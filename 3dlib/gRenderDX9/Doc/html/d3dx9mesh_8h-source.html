<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gRenderDX9: d3dx9mesh.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.1 -->
<h1>d3dx9mesh.h</h1><div class="fragment"><pre>00001 
00002 <span class="comment">//</span>
00003 <span class="comment">//  Copyright (C) Microsoft Corporation.  All Rights Reserved.</span>
00004 <span class="comment">//</span>
00005 <span class="comment">//  File:       d3dx9mesh.h</span>
00006 <span class="comment">//  Content:    D3DX mesh types and functions</span>
00007 <span class="comment">//</span>
00009 <span class="comment"></span>
00010 <span class="preprocessor">#include "d3dx9.h"</span>
00011 
00012 <span class="preprocessor">#ifndef __D3DX9MESH_H__</span>
00013 <span class="preprocessor"></span><span class="preprocessor">#define __D3DX9MESH_H__</span>
00014 <span class="preprocessor"></span>
00015 <span class="comment">// {7ED943DD-52E8-40b5-A8D8-76685C406330}</span>
00016 DEFINE_GUID(IID_ID3DXBaseMesh, 
00017 0x7ed943dd, 0x52e8, 0x40b5, 0xa8, 0xd8, 0x76, 0x68, 0x5c, 0x40, 0x63, 0x30);
00018 
00019 <span class="comment">// {4020E5C2-1403-4929-883F-E2E849FAC195}</span>
00020 DEFINE_GUID(IID_ID3DXMesh, 
00021 0x4020e5c2, 0x1403, 0x4929, 0x88, 0x3f, 0xe2, 0xe8, 0x49, 0xfa, 0xc1, 0x95);
00022 
00023 <span class="comment">// {8875769A-D579-4088-AAEB-534D1AD84E96}</span>
00024 DEFINE_GUID(IID_ID3DXPMesh, 
00025 0x8875769a, 0xd579, 0x4088, 0xaa, 0xeb, 0x53, 0x4d, 0x1a, 0xd8, 0x4e, 0x96);
00026 
00027 <span class="comment">// {667EA4C7-F1CD-4386-B523-7C0290B83CC5}</span>
00028 DEFINE_GUID(IID_ID3DXSPMesh, 
00029 0x667ea4c7, 0xf1cd, 0x4386, 0xb5, 0x23, 0x7c, 0x2, 0x90, 0xb8, 0x3c, 0xc5);
00030 
00031 <span class="comment">// {11EAA540-F9A6-4d49-AE6A-E19221F70CC4}</span>
00032 DEFINE_GUID(IID_ID3DXSkinInfo, 
00033 0x11eaa540, 0xf9a6, 0x4d49, 0xae, 0x6a, 0xe1, 0x92, 0x21, 0xf7, 0xc, 0xc4);
00034 
00035 <span class="comment">// {3CE6CC22-DBF2-44f4-894D-F9C34A337139}</span>
00036 DEFINE_GUID(IID_ID3DXPatchMesh, 
00037 0x3ce6cc22, 0xdbf2, 0x44f4, 0x89, 0x4d, 0xf9, 0xc3, 0x4a, 0x33, 0x71, 0x39);
00038 
00039 <span class="comment">//patch mesh can be quads or tris</span>
00040 <span class="keyword">typedef</span> <span class="keyword">enum</span> _D3DXPATCHMESHTYPE {
00041     D3DXPATCHMESH_RECT   = 0x001,
00042     D3DXPATCHMESH_TRI    = 0x002,
00043     D3DXPATCHMESH_NPATCH = 0x003,
00044 
00045     D3DXPATCHMESH_FORCE_DWORD    = 0x7fffffff, <span class="comment">/* force 32-bit size enum */</span>
00046 } D3DXPATCHMESHTYPE;
00047 
00048 <span class="comment">// Mesh options - lower 3 bytes only, upper byte used by _D3DXMESHOPT option flags</span>
00049 <span class="keyword">enum</span> _D3DXMESH {
00050     D3DXMESH_32BIT                  = 0x001, <span class="comment">// If set, then use 32 bit indices, if not set use 16 bit indices.</span>
00051     D3DXMESH_DONOTCLIP              = 0x002, <span class="comment">// Use D3DUSAGE_DONOTCLIP for VB &amp; IB.</span>
00052     D3DXMESH_POINTS                 = 0x004, <span class="comment">// Use D3DUSAGE_POINTS for VB &amp; IB. </span>
00053     D3DXMESH_RTPATCHES              = 0x008, <span class="comment">// Use D3DUSAGE_RTPATCHES for VB &amp; IB. </span>
00054     D3DXMESH_NPATCHES               = 0x4000,<span class="comment">// Use D3DUSAGE_NPATCHES for VB &amp; IB. </span>
00055     D3DXMESH_VB_SYSTEMMEM           = 0x010, <span class="comment">// Use D3DPOOL_SYSTEMMEM for VB. Overrides D3DXMESH_MANAGEDVERTEXBUFFER</span>
00056     D3DXMESH_VB_MANAGED             = 0x020, <span class="comment">// Use D3DPOOL_MANAGED for VB. </span>
00057     D3DXMESH_VB_WRITEONLY           = 0x040, <span class="comment">// Use D3DUSAGE_WRITEONLY for VB.</span>
00058     D3DXMESH_VB_DYNAMIC             = 0x080, <span class="comment">// Use D3DUSAGE_DYNAMIC for VB.</span>
00059     D3DXMESH_VB_SOFTWAREPROCESSING = 0x8000, <span class="comment">// Use D3DUSAGE_SOFTWAREPROCESSING for VB.</span>
00060     D3DXMESH_IB_SYSTEMMEM           = 0x100, <span class="comment">// Use D3DPOOL_SYSTEMMEM for IB. Overrides D3DXMESH_MANAGEDINDEXBUFFER</span>
00061     D3DXMESH_IB_MANAGED             = 0x200, <span class="comment">// Use D3DPOOL_MANAGED for IB.</span>
00062     D3DXMESH_IB_WRITEONLY           = 0x400, <span class="comment">// Use D3DUSAGE_WRITEONLY for IB.</span>
00063     D3DXMESH_IB_DYNAMIC             = 0x800, <span class="comment">// Use D3DUSAGE_DYNAMIC for IB.</span>
00064     D3DXMESH_IB_SOFTWAREPROCESSING= 0x10000, <span class="comment">// Use D3DUSAGE_SOFTWAREPROCESSING for IB.</span>
00065 
00066     D3DXMESH_VB_SHARE               = 0x1000, <span class="comment">// Valid for Clone* calls only, forces cloned mesh/pmesh to share vertex buffer</span>
00067 
00068     D3DXMESH_USEHWONLY              = 0x2000, <span class="comment">// Valid for ID3DXSkinInfo::ConvertToBlendedMesh</span>
00069 
00070     <span class="comment">// Helper options</span>
00071     D3DXMESH_SYSTEMMEM              = 0x110, <span class="comment">// D3DXMESH_VB_SYSTEMMEM | D3DXMESH_IB_SYSTEMMEM</span>
00072     D3DXMESH_MANAGED                = 0x220, <span class="comment">// D3DXMESH_VB_MANAGED | D3DXMESH_IB_MANAGED</span>
00073     D3DXMESH_WRITEONLY              = 0x440, <span class="comment">// D3DXMESH_VB_WRITEONLY | D3DXMESH_IB_WRITEONLY</span>
00074     D3DXMESH_DYNAMIC                = 0x880, <span class="comment">// D3DXMESH_VB_DYNAMIC | D3DXMESH_IB_DYNAMIC</span>
00075     D3DXMESH_SOFTWAREPROCESSING   = 0x18000, <span class="comment">// D3DXMESH_VB_SOFTWAREPROCESSING | D3DXMESH_IB_SOFTWAREPROCESSING</span>
00076 
00077 };
00078 
00079 <span class="comment">//patch mesh options</span>
00080 <span class="keyword">enum</span> _D3DXPATCHMESH {
00081     D3DXPATCHMESH_DEFAULT = 000,
00082 };
00083 <span class="comment">// option field values for specifying min value in D3DXGeneratePMesh and D3DXSimplifyMesh</span>
00084 <span class="keyword">enum</span> _D3DXMESHSIMP
00085 {
00086     D3DXMESHSIMP_VERTEX   = 0x1,
00087     D3DXMESHSIMP_FACE     = 0x2,
00088 
00089 };
00090 
00091 <span class="keyword">typedef</span> <span class="keyword">enum</span> _D3DXCLEANTYPE {
00092     D3DXCLEAN_BACKFACING    = 0x00000001,
00093     D3DXCLEAN_BOWTIES       = 0x00000002,
00094     
00095     <span class="comment">// Helper options</span>
00096     D3DXCLEAN_SKINNING      = D3DXCLEAN_BACKFACING, <span class="comment">// Bowtie cleaning modifies geometry and breaks skinning</span>
00097     D3DXCLEAN_OPTIMIZATION  = D3DXCLEAN_BACKFACING,
00098     D3DXCLEAN_SIMPLIFICATION= D3DXCLEAN_BACKFACING | D3DXCLEAN_BOWTIES, 
00099 } D3DXCLEANTYPE;
00100 
00101 <span class="keyword">enum</span> _MAX_FVF_DECL_SIZE
00102 {
00103     MAX_FVF_DECL_SIZE = MAXD3DDECLLENGTH + 1 <span class="comment">// +1 for END</span>
00104 };
00105 
00106 <span class="keyword">typedef</span> <span class="keyword">struct </span>ID3DXBaseMesh *LPD3DXBASEMESH;
00107 <span class="keyword">typedef</span> <span class="keyword">struct </span>ID3DXMesh *LPD3DXMESH;
00108 <span class="keyword">typedef</span> <span class="keyword">struct </span>ID3DXPMesh *LPD3DXPMESH;
00109 <span class="keyword">typedef</span> <span class="keyword">struct </span>ID3DXSPMesh *LPD3DXSPMESH;
00110 <span class="keyword">typedef</span> <span class="keyword">struct </span>ID3DXSkinInfo *LPD3DXSKININFO;
00111 <span class="keyword">typedef</span> <span class="keyword">struct </span>ID3DXPatchMesh *LPD3DXPATCHMESH;
00112 
00113 <span class="keyword">typedef</span> <span class="keyword">struct </span>_D3DXATTRIBUTERANGE
00114 {
00115     DWORD AttribId;
00116     DWORD FaceStart;
00117     DWORD FaceCount;
00118     DWORD VertexStart;
00119     DWORD VertexCount;
00120 } D3DXATTRIBUTERANGE;
00121 
00122 <span class="keyword">typedef</span> D3DXATTRIBUTERANGE* LPD3DXATTRIBUTERANGE;
00123 
00124 <span class="keyword">typedef</span> <span class="keyword">struct </span>_D3DXMATERIAL
00125 {
00126     D3DMATERIAL9  MatD3D;
00127     LPSTR         pTextureFilename;
00128 } D3DXMATERIAL;
00129 <span class="keyword">typedef</span> D3DXMATERIAL *LPD3DXMATERIAL;
00130 
00131 <span class="keyword">typedef</span> <span class="keyword">enum</span> _D3DXEFFECTDEFAULTTYPE
00132 {
00133     D3DXEDT_STRING = 0x1,       <span class="comment">// pValue points to a null terminated ASCII string </span>
00134     D3DXEDT_FLOATS = 0x2,       <span class="comment">// pValue points to an array of floats - number of floats is NumBytes / sizeof(float)</span>
00135     D3DXEDT_DWORD  = 0x3,       <span class="comment">// pValue points to a DWORD</span>
00136 
00137     D3DXEDT_FORCEDWORD = 0x7fffffff
00138 } D3DXEFFECTDEFAULTTYPE;
00139 
00140 <span class="keyword">typedef</span> <span class="keyword">struct </span>_D3DXEFFECTDEFAULT
00141 {
00142     LPSTR                 pParamName;
00143     D3DXEFFECTDEFAULTTYPE Type;           <span class="comment">// type of the data pointed to by pValue</span>
00144     DWORD                 NumBytes;       <span class="comment">// size in bytes of the data pointed to by pValue</span>
00145     LPVOID                pValue;         <span class="comment">// data for the default of the effect</span>
00146 } D3DXEFFECTDEFAULT, *LPD3DXEFFECTDEFAULT;
00147 
00148 <span class="keyword">typedef</span> <span class="keyword">struct </span>_D3DXEFFECTINSTANCE
00149 {
00150     LPSTR               pEffectFilename;
00151     DWORD               NumDefaults;
00152     LPD3DXEFFECTDEFAULT pDefaults;
00153 } D3DXEFFECTINSTANCE, *LPD3DXEFFECTINSTANCE;
00154 
00155 <span class="keyword">typedef</span> <span class="keyword">struct </span>_D3DXATTRIBUTEWEIGHTS
00156 {
00157     FLOAT Position;
00158     FLOAT Boundary;
00159     FLOAT Normal;
00160     FLOAT Diffuse;
00161     FLOAT Specular;
00162     FLOAT Texcoord[8];
00163     FLOAT Tangent;
00164     FLOAT Binormal;
00165 } D3DXATTRIBUTEWEIGHTS, *LPD3DXATTRIBUTEWEIGHTS;
00166 
00167 <span class="keyword">enum</span> _D3DXWELDEPSILONSFLAGS
00168 {
00169     D3DXWELDEPSILONS_WELDALL             = 0x1,  <span class="comment">// weld all vertices marked by adjacency as being overlapping</span>
00170 
00171     D3DXWELDEPSILONS_WELDPARTIALMATCHES  = 0x2,  <span class="comment">// if a given vertex component is within epsilon, modify partial matched </span>
00172                                                     <span class="comment">// vertices so that both components identical AND if all components "equal"</span>
00173                                                     <span class="comment">// remove one of the vertices</span>
00174     D3DXWELDEPSILONS_DONOTREMOVEVERTICES = 0x4,  <span class="comment">// instructs weld to only allow modifications to vertices and not removal</span>
00175                                                     <span class="comment">// ONLY valid if D3DXWELDEPSILONS_WELDPARTIALMATCHES is set</span>
00176                                                     <span class="comment">// useful to modify vertices to be equal, but not allow vertices to be removed</span>
00177 
00178     D3DXWELDEPSILONS_DONOTSPLIT          = 0x8,  <span class="comment">// instructs weld to specify the D3DXMESHOPT_DONOTSPLIT flag when doing an Optimize(ATTR_SORT)</span>
00179                                                     <span class="comment">// if this flag is not set, all vertices that are in separate attribute groups</span>
00180                                                     <span class="comment">// will remain split and not welded.  Setting this flag can slow down software vertex processing</span>
00181 
00182 };
00183 
00184 <span class="keyword">typedef</span> <span class="keyword">struct </span>_D3DXWELDEPSILONS
00185 {
00186     FLOAT Position;                 <span class="comment">// NOTE: This does NOT replace the epsilon in GenerateAdjacency</span>
00187                                             <span class="comment">// in general, it should be the same value or greater than the one passed to GeneratedAdjacency</span>
00188     FLOAT BlendWeights;
00189     FLOAT Normal;
00190     FLOAT PSize;
00191     FLOAT Specular;
00192     FLOAT Diffuse;
00193     FLOAT Texcoord[8];
00194     FLOAT Tangent;
00195     FLOAT Binormal;
00196     FLOAT TessFactor;
00197 } D3DXWELDEPSILONS;
00198 
00199 <span class="keyword">typedef</span> D3DXWELDEPSILONS* LPD3DXWELDEPSILONS;
00200 
00201 
00202 <span class="preprocessor">#undef INTERFACE</span>
00203 <span class="preprocessor"></span><span class="preprocessor">#define INTERFACE ID3DXBaseMesh</span>
00204 <span class="preprocessor"></span>
00205 DECLARE_INTERFACE_(ID3DXBaseMesh, IUnknown)
00206 {
00207     <span class="comment">// IUnknown</span>
00208     STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
00209     STDMETHOD_(ULONG, AddRef)(THIS) PURE;
00210     STDMETHOD_(ULONG, Release)(THIS) PURE;
00211 
00212     <span class="comment">// ID3DXBaseMesh</span>
00213     STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
00214     STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
00215     STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
00216     STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
00217     STDMETHOD(GetDeclaration)(THIS_ D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) PURE;
00218     STDMETHOD_(DWORD, GetNumBytesPerVertex)(THIS) PURE;
00219     STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
00220     STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE9* ppDevice) PURE;
00221     STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options, 
00222                 DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
00223     STDMETHOD(CloneMesh)(THIS_ DWORD Options, 
00224                 CONST D3DVERTEXELEMENT9 *pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
00225     STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER9* ppVB) PURE;
00226     STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER9* ppIB) PURE;
00227     STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, LPVOID *ppData) PURE;
00228     STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
00229     STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, LPVOID *ppData) PURE;
00230     STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
00231     STDMETHOD(GetAttributeTable)(
00232                 THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;
00233 
00234     STDMETHOD(ConvertPointRepsToAdjacency)(THIS_ CONST DWORD* pPRep, DWORD* pAdjacency) PURE;
00235     STDMETHOD(ConvertAdjacencyToPointReps)(THIS_ CONST DWORD* pAdjacency, DWORD* pPRep) PURE;
00236     STDMETHOD(GenerateAdjacency)(THIS_ FLOAT Epsilon, DWORD* pAdjacency) PURE;
00237 
00238     STDMETHOD(UpdateSemantics)(THIS_ D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) PURE;
00239 };
00240 
00241 
00242 <span class="preprocessor">#undef INTERFACE</span>
00243 <span class="preprocessor"></span><span class="preprocessor">#define INTERFACE ID3DXMesh</span>
00244 <span class="preprocessor"></span>
00245 DECLARE_INTERFACE_(ID3DXMesh, ID3DXBaseMesh)
00246 {
00247     <span class="comment">// IUnknown</span>
00248     STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
00249     STDMETHOD_(ULONG, AddRef)(THIS) PURE;
00250     STDMETHOD_(ULONG, Release)(THIS) PURE;
00251 
00252     <span class="comment">// ID3DXBaseMesh</span>
00253     STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
00254     STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
00255     STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
00256     STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
00257     STDMETHOD(GetDeclaration)(THIS_ D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) PURE;
00258     STDMETHOD_(DWORD, GetNumBytesPerVertex)(THIS) PURE;
00259     STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
00260     STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE9* ppDevice) PURE;
00261     STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options, 
00262                 DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
00263     STDMETHOD(CloneMesh)(THIS_ DWORD Options, 
00264                 CONST D3DVERTEXELEMENT9 *pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
00265     STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER9* ppVB) PURE;
00266     STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER9* ppIB) PURE;
00267     STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, LPVOID *ppData) PURE;
00268     STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
00269     STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, LPVOID *ppData) PURE;
00270     STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
00271     STDMETHOD(GetAttributeTable)(
00272                 THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;
00273 
00274     STDMETHOD(ConvertPointRepsToAdjacency)(THIS_ CONST DWORD* pPRep, DWORD* pAdjacency) PURE;
00275     STDMETHOD(ConvertAdjacencyToPointReps)(THIS_ CONST DWORD* pAdjacency, DWORD* pPRep) PURE;
00276     STDMETHOD(GenerateAdjacency)(THIS_ FLOAT Epsilon, DWORD* pAdjacency) PURE;
00277 
00278     STDMETHOD(UpdateSemantics)(THIS_ D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) PURE;
00279 
00280     <span class="comment">// ID3DXMesh</span>
00281     STDMETHOD(LockAttributeBuffer)(THIS_ DWORD Flags, DWORD** ppData) PURE;
00282     STDMETHOD(UnlockAttributeBuffer)(THIS) PURE;
00283     STDMETHOD(Optimize)(THIS_ DWORD Flags, CONST DWORD* pAdjacencyIn, DWORD* pAdjacencyOut, 
00284                      DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap,  
00285                      LPD3DXMESH* ppOptMesh) PURE;
00286     STDMETHOD(OptimizeInplace)(THIS_ DWORD Flags, CONST DWORD* pAdjacencyIn, DWORD* pAdjacencyOut, 
00287                      DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap) PURE;
00288     STDMETHOD(SetAttributeTable)(THIS_ CONST D3DXATTRIBUTERANGE *pAttribTable, DWORD cAttribTableSize) PURE;
00289 };
00290 
00291 
00292 <span class="preprocessor">#undef INTERFACE</span>
00293 <span class="preprocessor"></span><span class="preprocessor">#define INTERFACE ID3DXPMesh</span>
00294 <span class="preprocessor"></span>
00295 DECLARE_INTERFACE_(ID3DXPMesh, ID3DXBaseMesh)
00296 {
00297     <span class="comment">// IUnknown</span>
00298     STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
00299     STDMETHOD_(ULONG, AddRef)(THIS) PURE;
00300     STDMETHOD_(ULONG, Release)(THIS) PURE;
00301 
00302     <span class="comment">// ID3DXBaseMesh</span>
00303     STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
00304     STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
00305     STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
00306     STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
00307     STDMETHOD(GetDeclaration)(THIS_ D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) PURE;
00308     STDMETHOD_(DWORD, GetNumBytesPerVertex)(THIS) PURE;
00309     STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
00310     STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE9* ppDevice) PURE;
00311     STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options, 
00312                 DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
00313     STDMETHOD(CloneMesh)(THIS_ DWORD Options, 
00314                 CONST D3DVERTEXELEMENT9 *pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
00315     STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER9* ppVB) PURE;
00316     STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER9* ppIB) PURE;
00317     STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, LPVOID *ppData) PURE;
00318     STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
00319     STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, LPVOID *ppData) PURE;
00320     STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
00321     STDMETHOD(GetAttributeTable)(
00322                 THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;
00323 
00324     STDMETHOD(ConvertPointRepsToAdjacency)(THIS_ CONST DWORD* pPRep, DWORD* pAdjacency) PURE;
00325     STDMETHOD(ConvertAdjacencyToPointReps)(THIS_ CONST DWORD* pAdjacency, DWORD* pPRep) PURE;
00326     STDMETHOD(GenerateAdjacency)(THIS_ FLOAT Epsilon, DWORD* pAdjacency) PURE;
00327 
00328     STDMETHOD(UpdateSemantics)(THIS_ D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) PURE;
00329 
00330     <span class="comment">// ID3DXPMesh</span>
00331     STDMETHOD(ClonePMeshFVF)(THIS_ DWORD Options, 
00332                 DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXPMESH* ppCloneMesh) PURE;
00333     STDMETHOD(ClonePMesh)(THIS_ DWORD Options, 
00334                 CONST D3DVERTEXELEMENT9 *pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, LPD3DXPMESH* ppCloneMesh) PURE;
00335     STDMETHOD(SetNumFaces)(THIS_ DWORD Faces) PURE;
00336     STDMETHOD(SetNumVertices)(THIS_ DWORD Vertices) PURE;
00337     STDMETHOD_(DWORD, GetMaxFaces)(THIS) PURE;
00338     STDMETHOD_(DWORD, GetMinFaces)(THIS) PURE;
00339     STDMETHOD_(DWORD, GetMaxVertices)(THIS) PURE;
00340     STDMETHOD_(DWORD, GetMinVertices)(THIS) PURE;
00341     STDMETHOD(Save)(THIS_ IStream *pStream, CONST D3DXMATERIAL* pMaterials, CONST D3DXEFFECTINSTANCE* pEffectInstances, DWORD NumMaterials) PURE;
00342 
00343     STDMETHOD(Optimize)(THIS_ DWORD Flags, DWORD* pAdjacencyOut, 
00344                      DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap,  
00345                      LPD3DXMESH* ppOptMesh) PURE;
00346 
00347     STDMETHOD(OptimizeBaseLOD)(THIS_ DWORD Flags, DWORD* pFaceRemap) PURE;
00348     STDMETHOD(TrimByFaces)(THIS_ DWORD NewFacesMin, DWORD NewFacesMax, DWORD *rgiFaceRemap, DWORD *rgiVertRemap) PURE;
00349     STDMETHOD(TrimByVertices)(THIS_ DWORD NewVerticesMin, DWORD NewVerticesMax, DWORD *rgiFaceRemap, DWORD *rgiVertRemap) PURE;
00350 
00351     STDMETHOD(GetAdjacency)(THIS_ DWORD* pAdjacency) PURE;
00352 
00353     <span class="comment">//  Used to generate the immediate "ancestor" for each vertex when it is removed by a vsplit.  Allows generation of geomorphs</span>
00354     <span class="comment">//     Vertex buffer must be equal to or greater than the maximum number of vertices in the pmesh</span>
00355     STDMETHOD(GenerateVertexHistory)(THIS_ DWORD* pVertexHistory) PURE;
00356 };
00357 
00358 
00359 <span class="preprocessor">#undef INTERFACE</span>
00360 <span class="preprocessor"></span><span class="preprocessor">#define INTERFACE ID3DXSPMesh</span>
00361 <span class="preprocessor"></span>
00362 DECLARE_INTERFACE_(ID3DXSPMesh, IUnknown)
00363 {
00364     <span class="comment">// IUnknown</span>
00365     STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
00366     STDMETHOD_(ULONG, AddRef)(THIS) PURE;
00367     STDMETHOD_(ULONG, Release)(THIS) PURE;
00368 
00369     <span class="comment">// ID3DXSPMesh</span>
00370     STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
00371     STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
00372     STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
00373     STDMETHOD(GetDeclaration)(THIS_ D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) PURE;
00374     STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
00375     STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE9* ppDevice) PURE;
00376     STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options, 
00377                 DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, DWORD *pAdjacencyOut, DWORD *pVertexRemapOut, LPD3DXMESH* ppCloneMesh) PURE;
00378     STDMETHOD(CloneMesh)(THIS_ DWORD Options, 
00379                 CONST D3DVERTEXELEMENT9 *pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, DWORD *pAdjacencyOut, DWORD *pVertexRemapOut, LPD3DXMESH* ppCloneMesh) PURE;
00380     STDMETHOD(ClonePMeshFVF)(THIS_ DWORD Options, 
00381                 DWORD FVF, LPDIRECT3DDEVICE9 pD3DDevice, DWORD *pVertexRemapOut, FLOAT *pErrorsByFace, LPD3DXPMESH* ppCloneMesh) PURE;
00382     STDMETHOD(ClonePMesh)(THIS_ DWORD Options, 
00383                 CONST D3DVERTEXELEMENT9 *pDeclaration, LPDIRECT3DDEVICE9 pD3DDevice, DWORD *pVertexRemapOut, FLOAT *pErrorsbyFace, LPD3DXPMESH* ppCloneMesh) PURE;
00384     STDMETHOD(ReduceFaces)(THIS_ DWORD Faces) PURE;
00385     STDMETHOD(ReduceVertices)(THIS_ DWORD Vertices) PURE;
00386     STDMETHOD_(DWORD, GetMaxFaces)(THIS) PURE;
00387     STDMETHOD_(DWORD, GetMaxVertices)(THIS) PURE;
00388     STDMETHOD(GetVertexAttributeWeights)(THIS_ LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights) PURE;
00389     STDMETHOD(GetVertexWeights)(THIS_ FLOAT *pVertexWeights) PURE;
00390 };
00391 
00392 <span class="preprocessor">#define UNUSED16 (0xffff)</span>
00393 <span class="preprocessor"></span><span class="preprocessor">#define UNUSED32 (0xffffffff)</span>
00394 <span class="preprocessor"></span>
00395 <span class="comment">// ID3DXMesh::Optimize options - upper byte only, lower 3 bytes used from _D3DXMESH option flags</span>
00396 <span class="keyword">enum</span> _D3DXMESHOPT {
00397     D3DXMESHOPT_COMPACT       = 0x01000000,
00398     D3DXMESHOPT_ATTRSORT      = 0x02000000,
00399     D3DXMESHOPT_VERTEXCACHE   = 0x04000000,
00400     D3DXMESHOPT_STRIPREORDER  = 0x08000000,
00401     D3DXMESHOPT_IGNOREVERTS   = 0x10000000,  <span class="comment">// optimize faces only, don't touch vertices</span>
00402     D3DXMESHOPT_DONOTSPLIT    = 0x20000000,  <span class="comment">// do not split vertices shared between attribute groups when attribute sorting</span>
00403     D3DXMESHOPT_DEVICEINDEPENDENT = 0x00400000,  <span class="comment">// Only affects VCache.  uses a static known good cache size for all cards</span>
00404                             
00405     <span class="comment">// D3DXMESHOPT_SHAREVB has been removed, please use D3DXMESH_VB_SHARE instead</span>
00406 
00407 };
00408 
00409 <span class="comment">// Subset of the mesh that has the same attribute and bone combination.</span>
00410 <span class="comment">// This subset can be rendered in a single draw call</span>
00411 <span class="keyword">typedef</span> <span class="keyword">struct </span>_D3DXBONECOMBINATION
00412 {
00413     DWORD AttribId;
00414     DWORD FaceStart;
00415     DWORD FaceCount;
00416     DWORD VertexStart;
00417     DWORD VertexCount;
00418     DWORD* BoneId;
00419 } D3DXBONECOMBINATION, *LPD3DXBONECOMBINATION;
00420 
00421 <span class="comment">// The following types of patch combinations are supported:</span>
00422 <span class="comment">// Patch type   Basis       Degree</span>
00423 <span class="comment">// Rect         Bezier      2,3,5</span>
00424 <span class="comment">// Rect         B-Spline    2,3,5</span>
00425 <span class="comment">// Rect         Catmull-Rom 3</span>
00426 <span class="comment">// Tri          Bezier      2,3,5</span>
00427 <span class="comment">// N-Patch      N/A         3</span>
00428 
00429 <span class="keyword">typedef</span> <span class="keyword">struct </span>_D3DXPATCHINFO
00430 {
00431     D3DXPATCHMESHTYPE PatchType;
00432     D3DDEGREETYPE Degree;
00433     D3DBASISTYPE Basis;
00434 } D3DXPATCHINFO, *LPD3DXPATCHINFO;
00435 
00436 <span class="preprocessor">#undef INTERFACE</span>
00437 <span class="preprocessor"></span><span class="preprocessor">#define INTERFACE ID3DXPatchMesh</span>
00438 <span class="preprocessor"></span>
00439 DECLARE_INTERFACE_(ID3DXPatchMesh, IUnknown)
00440 {
00441     <span class="comment">// IUnknown</span>
00442     STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
00443     STDMETHOD_(ULONG, AddRef)(THIS) PURE;
00444     STDMETHOD_(ULONG, Release)(THIS) PURE;
00445 
00446     <span class="comment">// ID3DXPatchMesh</span>
00447 
00448     <span class="comment">// Return creation parameters</span>
00449     STDMETHOD_(DWORD, GetNumPatches)(THIS) PURE;
00450     STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
00451     STDMETHOD(GetDeclaration)(THIS_ D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) PURE;
00452     STDMETHOD_(DWORD, GetControlVerticesPerPatch)(THIS) PURE;
00453     STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
00454     STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE9 *ppDevice) PURE;
00455     STDMETHOD(GetPatchInfo)(THIS_ LPD3DXPATCHINFO PatchInfo) PURE;
00456 
00457     <span class="comment">// Control mesh access    </span>
00458     STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER9* ppVB) PURE;
00459     STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER9* ppIB) PURE;
00460     STDMETHOD(LockVertexBuffer)(THIS_ DWORD flags, LPVOID *ppData) PURE;
00461     STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
00462     STDMETHOD(LockIndexBuffer)(THIS_ DWORD flags, LPVOID *ppData) PURE;
00463     STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
00464     STDMETHOD(LockAttributeBuffer)(THIS_ DWORD flags, DWORD** ppData) PURE;
00465     STDMETHOD(UnlockAttributeBuffer)(THIS) PURE;
00466 
00467     <span class="comment">// This function returns the size of the tessellated mesh given a tessellation level.</span>
00468     <span class="comment">// This assumes uniform tessellation. For adaptive tessellation the Adaptive parameter must</span>
00469     <span class="comment">// be set to TRUE and TessellationLevel should be the max tessellation.</span>
00470     <span class="comment">// This will result in the max mesh size necessary for adaptive tessellation.    </span>
00471     STDMETHOD(GetTessSize)(THIS_ FLOAT fTessLevel,DWORD Adaptive, DWORD *NumTriangles,DWORD *NumVertices) PURE;
00472     
00473     <span class="comment">//GenerateAdjacency determines which patches are adjacent with provided tolerance</span>
00474     <span class="comment">//this information is used internally to optimize tessellation</span>
00475     STDMETHOD(GenerateAdjacency)(THIS_ FLOAT Tolerance) PURE;
00476     
00477     <span class="comment">//CloneMesh Creates a new patchmesh with the specified decl, and converts the vertex buffer</span>
00478     <span class="comment">//to the new decl. Entries in the new decl which are new are set to 0. If the current mesh</span>
00479     <span class="comment">//has adjacency, the new mesh will also have adjacency</span>
00480     STDMETHOD(CloneMesh)(THIS_ DWORD Options, CONST D3DVERTEXELEMENT9 *pDecl, LPD3DXPATCHMESH *pMesh) PURE;
00481     
00482     <span class="comment">// Optimizes the patchmesh for efficient tessellation. This function is designed</span>
00483     <span class="comment">// to perform one time optimization for patch meshes that need to be tessellated</span>
00484     <span class="comment">// repeatedly by calling the Tessellate() method. The optimization performed is</span>
00485     <span class="comment">// independent of the actual tessellation level used.</span>
00486     <span class="comment">// Currently Flags is unused.</span>
00487     <span class="comment">// If vertices are changed, Optimize must be called again</span>
00488     STDMETHOD(Optimize)(THIS_ DWORD flags) PURE;
00489 
00490     <span class="comment">//gets and sets displacement parameters</span>
00491     <span class="comment">//displacement maps can only be 2D textures MIP-MAPPING is ignored for non adapative tessellation</span>
00492     STDMETHOD(SetDisplaceParam)(THIS_ LPDIRECT3DBASETEXTURE9 Texture,
00493                               D3DTEXTUREFILTERTYPE MinFilter,
00494                               D3DTEXTUREFILTERTYPE MagFilter,
00495                               D3DTEXTUREFILTERTYPE MipFilter,
00496                               D3DTEXTUREADDRESS Wrap,
00497                               DWORD dwLODBias) PURE;
00498 
00499     STDMETHOD(GetDisplaceParam)(THIS_ LPDIRECT3DBASETEXTURE9 *Texture,
00500                                 D3DTEXTUREFILTERTYPE *MinFilter,
00501                                 D3DTEXTUREFILTERTYPE *MagFilter,
00502                                 D3DTEXTUREFILTERTYPE *MipFilter,
00503                                 D3DTEXTUREADDRESS *Wrap,
00504                                 DWORD *dwLODBias) PURE;
00505         
00506     <span class="comment">// Performs the uniform tessellation based on the tessellation level. </span>
00507     <span class="comment">// This function will perform more efficiently if the patch mesh has been optimized using the Optimize() call.</span>
00508     STDMETHOD(Tessellate)(THIS_ FLOAT fTessLevel,LPD3DXMESH pMesh) PURE;
00509 
00510     <span class="comment">// Performs adaptive tessellation based on the Z based adaptive tessellation criterion.</span>
00511     <span class="comment">// pTrans specifies a 4D vector that is dotted with the vertices to get the per vertex</span>
00512     <span class="comment">// adaptive tessellation amount. Each edge is tessellated to the average of the criterion</span>
00513     <span class="comment">// at the 2 vertices it connects.</span>
00514     <span class="comment">// MaxTessLevel specifies the upper limit for adaptive tesselation.</span>
00515     <span class="comment">// This function will perform more efficiently if the patch mesh has been optimized using the Optimize() call.</span>
00516     STDMETHOD(TessellateAdaptive)(THIS_ 
00517         CONST D3DXVECTOR4 *pTrans,
00518         DWORD dwMaxTessLevel, 
00519         DWORD dwMinTessLevel,
00520         LPD3DXMESH pMesh) PURE;
00521 
00522 };
00523 
00524 <span class="preprocessor">#undef INTERFACE</span>
00525 <span class="preprocessor"></span><span class="preprocessor">#define INTERFACE ID3DXSkinInfo</span>
00526 <span class="preprocessor"></span>
00527 DECLARE_INTERFACE_(ID3DXSkinInfo, IUnknown)
00528 {
00529     <span class="comment">// IUnknown</span>
00530     STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
00531     STDMETHOD_(ULONG, AddRef)(THIS) PURE;
00532     STDMETHOD_(ULONG, Release)(THIS) PURE;
00533 
00534     <span class="comment">// Specify the which vertices do each bones influence and by how much</span>
00535     STDMETHOD(SetBoneInfluence)(THIS_ DWORD bone, DWORD numInfluences, CONST DWORD* vertices, CONST FLOAT* weights) PURE;
00536     STDMETHOD(SetBoneVertexInfluence)(THIS_ DWORD boneNum, DWORD influenceNum, <span class="keywordtype">float</span> weight) PURE;
00537     STDMETHOD_(DWORD, GetNumBoneInfluences)(THIS_ DWORD bone) PURE;
00538     STDMETHOD(GetBoneInfluence)(THIS_ DWORD bone, DWORD* vertices, FLOAT* weights) PURE;
00539     STDMETHOD(GetBoneVertexInfluence)(THIS_ DWORD boneNum, DWORD influenceNum, <span class="keywordtype">float</span> *pWeight, DWORD *pVertexNum) PURE;
00540     STDMETHOD(GetMaxVertexInfluences)(THIS_ DWORD* maxVertexInfluences) PURE;
00541     STDMETHOD_(DWORD, GetNumBones)(THIS) PURE;
00542     STDMETHOD(FindBoneVertexInfluenceIndex)(THIS_ DWORD boneNum, DWORD vertexNum, DWORD *pInfluenceIndex) PURE;
00543 
00544     <span class="comment">// This gets the max face influences based on a triangle mesh with the specified index buffer</span>
00545     STDMETHOD(GetMaxFaceInfluences)(THIS_ LPDIRECT3DINDEXBUFFER9 pIB, DWORD NumFaces, DWORD* maxFaceInfluences) PURE;
00546     
00547     <span class="comment">// Set min bone influence. Bone influences that are smaller than this are ignored</span>
00548     STDMETHOD(SetMinBoneInfluence)(THIS_ FLOAT MinInfl) PURE;
00549     <span class="comment">// Get min bone influence. </span>
00550     STDMETHOD_(FLOAT, GetMinBoneInfluence)(THIS) PURE;
00551     
00552     <span class="comment">// Bone names are returned by D3DXLoadSkinMeshFromXof. They are not used by any other method of this object</span>
00553     STDMETHOD(SetBoneName)(THIS_ DWORD Bone, LPCSTR pName) PURE; <span class="comment">// pName is copied to an internal string buffer</span>
00554     STDMETHOD_(LPCSTR, GetBoneName)(THIS_ DWORD Bone) PURE; <span class="comment">// A pointer to an internal string buffer is returned. Do not free this.</span>
00555     
00556     <span class="comment">// Bone offset matrices are returned by D3DXLoadSkinMeshFromXof. They are not used by any other method of this object</span>
00557     STDMETHOD(SetBoneOffsetMatrix)(THIS_ DWORD Bone, CONST D3DXMATRIX *pBoneTransform) PURE; <span class="comment">// pBoneTransform is copied to an internal buffer</span>
00558     STDMETHOD_(LPD3DXMATRIX, GetBoneOffsetMatrix)(THIS_ DWORD Bone) PURE; <span class="comment">// A pointer to an internal matrix is returned. Do not free this.</span>
00559     
00560     <span class="comment">// Clone a skin info object</span>
00561     STDMETHOD(Clone)(THIS_ LPD3DXSKININFO* ppSkinInfo) PURE;
00562     
00563     <span class="comment">// Update bone influence information to match vertices after they are reordered. This should be called </span>
00564     <span class="comment">// if the target vertex buffer has been reordered externally.</span>
00565     STDMETHOD(Remap)(THIS_ DWORD NumVertices, DWORD* pVertexRemap) PURE;
00566 
00567     <span class="comment">// These methods enable the modification of the vertex layout of the vertices that will be skinned</span>
00568     STDMETHOD(SetFVF)(THIS_ DWORD FVF) PURE;
00569     STDMETHOD(SetDeclaration)(THIS_ CONST D3DVERTEXELEMENT9 *pDeclaration) PURE;
00570     STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
00571     STDMETHOD(GetDeclaration)(THIS_ D3DVERTEXELEMENT9 Declaration[MAX_FVF_DECL_SIZE]) PURE;
00572 
00573     <span class="comment">// Apply SW skinning based on current pose matrices to the target vertices.</span>
00574     STDMETHOD(UpdateSkinnedMesh)(THIS_ 
00575         CONST D3DXMATRIX* pBoneTransforms, 
00576         CONST D3DXMATRIX* pBoneInvTransposeTransforms, 
00577         LPCVOID pVerticesSrc, 
00578         PVOID pVerticesDst) PURE;
00579 
00580     <span class="comment">// Takes a mesh and returns a new mesh with per vertex blend weights and a bone combination</span>
00581     <span class="comment">// table that describes which bones affect which subsets of the mesh</span>
00582     STDMETHOD(ConvertToBlendedMesh)(THIS_ 
00583         LPD3DXMESH pMesh,
00584         DWORD Options, 
00585         CONST DWORD *pAdjacencyIn, 
00586         LPDWORD pAdjacencyOut,
00587         DWORD* pFaceRemap, 
00588         LPD3DXBUFFER *ppVertexRemap, 
00589         DWORD* pMaxFaceInfl,
00590         DWORD* pNumBoneCombinations, 
00591         LPD3DXBUFFER* ppBoneCombinationTable, 
00592         LPD3DXMESH* ppMesh) PURE;
00593 
00594     <span class="comment">// Takes a mesh and returns a new mesh with per vertex blend weights and indices </span>
00595     <span class="comment">// and a bone combination table that describes which bones palettes affect which subsets of the mesh</span>
00596     STDMETHOD(ConvertToIndexedBlendedMesh)(THIS_ 
00597         LPD3DXMESH pMesh,
00598         DWORD Options, 
00599         DWORD paletteSize, 
00600         CONST DWORD *pAdjacencyIn, 
00601         LPDWORD pAdjacencyOut, 
00602         DWORD* pFaceRemap, 
00603         LPD3DXBUFFER *ppVertexRemap, 
00604         DWORD* pMaxVertexInfl,
00605         DWORD* pNumBoneCombinations, 
00606         LPD3DXBUFFER* ppBoneCombinationTable, 
00607         LPD3DXMESH* ppMesh) PURE;
00608 };
00609 
00610 <span class="preprocessor">#ifdef __cplusplus</span>
00611 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00612 <span class="preprocessor">#endif //__cplusplus</span>
00613 <span class="preprocessor"></span>
00614 
00615 HRESULT WINAPI 
00616     D3DXCreateMesh(
00617         DWORD NumFaces, 
00618         DWORD NumVertices, 
00619         DWORD Options, 
00620         CONST D3DVERTEXELEMENT9 *pDeclaration, 
00621         LPDIRECT3DDEVICE9 pD3DDevice, 
00622         LPD3DXMESH* ppMesh);
00623 
00624 HRESULT WINAPI 
00625     D3DXCreateMeshFVF(
00626         DWORD NumFaces, 
00627         DWORD NumVertices, 
00628         DWORD Options, 
00629         DWORD FVF, 
00630         LPDIRECT3DDEVICE9 pD3DDevice, 
00631         LPD3DXMESH* ppMesh);
00632 
00633 HRESULT WINAPI 
00634     D3DXCreateSPMesh(
00635         LPD3DXMESH pMesh, 
00636         CONST DWORD* pAdjacency, 
00637         CONST D3DXATTRIBUTEWEIGHTS *pVertexAttributeWeights,
00638         CONST FLOAT *pVertexWeights,
00639         LPD3DXSPMESH* ppSMesh);
00640 
00641 <span class="comment">// clean a mesh up for simplification, try to make manifold</span>
00642 HRESULT WINAPI
00643     D3DXCleanMesh(
00644     D3DXCLEANTYPE CleanType,
00645     LPD3DXMESH pMeshIn,
00646     CONST DWORD* pAdjacencyIn,
00647     LPD3DXMESH* ppMeshOut,
00648     DWORD* pAdjacencyOut,
00649     LPD3DXBUFFER* ppErrorsAndWarnings);
00650 
00651 HRESULT WINAPI
00652     D3DXValidMesh(
00653     LPD3DXMESH pMeshIn,
00654     CONST DWORD* pAdjacency,
00655     LPD3DXBUFFER* ppErrorsAndWarnings);
00656 
00657 HRESULT WINAPI 
00658     D3DXGeneratePMesh(
00659         LPD3DXMESH pMesh, 
00660         CONST DWORD* pAdjacency, 
00661         CONST D3DXATTRIBUTEWEIGHTS *pVertexAttributeWeights,
00662         CONST FLOAT *pVertexWeights,
00663         DWORD MinValue, 
00664         DWORD Options, 
00665         LPD3DXPMESH* ppPMesh);
00666 
00667 HRESULT WINAPI 
00668     D3DXSimplifyMesh(
00669         LPD3DXMESH pMesh, 
00670         CONST DWORD* pAdjacency, 
00671         CONST D3DXATTRIBUTEWEIGHTS *pVertexAttributeWeights,
00672         CONST FLOAT *pVertexWeights,
00673         DWORD MinValue, 
00674         DWORD Options, 
00675         LPD3DXMESH* ppMesh);
00676 
00677 HRESULT WINAPI 
00678     D3DXComputeBoundingSphere(
00679         CONST D3DXVECTOR3 *pFirstPosition,  <span class="comment">// pointer to first position</span>
00680         DWORD NumVertices, 
00681         DWORD dwStride,                     <span class="comment">// count in bytes to subsequent position vectors</span>
00682         D3DXVECTOR3 *pCenter, 
00683         FLOAT *pRadius);
00684 
00685 HRESULT WINAPI 
00686     D3DXComputeBoundingBox(
00687         CONST D3DXVECTOR3 *pFirstPosition,  <span class="comment">// pointer to first position</span>
00688         DWORD NumVertices, 
00689         DWORD dwStride,                     <span class="comment">// count in bytes to subsequent position vectors</span>
00690         D3DXVECTOR3 *pMin, 
00691         D3DXVECTOR3 *pMax);
00692 
00693 HRESULT WINAPI 
00694     D3DXComputeNormals(
00695         LPD3DXBASEMESH pMesh,
00696         CONST DWORD *pAdjacency);
00697 
00698 HRESULT WINAPI 
00699     D3DXCreateBuffer(
00700         DWORD NumBytes, 
00701         LPD3DXBUFFER *ppBuffer);
00702 
00703 
00704 HRESULT WINAPI
00705     D3DXLoadMeshFromXA(
00706         LPCSTR pFilename, 
00707         DWORD Options, 
00708         LPDIRECT3DDEVICE9 pD3DDevice, 
00709         LPD3DXBUFFER *ppAdjacency,
00710         LPD3DXBUFFER *ppMaterials, 
00711         LPD3DXBUFFER *ppEffectInstances, 
00712         DWORD *pNumMaterials,
00713         LPD3DXMESH *ppMesh);
00714 
00715 HRESULT WINAPI
00716     D3DXLoadMeshFromXW(
00717         LPCWSTR pFilename, 
00718         DWORD Options, 
00719         LPDIRECT3DDEVICE9 pD3DDevice, 
00720         LPD3DXBUFFER *ppAdjacency,
00721         LPD3DXBUFFER *ppMaterials, 
00722         LPD3DXBUFFER *ppEffectInstances, 
00723         DWORD *pNumMaterials,
00724         LPD3DXMESH *ppMesh);
00725 
00726 <span class="preprocessor">#ifdef UNICODE</span>
00727 <span class="preprocessor"></span><span class="preprocessor">#define D3DXLoadMeshFromX D3DXLoadMeshFromXW</span>
00728 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00729 <span class="preprocessor"></span><span class="preprocessor">#define D3DXLoadMeshFromX D3DXLoadMeshFromXA</span>
00730 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00731 <span class="preprocessor"></span>
00732 HRESULT WINAPI 
00733     D3DXLoadMeshFromXInMemory(
00734         LPCVOID Memory,
00735         DWORD SizeOfMemory,
00736         DWORD Options, 
00737         LPDIRECT3DDEVICE9 pD3DDevice, 
00738         LPD3DXBUFFER *ppAdjacency,
00739         LPD3DXBUFFER *ppMaterials, 
00740         LPD3DXBUFFER *ppEffectInstances, 
00741         DWORD *pNumMaterials,
00742         LPD3DXMESH *ppMesh);
00743 
00744 HRESULT WINAPI 
00745     D3DXLoadMeshFromXResource(
00746         HMODULE Module,
00747         LPCSTR Name,
00748         LPCSTR Type,
00749         DWORD Options, 
00750         LPDIRECT3DDEVICE9 pD3DDevice, 
00751         LPD3DXBUFFER *ppAdjacency,
00752         LPD3DXBUFFER *ppMaterials, 
00753         LPD3DXBUFFER *ppEffectInstances, 
00754         DWORD *pNumMaterials,
00755         LPD3DXMESH *ppMesh);
00756 
00757 HRESULT WINAPI 
00758     D3DXSaveMeshToXA(
00759         LPCSTR pFilename,
00760         LPD3DXMESH pMesh,
00761         CONST DWORD* pAdjacency,
00762         CONST D3DXMATERIAL* pMaterials,
00763         CONST D3DXEFFECTINSTANCE* pEffectInstances, 
00764         DWORD NumMaterials,
00765         DWORD Format
00766         );
00767 
00768 HRESULT WINAPI 
00769     D3DXSaveMeshToXW(
00770         LPCWSTR pFilename,
00771         LPD3DXMESH pMesh,
00772         CONST DWORD* pAdjacency,
00773         CONST D3DXMATERIAL* pMaterials,
00774         CONST D3DXEFFECTINSTANCE* pEffectInstances, 
00775         DWORD NumMaterials,
00776         DWORD Format
00777         );
00778         
00779 <span class="preprocessor">#ifdef UNICODE</span>
00780 <span class="preprocessor"></span><span class="preprocessor">#define D3DXSaveMeshToX D3DXSaveMeshToXW</span>
00781 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00782 <span class="preprocessor"></span><span class="preprocessor">#define D3DXSaveMeshToX D3DXSaveMeshToXA</span>
00783 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00784 <span class="preprocessor"></span>        
00785 
00786 HRESULT WINAPI 
00787     D3DXCreatePMeshFromStream(
00788         IStream *pStream, 
00789         DWORD Options,
00790         LPDIRECT3DDEVICE9 pD3DDevice, 
00791         LPD3DXBUFFER *ppMaterials,
00792         LPD3DXBUFFER *ppEffectInstances, 
00793         DWORD* pNumMaterials,
00794         LPD3DXPMESH *ppPMesh);
00795 
00796 <span class="comment">// Creates a skin info object based on the number of vertices, number of bones, and a declaration describing the vertex layout of the target vertices</span>
00797 <span class="comment">// The bone names and initial bone transforms are not filled in the skin info object by this method.</span>
00798 HRESULT WINAPI
00799     D3DXCreateSkinInfo(
00800         DWORD NumVertices,
00801         CONST D3DVERTEXELEMENT9 *pDeclaration, 
00802         DWORD NumBones,
00803         LPD3DXSKININFO* ppSkinInfo);
00804         
00805 <span class="comment">// Creates a skin info object based on the number of vertices, number of bones, and a FVF describing the vertex layout of the target vertices</span>
00806 <span class="comment">// The bone names and initial bone transforms are not filled in the skin info object by this method.</span>
00807 HRESULT WINAPI
00808     D3DXCreateSkinInfoFVF(
00809         DWORD NumVertices,
00810         DWORD FVF,
00811         DWORD NumBones,
00812         LPD3DXSKININFO* ppSkinInfo);
00813         
00814 <span class="preprocessor">#ifdef __cplusplus</span>
00815 <span class="preprocessor"></span>}
00816 
00817 <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00818 <span class="preprocessor">#endif //__cplusplus</span>
00819 <span class="preprocessor"></span>
00820 HRESULT WINAPI 
00821     D3DXLoadMeshFromXof(
00822         LPD3DXFILEDATA pxofMesh, 
00823         DWORD Options, 
00824         LPDIRECT3DDEVICE9 pD3DDevice, 
00825         LPD3DXBUFFER *ppAdjacency,
00826         LPD3DXBUFFER *ppMaterials, 
00827         LPD3DXBUFFER *ppEffectInstances, 
00828         DWORD *pNumMaterials,
00829         LPD3DXMESH *ppMesh);
00830 
00831 <span class="comment">// This similar to D3DXLoadMeshFromXof, except also returns skinning info if present in the file</span>
00832 <span class="comment">// If skinning info is not present, ppSkinInfo will be NULL     </span>
00833 HRESULT WINAPI
00834     D3DXLoadSkinMeshFromXof(
00835         LPD3DXFILEDATA pxofMesh, 
00836         DWORD Options,
00837         LPDIRECT3DDEVICE9 pD3DDevice,
00838         LPD3DXBUFFER* ppAdjacency,
00839         LPD3DXBUFFER* ppMaterials,
00840         LPD3DXBUFFER *ppEffectInstances, 
00841         DWORD *pMatOut,
00842         LPD3DXSKININFO* ppSkinInfo,
00843         LPD3DXMESH* ppMesh);
00844 
00845 
00846 <span class="comment">// The inverse of D3DXConvertTo{Indexed}BlendedMesh() functions. It figures out the skinning info from</span>
00847 <span class="comment">// the mesh and the bone combination table and populates a skin info object with that data. The bone</span>
00848 <span class="comment">// names and initial bone transforms are not filled in the skin info object by this method. This works</span>
00849 <span class="comment">// with either a non-indexed or indexed blended mesh. It examines the FVF or declarator of the mesh to</span>
00850 <span class="comment">// determine what type it is.</span>
00851 HRESULT WINAPI
00852     D3DXCreateSkinInfoFromBlendedMesh(
00853         LPD3DXBASEMESH pMesh,
00854         DWORD NumBones,
00855         CONST D3DXBONECOMBINATION *pBoneCombinationTable,
00856         LPD3DXSKININFO* ppSkinInfo);
00857         
00858 HRESULT WINAPI
00859     D3DXTessellateNPatches(
00860         LPD3DXMESH pMeshIn,             
00861         CONST DWORD* pAdjacencyIn,             
00862         FLOAT NumSegs,                    
00863         BOOL  QuadraticInterpNormals,     <span class="comment">// if false use linear intrep for normals, if true use quadratic</span>
00864         LPD3DXMESH *ppMeshOut,
00865         LPD3DXBUFFER *ppAdjacencyOut);
00866 
00867 
00868 <span class="comment">//generates implied outputdecl from input decl</span>
00869 <span class="comment">//the decl generated from this should be used to generate the output decl for</span>
00870 <span class="comment">//the tessellator subroutines. </span>
00871 
00872 HRESULT WINAPI
00873     D3DXGenerateOutputDecl(
00874         D3DVERTEXELEMENT9 *pOutput,
00875         CONST D3DVERTEXELEMENT9 *pInput);
00876 
00877 <span class="comment">//loads patches from an XFileData</span>
00878 <span class="comment">//since an X file can have up to 6 different patch meshes in it,</span>
00879 <span class="comment">//returns them in an array - pNumPatches will contain the number of</span>
00880 <span class="comment">//meshes in the actual file. </span>
00881 HRESULT WINAPI
00882     D3DXLoadPatchMeshFromXof(
00883         LPD3DXFILEDATA pXofObjMesh,
00884         DWORD Options,
00885         LPDIRECT3DDEVICE9 pD3DDevice,
00886         LPD3DXBUFFER *ppMaterials,
00887         LPD3DXBUFFER *ppEffectInstances, 
00888         PDWORD pNumMaterials,
00889         LPD3DXPATCHMESH *ppMesh);
00890 
00891 <span class="comment">//computes the size a single rect patch.</span>
00892 HRESULT WINAPI
00893     D3DXRectPatchSize(
00894         CONST FLOAT *pfNumSegs, <span class="comment">//segments for each edge (4)</span>
00895         DWORD *pdwTriangles,    <span class="comment">//output number of triangles</span>
00896         DWORD *pdwVertices);    <span class="comment">//output number of vertices</span>
00897 
00898 <span class="comment">//computes the size of a single triangle patch      </span>
00899 HRESULT WINAPI
00900     D3DXTriPatchSize(
00901         CONST FLOAT *pfNumSegs, <span class="comment">//segments for each edge (3)    </span>
00902         DWORD *pdwTriangles,    <span class="comment">//output number of triangles</span>
00903         DWORD *pdwVertices);    <span class="comment">//output number of vertices</span>
00904 
00905 
00906 <span class="comment">//tessellates a patch into a created mesh</span>
00907 <span class="comment">//similar to D3D RT patch</span>
00908 HRESULT WINAPI
00909     D3DXTessellateRectPatch(
00910         LPDIRECT3DVERTEXBUFFER9 pVB,
00911         CONST FLOAT *pNumSegs,
00912         CONST D3DVERTEXELEMENT9 *pdwInDecl,
00913         CONST D3DRECTPATCH_INFO *pRectPatchInfo,
00914         LPD3DXMESH pMesh);
00915 
00916 
00917 HRESULT WINAPI
00918     D3DXTessellateTriPatch(
00919       LPDIRECT3DVERTEXBUFFER9 pVB,
00920       CONST FLOAT *pNumSegs,
00921       CONST D3DVERTEXELEMENT9 *pInDecl,
00922       CONST D3DTRIPATCH_INFO *pTriPatchInfo,
00923       LPD3DXMESH pMesh);
00924 
00925 
00926 
00927 <span class="comment">//creates an NPatch PatchMesh from a D3DXMESH </span>
00928 HRESULT WINAPI
00929     D3DXCreateNPatchMesh(
00930         LPD3DXMESH pMeshSysMem,
00931         LPD3DXPATCHMESH *pPatchMesh);
00932 
00933       
00934 <span class="comment">//creates a patch mesh</span>
00935 HRESULT WINAPI
00936     D3DXCreatePatchMesh(
00937         CONST D3DXPATCHINFO *pInfo,     <span class="comment">//patch type</span>
00938         DWORD dwNumPatches,             <span class="comment">//number of patches</span>
00939         DWORD dwNumVertices,            <span class="comment">//number of control vertices</span>
00940         DWORD dwOptions,                <span class="comment">//options </span>
00941         CONST D3DVERTEXELEMENT9 *pDecl, <span class="comment">//format of control vertices</span>
00942         LPDIRECT3DDEVICE9 pD3DDevice, 
00943         LPD3DXPATCHMESH *pPatchMesh);
00944 
00945         
00946 <span class="comment">//returns the number of degenerates in a patch mesh -</span>
00947 <span class="comment">//text output put in string.</span>
00948 HRESULT WINAPI
00949     D3DXValidPatchMesh(LPD3DXPATCHMESH pMesh,
00950                         DWORD *dwcDegenerateVertices,
00951                         DWORD *dwcDegeneratePatches,
00952                         LPD3DXBUFFER *ppErrorsAndWarnings);
00953 
00954 UINT WINAPI
00955     D3DXGetFVFVertexSize(DWORD FVF);
00956 
00957 UINT WINAPI 
00958     D3DXGetDeclVertexSize(CONST D3DVERTEXELEMENT9 *pDecl,DWORD Stream);
00959 
00960 UINT WINAPI 
00961     D3DXGetDeclLength(CONST D3DVERTEXELEMENT9 *pDecl);
00962 
00963 HRESULT WINAPI
00964     D3DXDeclaratorFromFVF(
00965         DWORD FVF,
00966         D3DVERTEXELEMENT9 pDeclarator[MAX_FVF_DECL_SIZE]);
00967 
00968 HRESULT WINAPI
00969     D3DXFVFFromDeclarator(
00970         CONST D3DVERTEXELEMENT9 *pDeclarator,
00971         DWORD *pFVF);
00972 
00973 HRESULT WINAPI 
00974     D3DXWeldVertices(
00975         LPD3DXMESH pMesh,         
00976         DWORD Flags,
00977         CONST D3DXWELDEPSILONS *pEpsilons,                 
00978         CONST DWORD *pAdjacencyIn, 
00979         DWORD *pAdjacencyOut,
00980         DWORD *pFaceRemap, 
00981         LPD3DXBUFFER *ppVertexRemap);
00982 
00983 <span class="keyword">typedef</span> <span class="keyword">struct </span>_D3DXINTERSECTINFO
00984 {
00985     DWORD FaceIndex;                <span class="comment">// index of face intersected</span>
00986     FLOAT U;                        <span class="comment">// Barycentric Hit Coordinates    </span>
00987     FLOAT V;                        <span class="comment">// Barycentric Hit Coordinates</span>
00988     FLOAT Dist;                     <span class="comment">// Ray-Intersection Parameter Distance</span>
00989 } D3DXINTERSECTINFO, *LPD3DXINTERSECTINFO;
00990 
00991 
00992 HRESULT WINAPI
00993     D3DXIntersect(
00994         LPD3DXBASEMESH pMesh,
00995         CONST D3DXVECTOR3 *pRayPos,
00996         CONST D3DXVECTOR3 *pRayDir, 
00997         BOOL    *pHit,              <span class="comment">// True if any faces were intersected</span>
00998         DWORD   *pFaceIndex,        <span class="comment">// index of closest face intersected</span>
00999         FLOAT   *pU,                <span class="comment">// Barycentric Hit Coordinates    </span>
01000         FLOAT   *pV,                <span class="comment">// Barycentric Hit Coordinates</span>
01001         FLOAT   *pDist,             <span class="comment">// Ray-Intersection Parameter Distance</span>
01002         LPD3DXBUFFER *ppAllHits,    <span class="comment">// Array of D3DXINTERSECTINFOs for all hits (not just closest) </span>
01003         DWORD   *pCountOfHits);     <span class="comment">// Number of entries in AllHits array</span>
01004 
01005 HRESULT WINAPI
01006     D3DXIntersectSubset(
01007         LPD3DXBASEMESH pMesh,
01008         DWORD AttribId,
01009         CONST D3DXVECTOR3 *pRayPos,
01010         CONST D3DXVECTOR3 *pRayDir, 
01011         BOOL    *pHit,              <span class="comment">// True if any faces were intersected</span>
01012         DWORD   *pFaceIndex,        <span class="comment">// index of closest face intersected</span>
01013         FLOAT   *pU,                <span class="comment">// Barycentric Hit Coordinates    </span>
01014         FLOAT   *pV,                <span class="comment">// Barycentric Hit Coordinates</span>
01015         FLOAT   *pDist,             <span class="comment">// Ray-Intersection Parameter Distance</span>
01016         LPD3DXBUFFER *ppAllHits,    <span class="comment">// Array of D3DXINTERSECTINFOs for all hits (not just closest) </span>
01017         DWORD   *pCountOfHits);     <span class="comment">// Number of entries in AllHits array</span>
01018 
01019 
01020 HRESULT WINAPI D3DXSplitMesh
01021     (
01022     LPD3DXMESH pMeshIn,         
01023     CONST DWORD *pAdjacencyIn, 
01024     CONST DWORD MaxSize,
01025     CONST DWORD Options,
01026     DWORD *pMeshesOut,
01027     LPD3DXBUFFER *ppMeshArrayOut,
01028     LPD3DXBUFFER *ppAdjacencyArrayOut,
01029     LPD3DXBUFFER *ppFaceRemapArrayOut,
01030     LPD3DXBUFFER *ppVertRemapArrayOut
01031     );
01032 
01033 BOOL WINAPI D3DXIntersectTri 
01034 (
01035     CONST D3DXVECTOR3 *p0,           <span class="comment">// Triangle vertex 0 position</span>
01036     CONST D3DXVECTOR3 *p1,           <span class="comment">// Triangle vertex 1 position</span>
01037     CONST D3DXVECTOR3 *p2,           <span class="comment">// Triangle vertex 2 position</span>
01038     CONST D3DXVECTOR3 *pRayPos,      <span class="comment">// Ray origin</span>
01039     CONST D3DXVECTOR3 *pRayDir,      <span class="comment">// Ray direction</span>
01040     FLOAT *pU,                       <span class="comment">// Barycentric Hit Coordinates</span>
01041     FLOAT *pV,                       <span class="comment">// Barycentric Hit Coordinates</span>
01042     FLOAT *pDist);                   <span class="comment">// Ray-Intersection Parameter Distance</span>
01043 
01044 BOOL WINAPI
01045     D3DXSphereBoundProbe(
01046         CONST D3DXVECTOR3 *pCenter,
01047         FLOAT Radius,
01048         CONST D3DXVECTOR3 *pRayPosition,
01049         CONST D3DXVECTOR3 *pRayDirection);
01050 
01051 BOOL WINAPI 
01052     D3DXBoxBoundProbe(
01053         CONST D3DXVECTOR3 *pMin, 
01054         CONST D3DXVECTOR3 *pMax,
01055         CONST D3DXVECTOR3 *pRayPosition,
01056         CONST D3DXVECTOR3 *pRayDirection);
01057 
01058 
01059 
01060 <span class="comment">//D3DXComputeTangent</span>
01061 <span class="comment">//</span>
01062 <span class="comment">//Computes the Tangent vectors for the TexStage texture coordinates</span>
01063 <span class="comment">//and places the results in the TANGENT[TangentIndex] specified in the meshes' DECL</span>
01064 <span class="comment">//puts the binorm in BINORM[BinormIndex] also specified in the decl.</span>
01065 <span class="comment">//</span>
01066 <span class="comment">//If neither the binorm or the tangnet are in the meshes declaration,</span>
01067 <span class="comment">//the function will fail. </span>
01068 <span class="comment">//</span>
01069 <span class="comment">//If a tangent or Binorm field is in the Decl, but the user does not</span>
01070 <span class="comment">//wish D3DXComputeTangent to replace them, then D3DX_DEFAULT specified</span>
01071 <span class="comment">//in the TangentIndex or BinormIndex will cause it to ignore the specified </span>
01072 <span class="comment">//semantic.</span>
01073 <span class="comment">//</span>
01074 <span class="comment">//Wrap should be specified if the texture coordinates wrap.</span>
01075 
01076 HRESULT WINAPI D3DXComputeTangent(LPD3DXMESH Mesh,
01077                                  DWORD TexStage,
01078                                  DWORD TangentIndex,
01079                                  DWORD BinormIndex,
01080                                  DWORD Wrap,
01081                                  CONST DWORD *pAdjacency);
01082 
01083 HRESULT WINAPI
01084     D3DXConvertMeshSubsetToSingleStrip(
01085         LPD3DXBASEMESH MeshIn,
01086         DWORD AttribId,
01087         DWORD IBOptions,
01088         LPDIRECT3DINDEXBUFFER9 *ppIndexBuffer,
01089         DWORD *pNumIndices);
01090 
01091 HRESULT WINAPI
01092     D3DXConvertMeshSubsetToStrips(
01093         LPD3DXBASEMESH MeshIn,
01094         DWORD AttribId,
01095         DWORD IBOptions,
01096         LPDIRECT3DINDEXBUFFER9 *ppIndexBuffer,
01097         DWORD *pNumIndices,
01098         LPD3DXBUFFER *ppStripLengths,
01099         DWORD *pNumStrips);
01100 
01101         
01102 <span class="comment">//============================================================================</span>
01103 <span class="comment">//</span>
01104 <span class="comment">//  D3DXOptimizeFaces:</span>
01105 <span class="comment">//  --------------------</span>
01106 <span class="comment">//  Generate a face remapping for a triangle list that more effectively utilizes</span>
01107 <span class="comment">//    vertex caches.  This optimization is identical to the one provided</span>
01108 <span class="comment">//    by ID3DXMesh::Optimize with the hardware independent option enabled.</span>
01109 <span class="comment">//</span>
01110 <span class="comment">//  Parameters:</span>
01111 <span class="comment">//   pbIndices</span>
01112 <span class="comment">//      Triangle list indices to use for generating a vertex ordering</span>
01113 <span class="comment">//   NumFaces</span>
01114 <span class="comment">//      Number of faces in the triangle list</span>
01115 <span class="comment">//   NumVertices</span>
01116 <span class="comment">//      Number of vertices referenced by the triangle list</span>
01117 <span class="comment">//   b32BitIndices</span>
01118 <span class="comment">//      TRUE if indices are 32 bit, FALSE if indices are 16 bit</span>
01119 <span class="comment">//   pFaceRemap</span>
01120 <span class="comment">//      Destination buffer to store face ordering</span>
01121 <span class="comment">//      The number stored for a given element is where in the new ordering</span>
01122 <span class="comment">//        the face will have come from.  See ID3DXMesh::Optimize for more info.</span>
01123 <span class="comment">//</span>
01124 <span class="comment">//============================================================================</span>
01125 HRESULT WINAPI
01126     D3DXOptimizeFaces(
01127         LPCVOID pbIndices, 
01128         UINT cFaces, 
01129         UINT cVertices, 
01130         BOOL b32BitIndices, 
01131         DWORD* pFaceRemap);
01132         
01133 <span class="comment">//============================================================================</span>
01134 <span class="comment">//</span>
01135 <span class="comment">//  D3DXOptimizeVertices:</span>
01136 <span class="comment">//  --------------------</span>
01137 <span class="comment">//  Generate a vertex remapping to optimize for in order use of vertices for </span>
01138 <span class="comment">//    a given set of indices.  This is commonly used after applying the face</span>
01139 <span class="comment">//    remap generated by D3DXOptimizeFaces</span>
01140 <span class="comment">//</span>
01141 <span class="comment">//  Parameters:</span>
01142 <span class="comment">//   pbIndices</span>
01143 <span class="comment">//      Triangle list indices to use for generating a vertex ordering</span>
01144 <span class="comment">//   NumFaces</span>
01145 <span class="comment">//      Number of faces in the triangle list</span>
01146 <span class="comment">//   NumVertices</span>
01147 <span class="comment">//      Number of vertices referenced by the triangle list</span>
01148 <span class="comment">//   b32BitIndices</span>
01149 <span class="comment">//      TRUE if indices are 32 bit, FALSE if indices are 16 bit</span>
01150 <span class="comment">//   pVertexRemap</span>
01151 <span class="comment">//      Destination buffer to store vertex ordering</span>
01152 <span class="comment">//      The number stored for a given element is where in the new ordering</span>
01153 <span class="comment">//        the vertex will have come from.  See ID3DXMesh::Optimize for more info.</span>
01154 <span class="comment">//</span>
01155 <span class="comment">//============================================================================</span>
01156 HRESULT WINAPI
01157     D3DXOptimizeVertices(
01158         LPCVOID pbIndices, 
01159         UINT cFaces, 
01160         UINT cVertices, 
01161         BOOL b32BitIndices, 
01162         DWORD* pVertexRemap);
01163 
01164 <span class="preprocessor">#ifdef __cplusplus</span>
01165 <span class="preprocessor"></span>}
01166 <span class="preprocessor">#endif //__cplusplus</span>
01167 <span class="preprocessor"></span>
01168 
01169 <span class="comment">//===========================================================================</span>
01170 <span class="comment">//</span>
01171 <span class="comment">//  Data structures for Spherical Harmonic Precomputation</span>
01172 <span class="comment">//</span>
01173 <span class="comment">//</span>
01174 <span class="comment">//============================================================================</span>
01175 
01176 <span class="keyword">typedef</span> <span class="keyword">enum</span> _D3DXSHCOMPRESSQUALITYTYPE {
01177     D3DXSHCQUAL_FASTLOWQUALITY  = 1,
01178     D3DXSHCQUAL_SLOWHIGHQUALITY = 2,
01179     D3DXSHCQUAL_FORCE_DWORD     = 0x7fffffff
01180 } D3DXSHCOMPRESSQUALITYTYPE;
01181 
01182 <span class="keyword">typedef</span> <span class="keyword">enum</span> _D3DXSHGPUSIMOPT {
01183     D3DXSHGPUSIMOPT_SHADOWRES256  = 1,
01184     D3DXSHGPUSIMOPT_SHADOWRES512  = 0,
01185     D3DXSHGPUSIMOPT_SHADOWRES1024 = 2,
01186     D3DXSHGPUSIMOPT_SHADOWRES2048 = 3,
01187 
01188     D3DXSHGPUSIMOPT_HIGHQUALITY = 4,    
01189     
01190     D3DXSHGPUSIMOPT_FORCE_DWORD = 0x7fffffff
01191 } D3DXSHGPUSIMOPT;
01192 
01193 <span class="comment">// for all properties that are colors the luminance is computed</span>
01194 <span class="comment">// if the simulator is run with a single channel using the following</span>
01195 <span class="comment">// formula:  R * 0.2125 + G * 0.7154 + B * 0.0721</span>
01196 
01197 <span class="keyword">typedef</span> <span class="keyword">struct </span>_D3DXSHMATERIAL {
01198     D3DCOLORVALUE Diffuse;  <span class="comment">// Diffuse albedo of the surface.  (Ignored if object is a Mirror)</span>
01199     BOOL          bMirror;  <span class="comment">// Must be set to FALSE.  bMirror == TRUE not currently supported</span>
01200     BOOL          bSubSurf; <span class="comment">// true if the object does subsurface scattering - can't do this and be a mirror</span>
01201 
01202     <span class="comment">// subsurface scattering parameters </span>
01203     FLOAT         RelativeIndexOfRefraction;
01204     D3DCOLORVALUE Absorption;
01205     D3DCOLORVALUE ReducedScattering;
01206 
01207 } D3DXSHMATERIAL;
01208 
01209 <span class="comment">// allocated in D3DXSHPRTCompSplitMeshSC</span>
01210 <span class="comment">// vertices are duplicated into multiple super clusters but</span>
01211 <span class="comment">// only have a valid status in one super cluster (fill in the rest)</span>
01212 
01213 <span class="keyword">typedef</span> <span class="keyword">struct </span>_D3DXSHPRTSPLITMESHVERTDATA {
01214     UINT  uVertRemap;   <span class="comment">// vertex in original mesh this corresponds to</span>
01215     UINT  uSubCluster;  <span class="comment">// cluster index relative to super cluster</span>
01216     UCHAR ucVertStatus; <span class="comment">// 1 if vertex has valid data, 0 if it is "fill"</span>
01217 } D3DXSHPRTSPLITMESHVERTDATA;
01218 
01219 <span class="comment">// used in D3DXSHPRTCompSplitMeshSC</span>
01220 <span class="comment">// information for each super cluster that maps into face/vert arrays</span>
01221 
01222 <span class="keyword">typedef</span> <span class="keyword">struct </span>_D3DXSHPRTSPLITMESHCLUSTERDATA {
01223     UINT uVertStart;     <span class="comment">// initial index into remapped vertex array</span>
01224     UINT uVertLength;    <span class="comment">// number of vertices in this super cluster</span>
01225     
01226     UINT uFaceStart;     <span class="comment">// initial index into face array</span>
01227     UINT uFaceLength;    <span class="comment">// number of faces in this super cluster</span>
01228     
01229     UINT uClusterStart;  <span class="comment">// initial index into cluster array</span>
01230     UINT uClusterLength; <span class="comment">// number of clusters in this super cluster</span>
01231 } D3DXSHPRTSPLITMESHCLUSTERDATA;
01232 
01233 <span class="comment">// call back function for simulator</span>
01234 <span class="comment">// return S_OK to keep running the simulator - anything else represents</span>
01235 <span class="comment">// failure and the simulator will abort.</span>
01236 
01237 <span class="keyword">typedef</span> HRESULT (WINAPI *LPD3DXSHPRTSIMCB)(<span class="keywordtype">float</span> fPercentDone,  LPVOID lpUserContext);
01238 
01239 <span class="comment">// interfaces for PRT buffers/simulator</span>
01240 
01241 <span class="comment">// GUIDs</span>
01242 <span class="comment">// {F1827E47-00A8-49cd-908C-9D11955F8728}</span>
01243 DEFINE_GUID(IID_ID3DXPRTBuffer, 
01244 0xf1827e47, 0xa8, 0x49cd, 0x90, 0x8c, 0x9d, 0x11, 0x95, 0x5f, 0x87, 0x28);
01245 
01246 <span class="comment">// {A758D465-FE8D-45ad-9CF0-D01E56266A07}</span>
01247 DEFINE_GUID(IID_ID3DXPRTCompBuffer, 
01248 0xa758d465, 0xfe8d, 0x45ad, 0x9c, 0xf0, 0xd0, 0x1e, 0x56, 0x26, 0x6a, 0x7);
01249 
01250 <span class="comment">// {06F57E0A-BD95-43f1-A3DA-791CF6CA297B}</span>
01251 DEFINE_GUID(IID_ID3DXTextureGutterHelper, 
01252 0x6f57e0a, 0xbd95, 0x43f1, 0xa3, 0xda, 0x79, 0x1c, 0xf6, 0xca, 0x29, 0x7b);
01253 
01254 <span class="comment">// {C3F4ADBF-E6D2-4b7b-BFE8-9E7208746ADF}</span>
01255 DEFINE_GUID(IID_ID3DXPRTEngine, 
01256 0xc3f4adbf, 0xe6d2, 0x4b7b, 0xbf, 0xe8, 0x9e, 0x72, 0x8, 0x74, 0x6a, 0xdf);
01257 
01258 <span class="comment">// interface defenitions</span>
01259 
01260 
01261 <span class="keyword">typedef</span> interface ID3DXTextureGutterHelper ID3DXTextureGutterHelper;
01262 <span class="keyword">typedef</span> interface ID3DXTextureGutterHelper *LPD3DXTEXTUREGUTTERHELPER;
01263 
01264 <span class="keyword">typedef</span> interface ID3DXPRTBuffer ID3DXPRTBuffer;
01265 <span class="keyword">typedef</span> interface ID3DXPRTBuffer *LPD3DXPRTBUFFER;
01266 
01267 
01268 <span class="preprocessor">#undef INTERFACE</span>
01269 <span class="preprocessor"></span><span class="preprocessor">#define INTERFACE ID3DXPRTBuffer</span>
01270 <span class="preprocessor"></span>
01271 <span class="comment">// Buffer interface - contains "NumSamples" samples</span>
01272 <span class="comment">// each sample in memory is stored as NumCoeffs scalars per channel (1 or 3)</span>
01273 <span class="comment">// Same interface is used for both Vertex and Pixel PRT buffers</span>
01274 
01275 DECLARE_INTERFACE_(ID3DXPRTBuffer, IUnknown)
01276 {
01277     <span class="comment">// IUnknown</span>
01278     STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
01279     STDMETHOD_(ULONG, AddRef)(THIS) PURE;
01280     STDMETHOD_(ULONG, Release)(THIS) PURE;
01281 
01282     <span class="comment">// ID3DXPRTBuffer</span>
01283     STDMETHOD_(UINT, GetNumSamples)(THIS) PURE;
01284     STDMETHOD_(UINT, GetNumCoeffs)(THIS) PURE;
01285     STDMETHOD_(UINT, GetNumChannels)(THIS) PURE;
01286 
01287     STDMETHOD_(BOOL, IsTexture)(THIS) PURE;
01288     STDMETHOD_(UINT, GetWidth)(THIS) PURE;
01289     STDMETHOD_(UINT, GetHeight)(THIS) PURE;
01290 
01291     <span class="comment">// changes the number of samples allocated in the buffer</span>
01292     STDMETHOD(Resize)(THIS_ UINT NewSize) PURE;
01293 
01294     <span class="comment">// ppData will point to the memory location where sample Start begins</span>
01295     <span class="comment">// pointer is valid for at least NumSamples samples</span>
01296     STDMETHOD(LockBuffer)(THIS_ UINT Start, UINT NumSamples, FLOAT **ppData) PURE;
01297     STDMETHOD(UnlockBuffer)(THIS) PURE;
01298 
01299     <span class="comment">// every scalar in buffer is multiplied by Scale</span>
01300     STDMETHOD(ScaleBuffer)(THIS_ FLOAT Scale) PURE;
01301     
01302     <span class="comment">// every scalar contains the sum of this and pBuffers values</span>
01303     <span class="comment">// pBuffer must have the same storage class/dimensions </span>
01304     STDMETHOD(AddBuffer)(THIS_ LPD3DXPRTBUFFER pBuffer) PURE;
01305 
01306     <span class="comment">// GutterHelper (described below) will fill in the gutter</span>
01307     <span class="comment">// regions of a texture by interpolating "internal" values</span>
01308     STDMETHOD(AttachGH)(THIS_ LPD3DXTEXTUREGUTTERHELPER) PURE;
01309     STDMETHOD(ReleaseGH)(THIS) PURE;
01310     
01311     <span class="comment">// Evaluates attached gutter helper on the contents of this buffer</span>
01312     STDMETHOD(EvalGH)(THIS) PURE;
01313 
01314     <span class="comment">// extracts a given channel into texture pTexture</span>
01315     <span class="comment">// NumCoefficients starting from StartCoefficient are copied</span>
01316     STDMETHOD(ExtractTexture)(THIS_ UINT Channel, UINT StartCoefficient, 
01317                               UINT NumCoefficients, LPDIRECT3DTEXTURE9 pTexture) PURE;
01318 
01319     <span class="comment">// extracts NumCoefficients coefficients into mesh - only applicable on single channel</span>
01320     <span class="comment">// buffers, otherwise just lockbuffer and copy data.  With SHPRT data NumCoefficients </span>
01321     <span class="comment">// should be Order^2</span>
01322     STDMETHOD(ExtractToMesh)(THIS_ UINT NumCoefficients, D3DDECLUSAGE Usage, UINT UsageIndexStart,
01323                              LPD3DXMESH pScene) PURE;
01324 
01325 };
01326 
01327 <span class="keyword">typedef</span> interface ID3DXPRTCompBuffer ID3DXPRTCompBuffer;
01328 <span class="keyword">typedef</span> interface ID3DXPRTCompBuffer *LPD3DXPRTCOMPBUFFER;
01329 
01330 <span class="preprocessor">#undef INTERFACE</span>
01331 <span class="preprocessor"></span><span class="preprocessor">#define INTERFACE ID3DXPRTCompBuffer</span>
01332 <span class="preprocessor"></span>
01333 <span class="comment">// compressed buffers stored a compressed version of a PRTBuffer</span>
01334 
01335 DECLARE_INTERFACE_(ID3DXPRTCompBuffer, IUnknown)
01336 {
01337     <span class="comment">// IUnknown</span>
01338     STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
01339     STDMETHOD_(ULONG, AddRef)(THIS) PURE;
01340     STDMETHOD_(ULONG, Release)(THIS) PURE;
01341 
01342     <span class="comment">// ID3DPRTCompBuffer</span>
01343 
01344     <span class="comment">// NumCoeffs and NumChannels are properties of input buffer</span>
01345     STDMETHOD_(UINT, GetNumSamples)(THIS) PURE;
01346     STDMETHOD_(UINT, GetNumCoeffs)(THIS) PURE;
01347     STDMETHOD_(UINT, GetNumChannels)(THIS) PURE;
01348 
01349     STDMETHOD_(BOOL, IsTexture)(THIS) PURE;
01350     STDMETHOD_(UINT, GetWidth)(THIS) PURE;
01351     STDMETHOD_(UINT, GetHeight)(THIS) PURE;
01352 
01353     <span class="comment">// number of clusters, and PCA vectors per-cluster</span>
01354     STDMETHOD_(UINT, GetNumClusters)(THIS) PURE;
01355     STDMETHOD_(UINT, GetNumPCA)(THIS) PURE;
01356 
01357     <span class="comment">// normalizes PCA weights so that they are between [-1,1]</span>
01358     <span class="comment">// basis vectors are modified to reflect this</span>
01359     STDMETHOD(NormalizeData)(THIS) PURE;
01360 
01361     <span class="comment">// copies basis vectors for cluster "Cluster" into pClusterBasis</span>
01362     <span class="comment">// (NumPCA+1)*NumCoeffs*NumChannels floats</span>
01363     STDMETHOD(ExtractBasis)(THIS_ UINT Cluster, FLOAT *pClusterBasis) PURE;
01364     
01365     <span class="comment">// UINT per sample - which cluster it belongs to</span>
01366     STDMETHOD(ExtractClusterIDs)(THIS_ UINT *pClusterIDs) PURE;
01367     
01368     <span class="comment">// copies NumExtract PCA projection coefficients starting at StartPCA</span>
01369     <span class="comment">// into pPCACoefficients - NumSamples*NumExtract floats copied</span>
01370     STDMETHOD(ExtractPCA)(THIS_ UINT StartPCA, UINT NumExtract, FLOAT *pPCACoefficients) PURE;
01371 
01372     <span class="comment">// copies NumPCA projection coefficients starting at StartPCA</span>
01373     <span class="comment">// into pTexture - should be able to cope with signed formats</span>
01374     STDMETHOD(ExtractTexture)(THIS_ UINT StartPCA, UINT NumpPCA, 
01375                               LPDIRECT3DTEXTURE9 pTexture) PURE;
01376                               
01377     <span class="comment">// copies NumPCA projection coefficients into mesh pScene</span>
01378     <span class="comment">// Usage is D3DDECLUSAGE where coefficients are to be stored</span>
01379     <span class="comment">// UsageIndexStart is starting index</span>
01380     STDMETHOD(ExtractToMesh)(THIS_ UINT NumPCA, D3DDECLUSAGE Usage, UINT UsageIndexStart,
01381                              LPD3DXMESH pScene) PURE;
01382 };
01383 
01384 
01385 <span class="preprocessor">#undef INTERFACE</span>
01386 <span class="preprocessor"></span><span class="preprocessor">#define INTERFACE ID3DXTextureGutterHelper</span>
01387 <span class="preprocessor"></span>
01388 <span class="comment">// ID3DXTextureGutterHelper will build and manage</span>
01389 <span class="comment">// "gutter" regions in a texture - this will allow for</span>
01390 <span class="comment">// bi-linear interpolation to not have artifacts when rendering</span>
01391 <span class="comment">// It generates a map (in texture space) where each texel</span>
01392 <span class="comment">// is in one of 3 states:</span>
01393 <span class="comment">//   0  Invalid - not used at all</span>
01394 <span class="comment">//   1  Inside triangle</span>
01395 <span class="comment">//   2  Gutter texel</span>
01396 <span class="comment">//   4  represents a gutter texel that will be computed during PRT</span>
01397 <span class="comment">// For each Inside/Gutter texel it stores the face it</span>
01398 <span class="comment">// belongs to and barycentric coordinates for the 1st two</span>
01399 <span class="comment">// vertices of that face.  Gutter vertices are assigned to</span>
01400 <span class="comment">// the closest edge in texture space.</span>
01401 <span class="comment">//</span>
01402 <span class="comment">// When used with PRT this requires a unique parameterization</span>
01403 <span class="comment">// of the model - every texel must correspond to a single point</span>
01404 <span class="comment">// on the surface of the model and vice versa</span>
01405 
01406 DECLARE_INTERFACE_(ID3DXTextureGutterHelper, IUnknown)
01407 {
01408     <span class="comment">// IUnknown</span>
01409     STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
01410     STDMETHOD_(ULONG, AddRef)(THIS) PURE;
01411     STDMETHOD_(ULONG, Release)(THIS) PURE;
01412 
01413     <span class="comment">// ID3DXTextureGutterHelper</span>
01414     
01415     <span class="comment">// dimensions of texture this is bound too</span>
01416     STDMETHOD_(UINT, GetWidth)(THIS) PURE;
01417     STDMETHOD_(UINT, GetHeight)(THIS) PURE;
01418 
01419 
01420     <span class="comment">// Applying gutters recomputes all of the gutter texels of class "2"</span>
01421     <span class="comment">// based on texels of class "1" or "4"</span>
01422     
01423     <span class="comment">// Applies gutters to a raw float buffer - each texel is NumCoeffs floats</span>
01424     <span class="comment">// Width and Height must match GutterHelper</span>
01425     STDMETHOD(ApplyGuttersFloat)(THIS_ FLOAT *pDataIn, UINT NumCoeffs, UINT Width, UINT Height);
01426     
01427     <span class="comment">// Applies gutters to pTexture</span>
01428     <span class="comment">// Dimensions must match GutterHelper</span>
01429     STDMETHOD(ApplyGuttersTex)(THIS_ LPDIRECT3DTEXTURE9 pTexture);
01430     
01431     <span class="comment">// Applies gutters to a D3DXPRTBuffer</span>
01432     <span class="comment">// Dimensions must match GutterHelper</span>
01433     STDMETHOD(ApplyGuttersPRT)(THIS_ LPD3DXPRTBUFFER pBuffer);
01434     
01435     <span class="comment">// the routines below provide access to the data structures</span>
01436     <span class="comment">// used by the Apply functions</span>
01437 
01438     <span class="comment">// face map is a UINT per texel that represents the</span>
01439     <span class="comment">// face of the mesh that texel belongs too - </span>
01440     <span class="comment">// only valid if same texel is valid in pGutterData</span>
01441     <span class="comment">// pFaceData must be allocated by the user</span>
01442     STDMETHOD(GetFaceMap)(THIS_ UINT *pFaceData) PURE;
01443     
01444     <span class="comment">// BaryMap is a D3DXVECTOR2 per texel</span>
01445     <span class="comment">// the 1st two barycentric coordinates for the corresponding</span>
01446     <span class="comment">// face (3rd weight is always 1-sum of first two)</span>
01447     <span class="comment">// only valid if same texel is valid in pGutterData</span>
01448     <span class="comment">// pBaryData must be allocated by the user</span>
01449     STDMETHOD(GetBaryMap)(THIS_ D3DXVECTOR2 *pBaryData) PURE;
01450     
01451     <span class="comment">// TexelMap is a D3DXVECTOR2 per texel that</span>
01452     <span class="comment">// stores the location in pixel coordinates where the</span>
01453     <span class="comment">// corresponding texel is mapped</span>
01454     <span class="comment">// pTexelData must be allocated by the user</span>
01455     STDMETHOD(GetTexelMap)(THIS_ D3DXVECTOR2 *pTexelData) PURE;
01456     
01457     <span class="comment">// GutterMap is a BYTE per texel</span>
01458     <span class="comment">// 0/1/2 for Invalid/Internal/Gutter texels</span>
01459     <span class="comment">// 4 represents a gutter texel that will be computed</span>
01460     <span class="comment">// during PRT</span>
01461     <span class="comment">// pGutterData must be allocated by the user</span>
01462     STDMETHOD(GetGutterMap)(THIS_ BYTE *pGutterData) PURE;
01463     
01464     <span class="comment">// face map is a UINT per texel that represents the</span>
01465     <span class="comment">// face of the mesh that texel belongs too - </span>
01466     <span class="comment">// only valid if same texel is valid in pGutterData</span>
01467     STDMETHOD(SetFaceMap)(THIS_ UINT *pFaceData) PURE;
01468     
01469     <span class="comment">// BaryMap is a D3DXVECTOR2 per texel</span>
01470     <span class="comment">// the 1st two barycentric coordinates for the corresponding</span>
01471     <span class="comment">// face (3rd weight is always 1-sum of first two)</span>
01472     <span class="comment">// only valid if same texel is valid in pGutterData</span>
01473     STDMETHOD(SetBaryMap)(THIS_ D3DXVECTOR2 *pBaryData) PURE;
01474     
01475     <span class="comment">// TexelMap is a D3DXVECTOR2 per texel that</span>
01476     <span class="comment">// stores the location in pixel coordinates where the</span>
01477     <span class="comment">// corresponding texel is mapped</span>
01478     STDMETHOD(SetTexelMap)(THIS_ D3DXVECTOR2 *pTexelData) PURE;
01479     
01480     <span class="comment">// GutterMap is a BYTE per texel</span>
01481     <span class="comment">// 0/1/2 for Invalid/Internal/Gutter texels</span>
01482     <span class="comment">// 4 represents a gutter texel that will be computed</span>
01483     <span class="comment">// during PRT</span>
01484     STDMETHOD(SetGutterMap)(THIS_ BYTE *pGutterData) PURE;    
01485 };
01486 
01487 
01488 <span class="keyword">typedef</span> interface ID3DXPRTEngine ID3DXPRTEngine;
01489 <span class="keyword">typedef</span> interface ID3DXPRTEngine *LPD3DXPRTENGINE;
01490 
01491 <span class="preprocessor">#undef INTERFACE</span>
01492 <span class="preprocessor"></span><span class="preprocessor">#define INTERFACE ID3DXPRTEngine</span>
01493 <span class="preprocessor"></span>
01494 <span class="comment">// ID3DXPRTEngine is used to compute a PRT simulation</span>
01495 <span class="comment">// Use the following steps to compute PRT for SH</span>
01496 <span class="comment">// (1) create an interface (which includes a scene)</span>
01497 <span class="comment">// (2) call SetSamplingInfo</span>
01498 <span class="comment">// (3) [optional] Set MeshMaterials/albedo's (required if doing bounces)</span>
01499 <span class="comment">// (4) call ComputeDirectLightingSH</span>
01500 <span class="comment">// (5) [optional] call ComputeBounce</span>
01501 <span class="comment">// repeat step 5 for as many bounces as wanted.</span>
01502 <span class="comment">// if you want to model subsurface scattering you</span>
01503 <span class="comment">// need to call ComputeSS after direct lighting and</span>
01504 <span class="comment">// each bounce.</span>
01505 <span class="comment">// If you want to bake the albedo into the PRT signal, you</span>
01506 <span class="comment">// must call MutliplyAlbedo, otherwise the user has to multiply</span>
01507 <span class="comment">// the albedo themselves.  Not multiplying the albedo allows you</span>
01508 <span class="comment">// to model albedo variation at a finer scale then illumination, and</span>
01509 <span class="comment">// can result in better compression results.</span>
01510 <span class="comment">// Luminance values are computed from RGB values using the following</span>
01511 <span class="comment">// formula:  R * 0.2125 + G * 0.7154 + B * 0.0721</span>
01512 
01513 DECLARE_INTERFACE_(ID3DXPRTEngine, IUnknown)
01514 {
01515     <span class="comment">// IUnknown</span>
01516     STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
01517     STDMETHOD_(ULONG, AddRef)(THIS) PURE;
01518     STDMETHOD_(ULONG, Release)(THIS) PURE;
01519 
01520     <span class="comment">// ID3DXPRTEngine</span>
01521     
01522     <span class="comment">// This sets a material per attribute in the scene mesh and it is</span>
01523     <span class="comment">// the only way to specify subsurface scattering parameters.  if</span>
01524     <span class="comment">// bSetAlbedo is FALSE, NumChannels must match the current</span>
01525     <span class="comment">// configuration of the PRTEngine.  If you intend to change</span>
01526     <span class="comment">// NumChannels (through some other SetAlbedo function) it must</span>
01527     <span class="comment">// happen before SetMeshMaterials is called.</span>
01528     <span class="comment">//</span>
01529     <span class="comment">// NumChannels 1 implies "grayscale" materials, set this to 3 to enable</span>
01530     <span class="comment">//  color bleeding effects</span>
01531     <span class="comment">// bSetAlbedo sets albedo from material if TRUE - which clobbers per texel/vertex</span>
01532     <span class="comment">//  albedo that might have been set before.  FALSE won't clobber.</span>
01533     <span class="comment">// fLengthScale is used for subsurface scattering - scene is mapped into a 1mm unit cube</span>
01534     <span class="comment">//  and scaled by this amount</span>
01535     STDMETHOD(SetMeshMaterials)(THIS_ CONST D3DXSHMATERIAL **ppMaterials, UINT NumMeshes, 
01536                                 UINT NumChannels, BOOL bSetAlbedo, FLOAT fLengthScale) PURE;
01537     
01538     <span class="comment">// setting albedo per-vertex or per-texel over rides the albedos stored per mesh</span>
01539     <span class="comment">// but it does not over ride any other settings</span>
01540     
01541     <span class="comment">// sets an albedo to be used per vertex - the albedo is represented as a float</span>
01542     <span class="comment">// pDataIn input pointer (pointint to albedo of 1st sample)</span>
01543     <span class="comment">// NumChannels 1 implies "grayscale" materials, set this to 3 to enable</span>
01544     <span class="comment">//  color bleeding effects</span>
01545     <span class="comment">// Stride - stride in bytes to get to next samples albedo</span>
01546     STDMETHOD(SetPerVertexAlbedo)(THIS_ CONST VOID *pDataIn, UINT NumChannels, UINT Stride) PURE;
01547     
01548     <span class="comment">// represents the albedo per-texel instead of per-vertex (even if per-vertex PRT is used)</span>
01549     <span class="comment">// pAlbedoTexture - texture that stores the albedo (dimension arbitrary)</span>
01550     <span class="comment">// NumChannels 1 implies "grayscale" materials, set this to 3 to enable</span>
01551     <span class="comment">//  color bleeding effects</span>
01552     <span class="comment">// pGH - optional gutter helper, otherwise one is constructed in computation routines and</span>
01553     <span class="comment">//  destroyed (if not attached to buffers)</span>
01554     STDMETHOD(SetPerTexelAlbedo)(THIS_ LPDIRECT3DTEXTURE9 pAlbedoTexture, 
01555                                  UINT NumChannels, 
01556                                  LPD3DXTEXTUREGUTTERHELPER pGH) PURE;
01557                                  
01558     <span class="comment">// gets the per-vertex albedo</span>
01559     STDMETHOD(GetVertexAlbedo)(THIS_ D3DXCOLOR *pVertColors, UINT NumVerts) PURE;                                 
01560                                  
01561     <span class="comment">// If pixel PRT is being computed normals default to ones that are interpolated</span>
01562     <span class="comment">// from the vertex normals.  This specifies a texture that stores an object</span>
01563     <span class="comment">// space normal map instead (must use a texture format that can represent signed values)</span>
01564     <span class="comment">// pNormalTexture - normal map, must be same dimensions as PRTBuffers, signed                                </span>
01565     STDMETHOD(SetPerTexelNormal)(THIS_ LPDIRECT3DTEXTURE9 pNormalTexture) PURE;
01566                                  
01567     <span class="comment">// Copies per-vertex albedo from mesh</span>
01568     <span class="comment">// pMesh - mesh that represents the scene.  It must have the same</span>
01569     <span class="comment">//  properties as the mesh used to create the PRTEngine</span>
01570     <span class="comment">// Usage - D3DDECLUSAGE to extract albedos from</span>
01571     <span class="comment">// NumChannels 1 implies "grayscale" materials, set this to 3 to enable</span>
01572     <span class="comment">//  color bleeding effects</span>
01573     STDMETHOD(ExtractPerVertexAlbedo)(THIS_ LPD3DXMESH pMesh, 
01574                                       D3DDECLUSAGE Usage, 
01575                                       UINT NumChannels) PURE;
01576 
01577     <span class="comment">// Resamples the input buffer into the output buffer</span>
01578     <span class="comment">// can be used to move between per-vertex and per-texel buffers.  This can also be used</span>
01579     <span class="comment">// to convert single channel buffers to 3-channel buffers and vice-versa.</span>
01580     STDMETHOD(ResampleBuffer)(THIS_ LPD3DXPRTBUFFER pBufferIn, LPD3DXPRTBUFFER pBufferOut) PURE;
01581     
01582     <span class="comment">// Returns the scene mesh - including modifications from adaptive spatial sampling</span>
01583     <span class="comment">// The returned mesh only has positions, normals and texture coordinates (if defined)</span>
01584     <span class="comment">// pD3DDevice - d3d device that will be used to allocate the mesh</span>
01585     <span class="comment">// pFaceRemap - each face has a pointer back to the face on the original mesh that it comes from</span>
01586     <span class="comment">//  if the face hasn't been subdivided this will be an identity mapping</span>
01587     <span class="comment">// pVertRemap - each vertex contains 3 vertices that this is a linear combination of</span>
01588     <span class="comment">// pVertWeights - weights for each of above indices (sum to 1.0f)</span>
01589     <span class="comment">// ppMesh - mesh that will be allocated and filled</span>
01590     STDMETHOD(GetAdaptedMesh)(THIS_ LPDIRECT3DDEVICE9 pD3DDevice,UINT *pFaceRemap, UINT *pVertRemap, FLOAT *pfVertWeights, LPD3DXMESH *ppMesh) PURE;
01591 
01592     <span class="comment">// Number of vertices currently allocated (includes new vertices from adaptive sampling)</span>
01593     STDMETHOD_(UINT, GetNumVerts)(THIS) PURE;
01594     <span class="comment">// Number of faces currently allocated (includes new faces)</span>
01595     STDMETHOD_(UINT, GetNumFaces)(THIS) PURE;
01596 
01597     <span class="comment">// This will subdivide faces on a mesh so that adaptively simulations can</span>
01598     <span class="comment">// use a more conservative threshold (it won't miss features.)</span>
01599     <span class="comment">// MinEdgeLength - minimum edge length that will be generated, if 0.0f a</span>
01600     <span class="comment">//  reasonable default will be used</span>
01601     <span class="comment">// MaxSubdiv - maximum level of subdivision, if 0 is specified a default</span>
01602     <span class="comment">//  value will be used (5)</span>
01603     STDMETHOD(RobustMeshRefine)(THIS_ FLOAT MinEdgeLength, UINT MaxSubdiv) PURE;
01604 
01605     <span class="comment">// This sets to sampling information used by the simulator.  Adaptive sampling</span>
01606     <span class="comment">// parameters are currently ignored.</span>
01607     <span class="comment">// NumRays - number of rays to shoot per sample</span>
01608     <span class="comment">// UseSphere - if TRUE uses spherical samples, otherwise samples over</span>
01609     <span class="comment">//  the hemisphere.  Should only be used with GPU and Vol computations</span>
01610     <span class="comment">// UseCosine - if TRUE uses a cosine weighting - not used for Vol computations</span>
01611     <span class="comment">//  or if only the visiblity function is desired</span>
01612     <span class="comment">// Adaptive - if TRUE adaptive sampling (angular) is used</span>
01613     <span class="comment">// AdaptiveThresh - threshold used to terminate adaptive angular sampling</span>
01614     <span class="comment">//  ignored if adaptive sampling is not set</span>
01615     STDMETHOD(SetSamplingInfo)(THIS_ UINT NumRays, 
01616                                BOOL UseSphere, 
01617                                BOOL UseCosine, 
01618                                BOOL Adaptive, 
01619                                FLOAT AdaptiveThresh) PURE;
01620 
01621     <span class="comment">// Methods that compute the direct lighting contribution for objects</span>
01622     <span class="comment">// always represente light using spherical harmonics (SH)</span>
01623     <span class="comment">// the albedo is not multiplied by the signal - it just integrates</span>
01624     <span class="comment">// incoming light.  If NumChannels is not 1 the vector is replicated</span>
01625     <span class="comment">//</span>
01626     <span class="comment">// SHOrder - order of SH to use</span>
01627     <span class="comment">// pDataOut - PRT buffer that is generated.  Can be single channel</span>
01628     STDMETHOD(ComputeDirectLightingSH)(THIS_ UINT SHOrder, 
01629                                        LPD3DXPRTBUFFER pDataOut) PURE;
01630                                        
01631     <span class="comment">// Adaptive variant of above function.  This will refine the mesh</span>
01632     <span class="comment">// generating new vertices/faces to approximate the PRT signal</span>
01633     <span class="comment">// more faithfully.</span>
01634     <span class="comment">// SHOrder - order of SH to use</span>
01635     <span class="comment">// AdaptiveThresh - threshold for adaptive subdivision (in PRT vector error)</span>
01636     <span class="comment">//  if value is less then 1e-6f, 1e-6f is specified</span>
01637     <span class="comment">// MinEdgeLength - minimum edge length that will be generated</span>
01638     <span class="comment">//  if value is too small a fairly conservative model dependent value</span>
01639     <span class="comment">//  is used</span>
01640     <span class="comment">// MaxSubdiv - maximum subdivision level, if 0 is specified it </span>
01641     <span class="comment">//  will default to 4</span>
01642     <span class="comment">// pDataOut - PRT buffer that is generated.  Can be single channel.</span>
01643     STDMETHOD(ComputeDirectLightingSHAdaptive)(THIS_ UINT SHOrder, 
01644                                                FLOAT AdaptiveThresh,
01645                                                FLOAT MinEdgeLength,
01646                                                UINT MaxSubdiv,
01647                                                LPD3DXPRTBUFFER pDataOut) PURE;
01648                                        
01649     <span class="comment">// Function that computes the direct lighting contribution for objects</span>
01650     <span class="comment">// light is always represented using spherical harmonics (SH)</span>
01651     <span class="comment">// This is done on the GPU and is much faster then using the CPU.</span>
01652     <span class="comment">// The albedo is not multiplied by the signal - it just integrates</span>
01653     <span class="comment">// incoming light.  If NumChannels is not 1 the vector is replicated.</span>
01654     <span class="comment">// ZBias/ZAngleBias are akin to parameters used with shadow zbuffers.</span>
01655     <span class="comment">// A reasonable default for both values is 0.005, but the user should</span>
01656     <span class="comment">// experiment (ZAngleBias can be zero, ZBias should not be.)</span>
01657     <span class="comment">// Callbacks should not use the Direct3D9Device the simulator is using.</span>
01658     <span class="comment">// SetSamplingInfo must be called with TRUE for UseSphere and</span>
01659     <span class="comment">// FALSE for UseCosine before this method is called.</span>
01660     <span class="comment">//</span>
01661     <span class="comment">// pD3DDevice - device used to run GPU simulator - must support PS2.0</span>
01662     <span class="comment">//  and FP render targets</span>
01663     <span class="comment">// Flags - parameters for the GPU simulator, combination of one or more</span>
01664     <span class="comment">//  D3DXSHGPUSIMOPT flags.  Only one SHADOWRES setting should be set and</span>
01665     <span class="comment">//  the defaults is 512</span>
01666     <span class="comment">// SHOrder - order of SH to use</span>
01667     <span class="comment">// ZBias - bias in normal direction (for depth test)</span>
01668     <span class="comment">// ZAngleBias - scaled by one minus cosine of angle with light (offset in depth)</span>
01669     <span class="comment">// pDataOut - PRT buffer that is filled in.  Can be single channel</span>
01670     STDMETHOD(ComputeDirectLightingSHGPU)(THIS_ LPDIRECT3DDEVICE9 pD3DDevice,
01671                                           UINT Flags,
01672                                           UINT SHOrder,
01673                                           FLOAT ZBias,
01674                                           FLOAT ZAngleBias,
01675                                           LPD3DXPRTBUFFER pDataOut) PURE;
01676 
01677 
01678     <span class="comment">// Functions that computes subsurface scattering (using material properties)</span>
01679     <span class="comment">// Albedo is not multiplied by result.  This only works for per-vertex data</span>
01680     <span class="comment">// use ResampleBuffer to move per-vertex data into a texture and back.</span>
01681     <span class="comment">//</span>
01682     <span class="comment">// pDataIn - input data (previous bounce)</span>
01683     <span class="comment">// pDataOut - result of subsurface scattering simulation</span>
01684     <span class="comment">// pDataTotal - [optional] results can be summed into this buffer</span>
01685     STDMETHOD(ComputeSS)(THIS_ LPD3DXPRTBUFFER pDataIn, 
01686                          LPD3DXPRTBUFFER pDataOut, LPD3DXPRTBUFFER pDataTotal) PURE;
01687 
01688     <span class="comment">// computes a single bounce of inter-reflected light</span>
01689     <span class="comment">// works for SH based PRT or generic lighting</span>
01690     <span class="comment">// Albedo is not multiplied by result</span>
01691     <span class="comment">//</span>
01692     <span class="comment">// pDataIn - previous bounces data </span>
01693     <span class="comment">// pDataOut - PRT buffer that is generated</span>
01694     <span class="comment">// pDataTotal - [optional] can be used to keep a running sum</span>
01695     STDMETHOD(ComputeBounce)(THIS_ LPD3DXPRTBUFFER pDataIn,
01696                              LPD3DXPRTBUFFER pDataOut,
01697                              LPD3DXPRTBUFFER pDataTotal) PURE;
01698 
01699     <span class="comment">// Adaptive version of above function.</span>
01700     <span class="comment">//</span>
01701     <span class="comment">// pDataIn - previous bounces data, can be single channel </span>
01702     <span class="comment">// AdaptiveThresh - threshold for adaptive subdivision (in PRT vector error)</span>
01703     <span class="comment">//  if value is less then 1e-6f, 1e-6f is specified</span>
01704     <span class="comment">// MinEdgeLength - minimum edge length that will be generated</span>
01705     <span class="comment">//  if value is too small a fairly conservative model dependent value</span>
01706     <span class="comment">//  is used</span>
01707     <span class="comment">// MaxSubdiv - maximum subdivision level, if 0 is specified it </span>
01708     <span class="comment">//  will default to 4</span>
01709     <span class="comment">// pDataOut - PRT buffer that is generated</span>
01710     <span class="comment">// pDataTotal - [optional] can be used to keep a running sum    </span>
01711     STDMETHOD(ComputeBounceAdaptive)(THIS_ LPD3DXPRTBUFFER pDataIn,
01712                                      FLOAT AdaptiveThresh,
01713                                      FLOAT MinEdgeLength,
01714                                      UINT MaxSubdiv,
01715                                      LPD3DXPRTBUFFER pDataOut,
01716                                      LPD3DXPRTBUFFER pDataTotal) PURE;
01717 
01718     <span class="comment">// Computes projection of distant SH radiance into a local SH radiance</span>
01719     <span class="comment">// function.  This models how direct lighting is attenuated by the </span>
01720     <span class="comment">// scene and is a form of "neighborhood transfer."  The result is</span>
01721     <span class="comment">// a linear operator (matrix) at every sample point, if you multiply</span>
01722     <span class="comment">// this matrix by the distant SH lighting coefficients you get an</span>
01723     <span class="comment">// approximation of the local incident radiance function from</span>
01724     <span class="comment">// direct lighting.  These resulting lighting coefficients can</span>
01725     <span class="comment">// than be projected into another basis or used with any rendering</span>
01726     <span class="comment">// technique that uses spherical harmonics as input.</span>
01727     <span class="comment">// SetSamplingInfo must be called with TRUE for UseSphere and</span>
01728     <span class="comment">// FALSE for UseCosine before this method is called.  </span>
01729     <span class="comment">// Generates SHOrderIn*SHOrderIn*SHOrderOut*SHOrderOut scalars </span>
01730     <span class="comment">// per channel at each sample location.</span>
01731     <span class="comment">//</span>
01732     <span class="comment">// SHOrderIn  - Order of the SH representation of distant lighting</span>
01733     <span class="comment">// SHOrderOut - Order of the SH representation of local lighting</span>
01734     <span class="comment">// NumVolSamples  - Number of sample locations</span>
01735     <span class="comment">// pSampleLocs    - position of sample locations</span>
01736     <span class="comment">// pDataOut       - PRT Buffer that will store output results    </span>
01737     STDMETHOD(ComputeVolumeSamplesDirectSH)(THIS_ UINT SHOrderIn, 
01738                                             UINT SHOrderOut, 
01739                                             UINT NumVolSamples,
01740                                             CONST D3DXVECTOR3 *pSampleLocs,
01741                                             LPD3DXPRTBUFFER pDataOut) PURE;
01742                                     
01743     <span class="comment">// At each sample location computes a linear operator (matrix) that maps</span>
01744     <span class="comment">// the representation of source radiance (NumCoeffs in pSurfDataIn)</span>
01745     <span class="comment">// into a local incident radiance function approximated with spherical </span>
01746     <span class="comment">// harmonics.  For example if a light map data is specified in pSurfDataIn</span>
01747     <span class="comment">// the result is an SH representation of the flow of light at each sample</span>
01748     <span class="comment">// point.  If PRT data for an outdoor scene is used, each sample point</span>
01749     <span class="comment">// contains a matrix that models how distant lighting bounces of the objects</span>
01750     <span class="comment">// in the scene and arrives at the given sample point.  Combined with</span>
01751     <span class="comment">// ComputeVolumeSamplesDirectSH this gives the complete representation for</span>
01752     <span class="comment">// how light arrives at each sample point parameterized by distant lighting.</span>
01753     <span class="comment">// SetSamplingInfo must be called with TRUE for UseSphere and</span>
01754     <span class="comment">// FALSE for UseCosine before this method is called.    </span>
01755     <span class="comment">// Generates pSurfDataIn-&gt;NumCoeffs()*SHOrder*SHOrder scalars</span>
01756     <span class="comment">// per channel at each sample location.</span>
01757     <span class="comment">//</span>
01758     <span class="comment">// pSurfDataIn    - previous bounce data</span>
01759     <span class="comment">// SHOrder        - order of SH to generate projection with</span>
01760     <span class="comment">// NumVolSamples  - Number of sample locations</span>
01761     <span class="comment">// pSampleLocs    - position of sample locations</span>
01762     <span class="comment">// pDataOut       - PRT Buffer that will store output results</span>
01763     STDMETHOD(ComputeVolumeSamples)(THIS_ LPD3DXPRTBUFFER pSurfDataIn, 
01764                                     UINT SHOrder, 
01765                                     UINT NumVolSamples,
01766                                     CONST D3DXVECTOR3 *pSampleLocs,
01767                                     LPD3DXPRTBUFFER pDataOut) PURE;
01768     <span class="comment">// Frees temporary data structures that can be created for subsurface scattering</span>
01769     <span class="comment">// this data is freed when the PRTComputeEngine is freed and is lazily created</span>
01770     STDMETHOD(FreeSSData)(THIS) PURE;
01771     
01772     <span class="comment">// Frees temporary data structures that can be created for bounce simulations</span>
01773     <span class="comment">// this data is freed when the PRTComputeEngine is freed and is lazily created</span>
01774     STDMETHOD(FreeBounceData)(THIS) PURE;
01775 
01776     <span class="comment">// This computes the convolution coefficients relative to the per sample normals</span>
01777     <span class="comment">// that minimize error in a least squares sense with respect to the input PRT</span>
01778     <span class="comment">// data set.  These coefficients can be used with skinned/transformed normals to</span>
01779     <span class="comment">// model global effects with dynamic objects.  Shading normals can optionaly be</span>
01780     <span class="comment">// solved for - these normals (along with the convolution coefficients) can more</span>
01781     <span class="comment">// accurately represent the PRT signal.</span>
01782     <span class="comment">//</span>
01783     <span class="comment">// pDataIn  - SH PRT dataset that is input</span>
01784     <span class="comment">// SHOrder  - Order of SH to compute conv coefficients for </span>
01785     <span class="comment">// pNormOut - Optional array of vectors (passed in) that will be filled with</span>
01786     <span class="comment">//             "shading normals", convolution coefficients are optimized for</span>
01787     <span class="comment">//             these normals.  This array must be the same size as the number of</span>
01788     <span class="comment">//             samples in pDataIn</span>
01789     <span class="comment">// pDataOut - Output buffer (SHOrder convolution coefficients per channel per sample)</span>
01790     STDMETHOD(ComputeConvCoeffs)(THIS_ LPD3DXPRTBUFFER pDataIn,
01791                                  UINT SHOrder,
01792                                  D3DXVECTOR3 *pNormOut,
01793                                  LPD3DXPRTBUFFER pDataOut) PURE;
01794 
01795     <span class="comment">// scales all the samples associated with a given sub mesh</span>
01796     <span class="comment">// can be useful when using subsurface scattering</span>
01797     <span class="comment">// fScale - value to scale each vector in submesh by</span>
01798     STDMETHOD(ScaleMeshChunk)(THIS_ UINT uMeshChunk, FLOAT fScale, LPD3DXPRTBUFFER pDataOut) PURE;
01799     
01800     <span class="comment">// mutliplies each PRT vector by the albedo - can be used if you want to have the albedo</span>
01801     <span class="comment">// burned into the dataset, often better not to do this.  If this is not done the user</span>
01802     <span class="comment">// must mutliply the albedo themselves when rendering - just multiply the albedo times</span>
01803     <span class="comment">// the result of the PRT dot product.</span>
01804     <span class="comment">// If pDataOut is a texture simulation result and there is an albedo texture it</span>
01805     <span class="comment">// must be represented at the same resolution as the simulation buffer.  You can use</span>
01806     <span class="comment">// LoadSurfaceFromSurface and set a new albedo texture if this is an issue - but must</span>
01807     <span class="comment">// be careful about how the gutters are handled.</span>
01808     <span class="comment">//</span>
01809     <span class="comment">// pDataOut - dataset that will get albedo pushed into it</span>
01810     STDMETHOD(MultiplyAlbedo)(THIS_ LPD3DXPRTBUFFER pDataOut) PURE;
01811     
01812     <span class="comment">// Sets a pointer to an optional call back function that reports back to the</span>
01813     <span class="comment">// user percentage done and gives them the option of quitting</span>
01814     <span class="comment">// pCB - pointer to call back function, return S_OK for the simulation</span>
01815     <span class="comment">//  to continue</span>
01816     <span class="comment">// Frequency - 1/Frequency is roughly the number of times the call back</span>
01817     <span class="comment">//  will be invoked</span>
01818     <span class="comment">// lpUserContext - will be passed back to the users call back</span>
01819     STDMETHOD(SetCallBack)(THIS_ LPD3DXSHPRTSIMCB pCB, FLOAT Frequency,  LPVOID lpUserContext) PURE;
01820 };
01821 
01822 
01823 <span class="comment">// API functions for creating interfaces</span>
01824 
01825 <span class="preprocessor">#ifdef __cplusplus</span>
01826 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
01827 <span class="preprocessor">#endif //__cplusplus</span>
01828 <span class="preprocessor"></span>
01829 <span class="comment">//============================================================================</span>
01830 <span class="comment">//</span>
01831 <span class="comment">//  D3DXCreatePRTBuffer:</span>
01832 <span class="comment">//  --------------------</span>
01833 <span class="comment">//  Generates a PRT Buffer that can be compressed or filled by a simulator</span>
01834 <span class="comment">//  This function should be used to create per-vertex or volume buffers.</span>
01835 <span class="comment">//  When buffers are created all values are initialized to zero.</span>
01836 <span class="comment">//</span>
01837 <span class="comment">//  Parameters:</span>
01838 <span class="comment">//    NumSamples</span>
01839 <span class="comment">//      Number of sample locations represented</span>
01840 <span class="comment">//    NumCoeffs</span>
01841 <span class="comment">//      Number of coefficients per sample location (order^2 for SH)</span>
01842 <span class="comment">//    NumChannels</span>
01843 <span class="comment">//      Number of color channels to represent (1 or 3)</span>
01844 <span class="comment">//    ppBuffer</span>
01845 <span class="comment">//      Buffer that will be allocated</span>
01846 <span class="comment">//</span>
01847 <span class="comment">//============================================================================</span>
01848 
01849 HRESULT WINAPI 
01850     D3DXCreatePRTBuffer( 
01851         UINT NumSamples,
01852         UINT NumCoeffs,
01853         UINT NumChannels,
01854         LPD3DXPRTBUFFER* ppBuffer);
01855 
01856 <span class="comment">//============================================================================</span>
01857 <span class="comment">//</span>
01858 <span class="comment">//  D3DXCreatePRTBufferTex:</span>
01859 <span class="comment">//  --------------------</span>
01860 <span class="comment">//  Generates a PRT Buffer that can be compressed or filled by a simulator</span>
01861 <span class="comment">//  This function should be used to create per-pixel buffers.</span>
01862 <span class="comment">//  When buffers are created all values are initialized to zero.</span>
01863 <span class="comment">//</span>
01864 <span class="comment">//  Parameters:</span>
01865 <span class="comment">//    Width</span>
01866 <span class="comment">//      Width of texture</span>
01867 <span class="comment">//    Height</span>
01868 <span class="comment">//      Height of texture</span>
01869 <span class="comment">//    NumCoeffs</span>
01870 <span class="comment">//      Number of coefficients per sample location (order^2 for SH)</span>
01871 <span class="comment">//    NumChannels</span>
01872 <span class="comment">//      Number of color channels to represent (1 or 3)</span>
01873 <span class="comment">//    ppBuffer</span>
01874 <span class="comment">//      Buffer that will be allocated</span>
01875 <span class="comment">//</span>
01876 <span class="comment">//============================================================================</span>
01877 
01878 HRESULT WINAPI
01879     D3DXCreatePRTBufferTex( 
01880         UINT Width,
01881         UINT Height,
01882         UINT NumCoeffs,
01883         UINT NumChannels,
01884         LPD3DXPRTBUFFER* ppBuffer);
01885 
01886 <span class="comment">//============================================================================</span>
01887 <span class="comment">//</span>
01888 <span class="comment">//  D3DXLoadPRTBufferFromFile:</span>
01889 <span class="comment">//  --------------------</span>
01890 <span class="comment">//  Loads a PRT buffer that has been saved to disk.</span>
01891 <span class="comment">//</span>
01892 <span class="comment">//  Parameters:</span>
01893 <span class="comment">//    pFilename</span>
01894 <span class="comment">//      Name of the file to load</span>
01895 <span class="comment">//    ppBuffer</span>
01896 <span class="comment">//      Buffer that will be allocated</span>
01897 <span class="comment">//</span>
01898 <span class="comment">//============================================================================</span>
01899 
01900 HRESULT WINAPI
01901     D3DXLoadPRTBufferFromFileA(
01902         LPCSTR pFilename, 
01903         LPD3DXPRTBUFFER*       ppBuffer);
01904         
01905 HRESULT WINAPI
01906     D3DXLoadPRTBufferFromFileW(
01907         LPCWSTR pFilename, 
01908         LPD3DXPRTBUFFER*       ppBuffer);
01909 
01910 <span class="preprocessor">#ifdef UNICODE</span>
01911 <span class="preprocessor"></span><span class="preprocessor">#define D3DXLoadPRTBufferFromFile D3DXLoadPRTBufferFromFileW</span>
01912 <span class="preprocessor"></span><span class="preprocessor">#else</span>
01913 <span class="preprocessor"></span><span class="preprocessor">#define D3DXLoadPRTBufferFromFile D3DXLoadPRTBufferFromFileA</span>
01914 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01915 <span class="preprocessor"></span>
01916 
01917 <span class="comment">//============================================================================</span>
01918 <span class="comment">//</span>
01919 <span class="comment">//  D3DXSavePRTBufferToFile:</span>
01920 <span class="comment">//  --------------------</span>
01921 <span class="comment">//  Saves a PRTBuffer to disk.</span>
01922 <span class="comment">//</span>
01923 <span class="comment">//  Parameters:</span>
01924 <span class="comment">//    pFilename</span>
01925 <span class="comment">//      Name of the file to save</span>
01926 <span class="comment">//    pBuffer</span>
01927 <span class="comment">//      Buffer that will be saved</span>
01928 <span class="comment">//</span>
01929 <span class="comment">//============================================================================</span>
01930 
01931 HRESULT WINAPI
01932     D3DXSavePRTBufferToFileA(
01933         LPCSTR pFileName,
01934         LPD3DXPRTBUFFER pBuffer);
01935         
01936 HRESULT WINAPI
01937     D3DXSavePRTBufferToFileW(
01938         LPCWSTR pFileName,
01939         LPD3DXPRTBUFFER pBuffer);
01940 
01941 <span class="preprocessor">#ifdef UNICODE</span>
01942 <span class="preprocessor"></span><span class="preprocessor">#define D3DXSavePRTBufferToFile D3DXSavePRTBufferToFileW</span>
01943 <span class="preprocessor"></span><span class="preprocessor">#else</span>
01944 <span class="preprocessor"></span><span class="preprocessor">#define D3DXSavePRTBufferToFile D3DXSavePRTBufferToFileA</span>
01945 <span class="preprocessor"></span><span class="preprocessor">#endif                </span>
01946 <span class="preprocessor"></span>
01947 
01948 <span class="comment">//============================================================================</span>
01949 <span class="comment">//</span>
01950 <span class="comment">//  D3DXLoadPRTCompBufferFromFile:</span>
01951 <span class="comment">//  --------------------</span>
01952 <span class="comment">//  Loads a PRTComp buffer that has been saved to disk.</span>
01953 <span class="comment">//</span>
01954 <span class="comment">//  Parameters:</span>
01955 <span class="comment">//    pFilename</span>
01956 <span class="comment">//      Name of the file to load</span>
01957 <span class="comment">//    ppBuffer</span>
01958 <span class="comment">//      Buffer that will be allocated</span>
01959 <span class="comment">//</span>
01960 <span class="comment">//============================================================================</span>
01961 
01962 HRESULT WINAPI
01963     D3DXLoadPRTCompBufferFromFileA(
01964         LPCSTR pFilename, 
01965         LPD3DXPRTCOMPBUFFER*       ppBuffer);
01966         
01967 HRESULT WINAPI
01968     D3DXLoadPRTCompBufferFromFileW(
01969         LPCWSTR pFilename, 
01970         LPD3DXPRTCOMPBUFFER*       ppBuffer);
01971 
01972 <span class="preprocessor">#ifdef UNICODE</span>
01973 <span class="preprocessor"></span><span class="preprocessor">#define D3DXLoadPRTCompBufferFromFile D3DXLoadPRTCompBufferFromFileW</span>
01974 <span class="preprocessor"></span><span class="preprocessor">#else</span>
01975 <span class="preprocessor"></span><span class="preprocessor">#define D3DXLoadPRTCompBufferFromFile D3DXLoadPRTCompBufferFromFileA</span>
01976 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01977 <span class="preprocessor"></span>
01978 <span class="comment">//============================================================================</span>
01979 <span class="comment">//</span>
01980 <span class="comment">//  D3DXSavePRTCompBufferToFile:</span>
01981 <span class="comment">//  --------------------</span>
01982 <span class="comment">//  Saves a PRTCompBuffer to disk.</span>
01983 <span class="comment">//</span>
01984 <span class="comment">//  Parameters:</span>
01985 <span class="comment">//    pFilename</span>
01986 <span class="comment">//      Name of the file to save</span>
01987 <span class="comment">//    pBuffer</span>
01988 <span class="comment">//      Buffer that will be saved</span>
01989 <span class="comment">//</span>
01990 <span class="comment">//============================================================================</span>
01991 
01992 HRESULT WINAPI
01993     D3DXSavePRTCompBufferToFileA(
01994         LPCSTR pFileName,
01995         LPD3DXPRTCOMPBUFFER pBuffer);
01996         
01997 HRESULT WINAPI
01998     D3DXSavePRTCompBufferToFileW(
01999         LPCWSTR pFileName,
02000         LPD3DXPRTCOMPBUFFER pBuffer);
02001 
02002 <span class="preprocessor">#ifdef UNICODE</span>
02003 <span class="preprocessor"></span><span class="preprocessor">#define D3DXSavePRTCompBufferToFile D3DXSavePRTCompBufferToFileW</span>
02004 <span class="preprocessor"></span><span class="preprocessor">#else</span>
02005 <span class="preprocessor"></span><span class="preprocessor">#define D3DXSavePRTCompBufferToFile D3DXSavePRTCompBufferToFileA</span>
02006 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
02007 <span class="preprocessor"></span>
02008 <span class="comment">//============================================================================</span>
02009 <span class="comment">//</span>
02010 <span class="comment">//  D3DXCreatePRTCompBuffer:</span>
02011 <span class="comment">//  --------------------</span>
02012 <span class="comment">//  Compresses a PRT buffer (vertex or texel)</span>
02013 <span class="comment">//</span>
02014 <span class="comment">//  Parameters:</span>
02015 <span class="comment">//    D3DXSHCOMPRESSQUALITYTYPE</span>
02016 <span class="comment">//      Quality of compression - low is faster (computes PCA per voronoi cluster)</span>
02017 <span class="comment">//      high is slower but better quality (clusters based on distance to affine subspace)</span>
02018 <span class="comment">//    NumClusters</span>
02019 <span class="comment">//      Number of clusters to compute</span>
02020 <span class="comment">//    NumPCA</span>
02021 <span class="comment">//      Number of basis vectors to compute</span>
02022 <span class="comment">//    ppBufferIn</span>
02023 <span class="comment">//      Buffer that will be compressed</span>
02024 <span class="comment">//    ppBufferOut</span>
02025 <span class="comment">//      Compressed buffer that will be created</span>
02026 <span class="comment">//</span>
02027 <span class="comment">//============================================================================</span>
02028 
02029 
02030 HRESULT WINAPI
02031     D3DXCreatePRTCompBuffer(
02032         D3DXSHCOMPRESSQUALITYTYPE Quality,
02033         UINT NumClusters, 
02034         UINT NumPCA,
02035         LPD3DXPRTBUFFER  pBufferIn,
02036         LPD3DXPRTCOMPBUFFER *ppBufferOut
02037     );
02038 
02039 <span class="comment">//============================================================================</span>
02040 <span class="comment">//</span>
02041 <span class="comment">//  D3DXCreateTextureGutterHelper:</span>
02042 <span class="comment">//  --------------------</span>
02043 <span class="comment">//  Generates a "GutterHelper" for a given set of meshes and texture</span>
02044 <span class="comment">//  resolution</span>
02045 <span class="comment">//</span>
02046 <span class="comment">//  Parameters:</span>
02047 <span class="comment">//    Width</span>
02048 <span class="comment">//      Width of texture</span>
02049 <span class="comment">//    Height</span>
02050 <span class="comment">//      Height of texture</span>
02051 <span class="comment">//    pMesh</span>
02052 <span class="comment">//      Mesh that represents the scene</span>
02053 <span class="comment">//    GutterSize</span>
02054 <span class="comment">//      Number of texels to over rasterize in texture space</span>
02055 <span class="comment">//      this should be at least 1.0</span>
02056 <span class="comment">//    ppBuffer</span>
02057 <span class="comment">//      GutterHelper that will be created</span>
02058 <span class="comment">//</span>
02059 <span class="comment">//============================================================================</span>
02060 
02061 
02062 HRESULT WINAPI 
02063     D3DXCreateTextureGutterHelper( 
02064         UINT Width,
02065         UINT Height,
02066         LPD3DXMESH pMesh, 
02067         FLOAT GutterSize,
02068         LPD3DXTEXTUREGUTTERHELPER* ppBuffer);
02069 
02070 
02071 <span class="comment">//============================================================================</span>
02072 <span class="comment">//</span>
02073 <span class="comment">//  D3DXCreatePRTEngine:</span>
02074 <span class="comment">//  --------------------</span>
02075 <span class="comment">//  Computes a PRTEngine which can efficiently generate PRT simulations</span>
02076 <span class="comment">//  of a scene</span>
02077 <span class="comment">//</span>
02078 <span class="comment">//  Parameters:</span>
02079 <span class="comment">//    pMesh</span>
02080 <span class="comment">//      Mesh that represents the scene - must have an AttributeTable</span>
02081 <span class="comment">//      where vertices are in a unique attribute.</span>
02082 <span class="comment">//    ExtractUVs</span>
02083 <span class="comment">//      Set this to true if textures are going to be used for albedos</span>
02084 <span class="comment">//      or to store PRT vectors</span>
02085 <span class="comment">//    pBlockerMesh</span>
02086 <span class="comment">//      Optional mesh that just blocks the scene</span>
02087 <span class="comment">//    ppEngine</span>
02088 <span class="comment">//      PRTEngine that will be created</span>
02089 <span class="comment">//</span>
02090 <span class="comment">//============================================================================</span>
02091 
02092 
02093 HRESULT WINAPI 
02094     D3DXCreatePRTEngine( 
02095         LPD3DXMESH pMesh, 
02096         BOOL ExtractUVs,
02097         LPD3DXMESH pBlockerMesh, 
02098         LPD3DXPRTENGINE* ppEngine);
02099 
02100 <span class="comment">//============================================================================</span>
02101 <span class="comment">//</span>
02102 <span class="comment">//  D3DXConcatenateMeshes:</span>
02103 <span class="comment">//  --------------------</span>
02104 <span class="comment">//  Concatenates a group of meshes into one common mesh.  This can optionaly transform</span>
02105 <span class="comment">//  each sub mesh or its texture coordinates.  If no DECL is given it will</span>
02106 <span class="comment">//  generate a union of all of the DECL's of the sub meshes, promoting channels</span>
02107 <span class="comment">//  and types if neccesary.  It will create an AttributeTable if possible, one can</span>
02108 <span class="comment">//  call OptimizeMesh with attribute sort and compacting enabled to ensure this.</span>
02109 <span class="comment">//</span>
02110 <span class="comment">//  Parameters:</span>
02111 <span class="comment">//    ppMeshes</span>
02112 <span class="comment">//      Array of pointers to meshes that can store PRT vectors</span>
02113 <span class="comment">//    NumMeshes</span>
02114 <span class="comment">//      Number of meshes</span>
02115 <span class="comment">//    Options</span>
02116 <span class="comment">//      Passed through to D3DXCreateMesh</span>
02117 <span class="comment">//    pGeomXForms</span>
02118 <span class="comment">//      [optional] Each sub mesh is transformed by the corresponding</span>
02119 <span class="comment">//      matrix if this array is supplied</span>
02120 <span class="comment">//    pTextureXForms</span>
02121 <span class="comment">//      [optional] UV coordinates for each sub mesh are transformed</span>
02122 <span class="comment">//      by corresponding matrix if supplied</span>
02123 <span class="comment">//    pDecl</span>
02124 <span class="comment">//      [optional] Only information in this DECL is used when merging</span>
02125 <span class="comment">//      data</span>
02126 <span class="comment">//    pD3DDevice</span>
02127 <span class="comment">//      D3D device that is used to create the new mesh</span>
02128 <span class="comment">//    ppMeshOut</span>
02129 <span class="comment">//      Mesh that will be created</span>
02130 <span class="comment">//</span>
02131 <span class="comment">//============================================================================</span>
02132 
02133 
02134 HRESULT WINAPI 
02135     D3DXConcatenateMeshes(
02136         LPD3DXMESH *ppMeshes, 
02137         UINT NumMeshes, 
02138         DWORD Options, 
02139         CONST D3DXMATRIX *pGeomXForms, 
02140         CONST D3DXMATRIX *pTextureXForms, 
02141         CONST D3DVERTEXELEMENT9 *pDecl,
02142         LPDIRECT3DDEVICE9 pD3DDevice, 
02143         LPD3DXMESH *ppMeshOut);
02144 
02145 <span class="comment">//============================================================================</span>
02146 <span class="comment">//</span>
02147 <span class="comment">//  D3DXSHPRTCompSuperCluster:</span>
02148 <span class="comment">//  --------------------------</span>
02149 <span class="comment">//  Used with compressed results of D3DXSHPRTSimulation.</span>
02150 <span class="comment">//  Generates "super clusters" - groups of clusters that can be drawn in</span>
02151 <span class="comment">//  the same draw call.  A greedy algorithm that minimizes overdraw is used</span>
02152 <span class="comment">//  to group the clusters.</span>
02153 <span class="comment">//</span>
02154 <span class="comment">//  Parameters:</span>
02155 <span class="comment">//   pClusterIDs</span>
02156 <span class="comment">//      NumVerts cluster ID's (extracted from a compressed buffer)</span>
02157 <span class="comment">//   pScene</span>
02158 <span class="comment">//      Mesh that represents composite scene passed to the simulator</span>
02159 <span class="comment">//   MaxNumClusters</span>
02160 <span class="comment">//      Maximum number of clusters allocated per super cluster</span>
02161 <span class="comment">//   NumClusters</span>
02162 <span class="comment">//      Number of clusters computed in the simulator</span>
02163 <span class="comment">//   pSuperClusterIDs</span>
02164 <span class="comment">//      Array of length NumClusters, contains index of super cluster</span>
02165 <span class="comment">//      that corresponding cluster was assigned to</span>
02166 <span class="comment">//   pNumSuperClusters</span>
02167 <span class="comment">//      Returns the number of super clusters allocated</span>
02168 <span class="comment">//      </span>
02169 <span class="comment">//============================================================================</span>
02170 
02171 HRESULT WINAPI 
02172     D3DXSHPRTCompSuperCluster(
02173         UINT *pClusterIDs, 
02174         LPD3DXMESH pScene, 
02175         UINT MaxNumClusters, 
02176         UINT NumClusters,
02177         UINT *pSuperClusterIDs, 
02178         UINT *pNumSuperClusters);
02179 
02180 <span class="comment">//============================================================================</span>
02181 <span class="comment">//</span>
02182 <span class="comment">//  D3DXSHPRTCompSplitMeshSC:</span>
02183 <span class="comment">//  -------------------------</span>
02184 <span class="comment">//  Used with compressed results of the vertex version of the PRT simulator.</span>
02185 <span class="comment">//  After D3DXSHRTCompSuperCluster has been called this function can be used</span>
02186 <span class="comment">//  to split the mesh into a group of faces/vertices per super cluster.</span>
02187 <span class="comment">//  Each super cluster contains all of the faces that contain any vertex</span>
02188 <span class="comment">//  classified in one of its clusters.  All of the vertices connected to this</span>
02189 <span class="comment">//  set of faces are also included with the returned array ppVertStatus </span>
02190 <span class="comment">//  indicating whether or not the vertex belongs to the supercluster.</span>
02191 <span class="comment">//</span>
02192 <span class="comment">//  Parameters:</span>
02193 <span class="comment">//   pClusterIDs</span>
02194 <span class="comment">//      NumVerts cluster ID's (extracted from a compressed buffer)</span>
02195 <span class="comment">//   NumVertices</span>
02196 <span class="comment">//      Number of vertices in original mesh</span>
02197 <span class="comment">//   NumClusters</span>
02198 <span class="comment">//      Number of clusters (input parameter to compression)</span>
02199 <span class="comment">//   pSuperClusterIDs</span>
02200 <span class="comment">//      Array of size NumClusters that will contain super cluster ID's (from</span>
02201 <span class="comment">//      D3DXSHCompSuerCluster)</span>
02202 <span class="comment">//   NumSuperClusters</span>
02203 <span class="comment">//      Number of superclusters allocated in D3DXSHCompSuerCluster</span>
02204 <span class="comment">//   pInputIB</span>
02205 <span class="comment">//      Raw index buffer for mesh - format depends on bInputIBIs32Bit</span>
02206 <span class="comment">//   InputIBIs32Bit</span>
02207 <span class="comment">//      Indicates whether the input index buffer is 32-bit (otherwise 16-bit</span>
02208 <span class="comment">//      is assumed)</span>
02209 <span class="comment">//   NumFaces</span>
02210 <span class="comment">//      Number of faces in the original mesh (pInputIB is 3 times this length)</span>
02211 <span class="comment">//   ppIBData</span>
02212 <span class="comment">//      LPD3DXBUFFER holds raw index buffer that will contain the resulting split faces.  </span>
02213 <span class="comment">//      Format determined by bIBIs32Bit.  Allocated by function</span>
02214 <span class="comment">//   pIBDataLength</span>
02215 <span class="comment">//      Length of ppIBData, assigned in function</span>
02216 <span class="comment">//   OutputIBIs32Bit</span>
02217 <span class="comment">//      Indicates whether the output index buffer is to be 32-bit (otherwise </span>
02218 <span class="comment">//      16-bit is assumed)</span>
02219 <span class="comment">//   ppFaceRemap</span>
02220 <span class="comment">//      LPD3DXBUFFER mapping of each face in ppIBData to original faces.  Length is</span>
02221 <span class="comment">//      *pIBDataLength/3.  Optional paramter, allocated in function</span>
02222 <span class="comment">//   ppVertData</span>
02223 <span class="comment">//      LPD3DXBUFFER contains new vertex data structure.  Size of pVertDataLength</span>
02224 <span class="comment">//   pVertDataLength</span>
02225 <span class="comment">//      Number of new vertices in split mesh.  Assigned in function</span>
02226 <span class="comment">//   pSCClusterList</span>
02227 <span class="comment">//      Array of length NumClusters which pSCData indexes into (Cluster* fields)</span>
02228 <span class="comment">//      for each SC, contains clusters sorted by super cluster</span>
02229 <span class="comment">//   pSCData</span>
02230 <span class="comment">//      Structure per super cluster - contains indices into ppIBData,</span>
02231 <span class="comment">//      pSCClusterList and ppVertData</span>
02232 <span class="comment">//</span>
02233 <span class="comment">//============================================================================</span>
02234 
02235 HRESULT WINAPI 
02236     D3DXSHPRTCompSplitMeshSC(
02237         UINT *pClusterIDs, 
02238         UINT NumVertices, 
02239         UINT NumClusters, 
02240         UINT *pSuperClusterIDs, 
02241         UINT NumSuperClusters,
02242         LPVOID pInputIB, 
02243         BOOL InputIBIs32Bit, 
02244         UINT NumFaces,
02245         LPD3DXBUFFER *ppIBData, 
02246         UINT *pIBDataLength, 
02247         BOOL OutputIBIs32Bit, 
02248         LPD3DXBUFFER *ppFaceRemap, 
02249         LPD3DXBUFFER *ppVertData, 
02250         UINT *pVertDataLength, 
02251         UINT *pSCClusterList,
02252         D3DXSHPRTSPLITMESHCLUSTERDATA *pSCData);
02253         
02254         
02255 <span class="preprocessor">#ifdef __cplusplus</span>
02256 <span class="preprocessor"></span>}
02257 <span class="preprocessor">#endif //__cplusplus</span>
02258 <span class="preprocessor"></span>
02260 <span class="comment">//</span>
02261 <span class="comment">//  Definitions of .X file templates used by mesh load/save functions </span>
02262 <span class="comment">//    that are not RM standard</span>
02263 <span class="comment">//</span>
02265 <span class="comment"></span>
02266 <span class="comment">// {3CF169CE-FF7C-44ab-93C0-F78F62D172E2}</span>
02267 DEFINE_GUID(DXFILEOBJ_XSkinMeshHeader,
02268 0x3cf169ce, 0xff7c, 0x44ab, 0x93, 0xc0, 0xf7, 0x8f, 0x62, 0xd1, 0x72, 0xe2);
02269 
02270 <span class="comment">// {B8D65549-D7C9-4995-89CF-53A9A8B031E3}</span>
02271 DEFINE_GUID(DXFILEOBJ_VertexDuplicationIndices, 
02272 0xb8d65549, 0xd7c9, 0x4995, 0x89, 0xcf, 0x53, 0xa9, 0xa8, 0xb0, 0x31, 0xe3);
02273 
02274 <span class="comment">// {A64C844A-E282-4756-8B80-250CDE04398C}</span>
02275 DEFINE_GUID(DXFILEOBJ_FaceAdjacency, 
02276 0xa64c844a, 0xe282, 0x4756, 0x8b, 0x80, 0x25, 0xc, 0xde, 0x4, 0x39, 0x8c);
02277 
02278 <span class="comment">// {6F0D123B-BAD2-4167-A0D0-80224F25FABB}</span>
02279 DEFINE_GUID(DXFILEOBJ_SkinWeights, 
02280 0x6f0d123b, 0xbad2, 0x4167, 0xa0, 0xd0, 0x80, 0x22, 0x4f, 0x25, 0xfa, 0xbb);
02281 
02282 <span class="comment">// {A3EB5D44-FC22-429d-9AFB-3221CB9719A6}</span>
02283 DEFINE_GUID(DXFILEOBJ_Patch, 
02284 0xa3eb5d44, 0xfc22, 0x429d, 0x9a, 0xfb, 0x32, 0x21, 0xcb, 0x97, 0x19, 0xa6);
02285 
02286 <span class="comment">// {D02C95CC-EDBA-4305-9B5D-1820D7704BBF}</span>
02287 DEFINE_GUID(DXFILEOBJ_PatchMesh, 
02288 0xd02c95cc, 0xedba, 0x4305, 0x9b, 0x5d, 0x18, 0x20, 0xd7, 0x70, 0x4b, 0xbf);
02289 
02290 <span class="comment">// {B9EC94E1-B9A6-4251-BA18-94893F02C0EA}</span>
02291 DEFINE_GUID(DXFILEOBJ_PatchMesh9, 
02292 0xb9ec94e1, 0xb9a6, 0x4251, 0xba, 0x18, 0x94, 0x89, 0x3f, 0x2, 0xc0, 0xea);
02293 
02294 <span class="comment">// {B6C3E656-EC8B-4b92-9B62-681659522947}</span>
02295 DEFINE_GUID(DXFILEOBJ_PMInfo, 
02296 0xb6c3e656, 0xec8b, 0x4b92, 0x9b, 0x62, 0x68, 0x16, 0x59, 0x52, 0x29, 0x47);
02297 
02298 <span class="comment">// {917E0427-C61E-4a14-9C64-AFE65F9E9844}</span>
02299 DEFINE_GUID(DXFILEOBJ_PMAttributeRange, 
02300 0x917e0427, 0xc61e, 0x4a14, 0x9c, 0x64, 0xaf, 0xe6, 0x5f, 0x9e, 0x98, 0x44);
02301 
02302 <span class="comment">// {574CCC14-F0B3-4333-822D-93E8A8A08E4C}</span>
02303 DEFINE_GUID(DXFILEOBJ_PMVSplitRecord,
02304 0x574ccc14, 0xf0b3, 0x4333, 0x82, 0x2d, 0x93, 0xe8, 0xa8, 0xa0, 0x8e, 0x4c);
02305 
02306 <span class="comment">// {B6E70A0E-8EF9-4e83-94AD-ECC8B0C04897}</span>
02307 DEFINE_GUID(DXFILEOBJ_FVFData, 
02308 0xb6e70a0e, 0x8ef9, 0x4e83, 0x94, 0xad, 0xec, 0xc8, 0xb0, 0xc0, 0x48, 0x97);
02309 
02310 <span class="comment">// {F752461C-1E23-48f6-B9F8-8350850F336F}</span>
02311 DEFINE_GUID(DXFILEOBJ_VertexElement, 
02312 0xf752461c, 0x1e23, 0x48f6, 0xb9, 0xf8, 0x83, 0x50, 0x85, 0xf, 0x33, 0x6f);
02313 
02314 <span class="comment">// {BF22E553-292C-4781-9FEA-62BD554BDD93}</span>
02315 DEFINE_GUID(DXFILEOBJ_DeclData, 
02316 0xbf22e553, 0x292c, 0x4781, 0x9f, 0xea, 0x62, 0xbd, 0x55, 0x4b, 0xdd, 0x93);
02317 
02318 <span class="comment">// {F1CFE2B3-0DE3-4e28-AFA1-155A750A282D}</span>
02319 DEFINE_GUID(DXFILEOBJ_EffectFloats, 
02320 0xf1cfe2b3, 0xde3, 0x4e28, 0xaf, 0xa1, 0x15, 0x5a, 0x75, 0xa, 0x28, 0x2d);
02321 
02322 <span class="comment">// {D55B097E-BDB6-4c52-B03D-6051C89D0E42}</span>
02323 DEFINE_GUID(DXFILEOBJ_EffectString, 
02324 0xd55b097e, 0xbdb6, 0x4c52, 0xb0, 0x3d, 0x60, 0x51, 0xc8, 0x9d, 0xe, 0x42);
02325 
02326 <span class="comment">// {622C0ED0-956E-4da9-908A-2AF94F3CE716}</span>
02327 DEFINE_GUID(DXFILEOBJ_EffectDWord, 
02328 0x622c0ed0, 0x956e, 0x4da9, 0x90, 0x8a, 0x2a, 0xf9, 0x4f, 0x3c, 0xe7, 0x16);
02329 
02330 <span class="comment">// {3014B9A0-62F5-478c-9B86-E4AC9F4E418B}</span>
02331 DEFINE_GUID(DXFILEOBJ_EffectParamFloats, 
02332 0x3014b9a0, 0x62f5, 0x478c, 0x9b, 0x86, 0xe4, 0xac, 0x9f, 0x4e, 0x41, 0x8b);
02333 
02334 <span class="comment">// {1DBC4C88-94C1-46ee-9076-2C28818C9481}</span>
02335 DEFINE_GUID(DXFILEOBJ_EffectParamString, 
02336 0x1dbc4c88, 0x94c1, 0x46ee, 0x90, 0x76, 0x2c, 0x28, 0x81, 0x8c, 0x94, 0x81);
02337 
02338 <span class="comment">// {E13963BC-AE51-4c5d-B00F-CFA3A9D97CE5}</span>
02339 DEFINE_GUID(DXFILEOBJ_EffectParamDWord,
02340 0xe13963bc, 0xae51, 0x4c5d, 0xb0, 0xf, 0xcf, 0xa3, 0xa9, 0xd9, 0x7c, 0xe5);
02341 
02342 <span class="comment">// {E331F7E4-0559-4cc2-8E99-1CEC1657928F}</span>
02343 DEFINE_GUID(DXFILEOBJ_EffectInstance, 
02344 0xe331f7e4, 0x559, 0x4cc2, 0x8e, 0x99, 0x1c, 0xec, 0x16, 0x57, 0x92, 0x8f);
02345 
02346 <span class="comment">// {9E415A43-7BA6-4a73-8743-B73D47E88476}</span>
02347 DEFINE_GUID(DXFILEOBJ_AnimTicksPerSecond, 
02348 0x9e415a43, 0x7ba6, 0x4a73, 0x87, 0x43, 0xb7, 0x3d, 0x47, 0xe8, 0x84, 0x76);
02349 
02350 <span class="comment">// {7F9B00B3-F125-4890-876E-1CFFBF697C4D}</span>
02351 DEFINE_GUID(DXFILEOBJ_CompressedAnimationSet, 
02352 0x7f9b00b3, 0xf125, 0x4890, 0x87, 0x6e, 0x1c, 0x42, 0xbf, 0x69, 0x7c, 0x4d);
02353 
02354 <span class="preprocessor">#pragma pack(push, 1)</span>
02355 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span>_XFILECOMPRESSEDANIMATIONSET
02356 {
02357     DWORD CompressedBlockSize;
02358     FLOAT TicksPerSec;
02359     DWORD PlaybackType;
02360     DWORD BufferLength;
02361 } XFILECOMPRESSEDANIMATIONSET;
02362 <span class="preprocessor">#pragma pack(pop)</span>
02363 <span class="preprocessor"></span>
02364 <span class="preprocessor">#define XSKINEXP_TEMPLATES \</span>
02365 <span class="preprocessor">        "xof 0303txt 0032\</span>
02366 <span class="preprocessor">        template XSkinMeshHeader \</span>
02367 <span class="preprocessor">        { \</span>
02368 <span class="preprocessor">            &lt;3CF169CE-FF7C-44ab-93C0-F78F62D172E2&gt; \</span>
02369 <span class="preprocessor">            WORD nMaxSkinWeightsPerVertex; \</span>
02370 <span class="preprocessor">            WORD nMaxSkinWeightsPerFace; \</span>
02371 <span class="preprocessor">            WORD nBones; \</span>
02372 <span class="preprocessor">        } \</span>
02373 <span class="preprocessor">        template VertexDuplicationIndices \</span>
02374 <span class="preprocessor">        { \</span>
02375 <span class="preprocessor">            &lt;B8D65549-D7C9-4995-89CF-53A9A8B031E3&gt; \</span>
02376 <span class="preprocessor">            DWORD nIndices; \</span>
02377 <span class="preprocessor">            DWORD nOriginalVertices; \</span>
02378 <span class="preprocessor">            array DWORD indices[nIndices]; \</span>
02379 <span class="preprocessor">        } \</span>
02380 <span class="preprocessor">        template FaceAdjacency \</span>
02381 <span class="preprocessor">        { \</span>
02382 <span class="preprocessor">            &lt;A64C844A-E282-4756-8B80-250CDE04398C&gt; \</span>
02383 <span class="preprocessor">            DWORD nIndices; \</span>
02384 <span class="preprocessor">            array DWORD indices[nIndices]; \</span>
02385 <span class="preprocessor">        } \</span>
02386 <span class="preprocessor">        template SkinWeights \</span>
02387 <span class="preprocessor">        { \</span>
02388 <span class="preprocessor">            &lt;6F0D123B-BAD2-4167-A0D0-80224F25FABB&gt; \</span>
02389 <span class="preprocessor">            STRING transformNodeName; \</span>
02390 <span class="preprocessor">            DWORD nWeights; \</span>
02391 <span class="preprocessor">            array DWORD vertexIndices[nWeights]; \</span>
02392 <span class="preprocessor">            array float weights[nWeights]; \</span>
02393 <span class="preprocessor">            Matrix4x4 matrixOffset; \</span>
02394 <span class="preprocessor">        } \</span>
02395 <span class="preprocessor">        template Patch \</span>
02396 <span class="preprocessor">        { \</span>
02397 <span class="preprocessor">            &lt;A3EB5D44-FC22-429D-9AFB-3221CB9719A6&gt; \</span>
02398 <span class="preprocessor">            DWORD nControlIndices; \</span>
02399 <span class="preprocessor">            array DWORD controlIndices[nControlIndices]; \</span>
02400 <span class="preprocessor">        } \</span>
02401 <span class="preprocessor">        template PatchMesh \</span>
02402 <span class="preprocessor">        { \</span>
02403 <span class="preprocessor">            &lt;D02C95CC-EDBA-4305-9B5D-1820D7704BBF&gt; \</span>
02404 <span class="preprocessor">            DWORD nVertices; \</span>
02405 <span class="preprocessor">            array Vector vertices[nVertices]; \</span>
02406 <span class="preprocessor">            DWORD nPatches; \</span>
02407 <span class="preprocessor">            array Patch patches[nPatches]; \</span>
02408 <span class="preprocessor">            [ ... ] \</span>
02409 <span class="preprocessor">        } \</span>
02410 <span class="preprocessor">        template PatchMesh9 \</span>
02411 <span class="preprocessor">        { \</span>
02412 <span class="preprocessor">            &lt;B9EC94E1-B9A6-4251-BA18-94893F02C0EA&gt; \</span>
02413 <span class="preprocessor">            DWORD Type; \</span>
02414 <span class="preprocessor">            DWORD Degree; \</span>
02415 <span class="preprocessor">            DWORD Basis; \</span>
02416 <span class="preprocessor">            DWORD nVertices; \</span>
02417 <span class="preprocessor">            array Vector vertices[nVertices]; \</span>
02418 <span class="preprocessor">            DWORD nPatches; \</span>
02419 <span class="preprocessor">            array Patch patches[nPatches]; \</span>
02420 <span class="preprocessor">            [ ... ] \</span>
02421 <span class="preprocessor">        } " \</span>
02422 <span class="preprocessor">        "template EffectFloats \</span>
02423 <span class="preprocessor">        { \</span>
02424 <span class="preprocessor">            &lt;F1CFE2B3-0DE3-4e28-AFA1-155A750A282D&gt; \</span>
02425 <span class="preprocessor">            DWORD nFloats; \</span>
02426 <span class="preprocessor">            array float Floats[nFloats]; \</span>
02427 <span class="preprocessor">        } \</span>
02428 <span class="preprocessor">        template EffectString \</span>
02429 <span class="preprocessor">        { \</span>
02430 <span class="preprocessor">            &lt;D55B097E-BDB6-4c52-B03D-6051C89D0E42&gt; \</span>
02431 <span class="preprocessor">            STRING Value; \</span>
02432 <span class="preprocessor">        } \</span>
02433 <span class="preprocessor">        template EffectDWord \</span>
02434 <span class="preprocessor">        { \</span>
02435 <span class="preprocessor">            &lt;622C0ED0-956E-4da9-908A-2AF94F3CE716&gt; \</span>
02436 <span class="preprocessor">            DWORD Value; \</span>
02437 <span class="preprocessor">        } " \</span>
02438 <span class="preprocessor">        "template EffectParamFloats \</span>
02439 <span class="preprocessor">        { \</span>
02440 <span class="preprocessor">            &lt;3014B9A0-62F5-478c-9B86-E4AC9F4E418B&gt; \</span>
02441 <span class="preprocessor">            STRING ParamName; \</span>
02442 <span class="preprocessor">            DWORD nFloats; \</span>
02443 <span class="preprocessor">            array float Floats[nFloats]; \</span>
02444 <span class="preprocessor">        } " \</span>
02445 <span class="preprocessor">        "template EffectParamString \</span>
02446 <span class="preprocessor">        { \</span>
02447 <span class="preprocessor">            &lt;1DBC4C88-94C1-46ee-9076-2C28818C9481&gt; \</span>
02448 <span class="preprocessor">            STRING ParamName; \</span>
02449 <span class="preprocessor">            STRING Value; \</span>
02450 <span class="preprocessor">        } \</span>
02451 <span class="preprocessor">        template EffectParamDWord \</span>
02452 <span class="preprocessor">        { \</span>
02453 <span class="preprocessor">            &lt;E13963BC-AE51-4c5d-B00F-CFA3A9D97CE5&gt; \</span>
02454 <span class="preprocessor">            STRING ParamName; \</span>
02455 <span class="preprocessor">            DWORD Value; \</span>
02456 <span class="preprocessor">        } \</span>
02457 <span class="preprocessor">        template EffectInstance \</span>
02458 <span class="preprocessor">        { \</span>
02459 <span class="preprocessor">            &lt;E331F7E4-0559-4cc2-8E99-1CEC1657928F&gt; \</span>
02460 <span class="preprocessor">            STRING EffectFilename; \</span>
02461 <span class="preprocessor">            [ ... ] \</span>
02462 <span class="preprocessor">        } " \</span>
02463 <span class="preprocessor">        "template AnimTicksPerSecond \</span>
02464 <span class="preprocessor">        { \</span>
02465 <span class="preprocessor">            &lt;9E415A43-7BA6-4a73-8743-B73D47E88476&gt; \</span>
02466 <span class="preprocessor">            DWORD AnimTicksPerSecond; \</span>
02467 <span class="preprocessor">        } \</span>
02468 <span class="preprocessor">        template CompressedAnimationSet \</span>
02469 <span class="preprocessor">        { \</span>
02470 <span class="preprocessor">            &lt;7F9B00B3-F125-4890-876E-1C42BF697C4D&gt; \</span>
02471 <span class="preprocessor">            DWORD CompressedBlockSize; \</span>
02472 <span class="preprocessor">            FLOAT TicksPerSec; \</span>
02473 <span class="preprocessor">            DWORD PlaybackType; \</span>
02474 <span class="preprocessor">            DWORD BufferLength; \</span>
02475 <span class="preprocessor">            array DWORD CompressedData[BufferLength]; \</span>
02476 <span class="preprocessor">        } "</span>
02477 <span class="preprocessor"></span>
02478 <span class="preprocessor">#define XEXTENSIONS_TEMPLATES \</span>
02479 <span class="preprocessor">        "xof 0303txt 0032\</span>
02480 <span class="preprocessor">        template FVFData \</span>
02481 <span class="preprocessor">        { \</span>
02482 <span class="preprocessor">            &lt;B6E70A0E-8EF9-4e83-94AD-ECC8B0C04897&gt; \</span>
02483 <span class="preprocessor">            DWORD dwFVF; \</span>
02484 <span class="preprocessor">            DWORD nDWords; \</span>
02485 <span class="preprocessor">            array DWORD data[nDWords]; \</span>
02486 <span class="preprocessor">        } \</span>
02487 <span class="preprocessor">        template VertexElement \</span>
02488 <span class="preprocessor">        { \</span>
02489 <span class="preprocessor">            &lt;F752461C-1E23-48f6-B9F8-8350850F336F&gt; \</span>
02490 <span class="preprocessor">            DWORD Type; \</span>
02491 <span class="preprocessor">            DWORD Method; \</span>
02492 <span class="preprocessor">            DWORD Usage; \</span>
02493 <span class="preprocessor">            DWORD UsageIndex; \</span>
02494 <span class="preprocessor">        } \</span>
02495 <span class="preprocessor">        template DeclData \</span>
02496 <span class="preprocessor">        { \</span>
02497 <span class="preprocessor">            &lt;BF22E553-292C-4781-9FEA-62BD554BDD93&gt; \</span>
02498 <span class="preprocessor">            DWORD nElements; \</span>
02499 <span class="preprocessor">            array VertexElement Elements[nElements]; \</span>
02500 <span class="preprocessor">            DWORD nDWords; \</span>
02501 <span class="preprocessor">            array DWORD data[nDWords]; \</span>
02502 <span class="preprocessor">        } \</span>
02503 <span class="preprocessor">        template PMAttributeRange \</span>
02504 <span class="preprocessor">        { \</span>
02505 <span class="preprocessor">            &lt;917E0427-C61E-4a14-9C64-AFE65F9E9844&gt; \</span>
02506 <span class="preprocessor">            DWORD iFaceOffset; \</span>
02507 <span class="preprocessor">            DWORD nFacesMin; \</span>
02508 <span class="preprocessor">            DWORD nFacesMax; \</span>
02509 <span class="preprocessor">            DWORD iVertexOffset; \</span>
02510 <span class="preprocessor">            DWORD nVerticesMin; \</span>
02511 <span class="preprocessor">            DWORD nVerticesMax; \</span>
02512 <span class="preprocessor">        } \</span>
02513 <span class="preprocessor">        template PMVSplitRecord \</span>
02514 <span class="preprocessor">        { \</span>
02515 <span class="preprocessor">            &lt;574CCC14-F0B3-4333-822D-93E8A8A08E4C&gt; \</span>
02516 <span class="preprocessor">            DWORD iFaceCLW; \</span>
02517 <span class="preprocessor">            DWORD iVlrOffset; \</span>
02518 <span class="preprocessor">            DWORD iCode; \</span>
02519 <span class="preprocessor">        } \</span>
02520 <span class="preprocessor">        template PMInfo \</span>
02521 <span class="preprocessor">        { \</span>
02522 <span class="preprocessor">            &lt;B6C3E656-EC8B-4b92-9B62-681659522947&gt; \</span>
02523 <span class="preprocessor">            DWORD nAttributes; \</span>
02524 <span class="preprocessor">            array PMAttributeRange attributeRanges[nAttributes]; \</span>
02525 <span class="preprocessor">            DWORD nMaxValence; \</span>
02526 <span class="preprocessor">            DWORD nMinLogicalVertices; \</span>
02527 <span class="preprocessor">            DWORD nMaxLogicalVertices; \</span>
02528 <span class="preprocessor">            DWORD nVSplits; \</span>
02529 <span class="preprocessor">            array PMVSplitRecord splitRecords[nVSplits]; \</span>
02530 <span class="preprocessor">            DWORD nAttributeMispredicts; \</span>
02531 <span class="preprocessor">            array DWORD attributeMispredicts[nAttributeMispredicts]; \</span>
02532 <span class="preprocessor">        } "</span>
02533 <span class="preprocessor"></span>        
02534 <span class="preprocessor">#endif //__D3DX9MESH_H__</span>
02535 <span class="preprocessor"></span>
02536 
</pre></div><hr><address style="align: right;"><small>
Generated on Tue Jun 13 11:14:34 2006 for gRenderDX9 by <a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 width=110 height=53>
</a> 1.3.1 using KingsTools</small></address>
</body>
</html>
