<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gRenderDX9: d3dRender.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.1 -->
<h1>d3dRender.cpp</h1><div class="fragment"><pre>00001 <span class="comment">/*****************************************************************************/</span>
00002 <span class="comment">/*  File:   d3dRender.cpp</span>
00003 <span class="comment">/*  Desc:   Render system interface implementation for DirectX9 </span>
00004 <span class="comment">/*  Author: Ruslan Shestopalyuk</span>
00005 <span class="comment">/*  Date:   02.11.2004</span>
00006 <span class="comment">/*****************************************************************************/</span>
00007 <span class="preprocessor">#include "gRenderPch.h"</span>
00008 <span class="preprocessor">#include &lt;dxerr9.h&gt;</span>
00009 <span class="preprocessor">#include "resource.h"</span>
00010 
00011 <span class="preprocessor">#include "IMediaManager.h"</span>
00012 <span class="preprocessor">#include "IResourceManager.h"</span>
00013 <span class="preprocessor">#include "rsVertex.h"</span>
00014 
00015 <span class="preprocessor">#include "d3dTexture.h"</span>
00016 <span class="preprocessor">#include "d3dShaderFX.h"</span>
00017 <span class="preprocessor">#include "d3dIndexBuffer.h"</span>
00018 <span class="preprocessor">#include "d3dVertexBuffer.h"</span>
00019 <span class="preprocessor">#include "d3dFont.h"</span>
00020 <span class="preprocessor">#include "d3dRender.h"</span>
00021 <span class="preprocessor">#include "d3dAdapt.h"</span>
00022 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00023 
00024 
00025 <span class="preprocessor">#include "stdafx.h"</span>
00026 <span class="preprocessor">#include "sgTransformNode.h"</span>
00027 <span class="preprocessor">#include "sgLight.h"</span>
00028 
00029 <span class="keywordtype">int</span> OtherTime=0;
00030 <span class="keywordtype">int</span> NDX_calls=0;
00031 
00032 
00033 <span class="comment">/*</span>
00034 <span class="comment">#include "kResFile.h"</span>
00035 <span class="comment">#include "kIO.h"</span>
00036 <span class="comment">#include "kIOHelpers.h"</span>
00037 <span class="comment">#include "vMesh.h"</span>
00038 <span class="comment">#include "sg.h"</span>
00039 <span class="comment">#include "sgNode.h"</span>
00040 <span class="comment">#include "sgGeometry.h"</span>
00041 <span class="comment">#include "sgLight.h"</span>
00042 <span class="comment">*/</span>
00043 
00044 <span class="comment">//  Direct3D libraries</span>
00045 <span class="preprocessor">#pragma comment (lib, "d3d9.lib" )</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#pragma comment (lib, "d3dx9.lib" )</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#pragma comment (lib, "dxguid.lib" )</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#pragma comment (lib, "dxerr9.lib" )</span>
00049 <span class="preprocessor"></span>
00050 IRenderSystem* GetRenderSystem()
00051 {
00052     <span class="keyword">static</span> RenderSystemDX9 s_RSDX9;
00053     <span class="keywordflow">return</span> &amp;s_RSDX9;
00054 }
00055 
00056 DIALOGS_API IRenderSystem* IRS = GetRenderSystem();
00057 
00058 IDirect3DDevice9* GetDirect3DDevice()
00059 {
00060     <span class="keywordflow">return</span> ((RenderSystemDX9*)GetRenderSystem())-&gt;GetDevice();
00061 }
00062 
00063 IDirect3DSurface9* GetDirect3DSurface( <span class="keywordtype">int</span> texID )
00064 {
00065     <span class="keywordflow">return</span> ((RenderSystemDX9*)GetRenderSystem())-&gt;GetSurface( texID );
00066 }
00067 
00068 <span class="comment">//INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT )</span>
00069 <span class="comment">//{</span>
00070 <span class="comment">//    InitCommonControls();</span>
00071 <span class="comment">//    IRS-&gt;Init( hInst, NULL );</span>
00072 <span class="comment">//    return g_RSDX9.Run();</span>
00073 <span class="comment">//} // WinMain</span>
00074 
00075 <span class="comment">/*****************************************************************************/</span>
00076 <span class="comment">/*  RenderSystemDX9 implementation  </span>
00077 <span class="comment">/*****************************************************************************/</span>
00078 RenderSystemDX9::RenderSystemDX9()
00079 {
00080     RECT drct;
00081     SystemParametersInfo( SPI_GETWORKAREA, 0, &amp;drct, 0 );
00082 
00083     m_strWindowTitle        = _T(<span class="stringliteral">"Kangaroo"</span>);
00084     m_d3dEnum.m_bUseZBuffer = TRUE;
00085     
00086     m_dwCreationWidth       = drct.right  - drct.left;
00087     m_dwCreationHeight      = drct.bottom - drct.top;
00088     m_CurrentFrame          = 0;
00089     IRS                     = <span class="keyword">this</span>;
00090     m_bInited               = <span class="keyword">false</span>;
00091     m_CurShader             = -1;
00092     m_CurPass               = 0;
00093     m_ViewPortZNear         = 0.0f;
00094     m_ViewPortZFar          = 1.0f;
00095     m_FPS                   = 0.0f;
00096 
00097     m_pBackBufferSurface    = NULL;
00098     m_pDepthStencilSurface  = NULL;
00099 
00100     m_FogDensity            = 0.00002f;
00101     m_TFactor               = 0xFFFFFFFF;
00102     m_ViewTM                = Matrix4D::identity;
00103     m_ProjTM                = Matrix4D::identity;
00104     m_WorldTM               = Matrix4D::identity;
00105     m_ShadersQuality        = 0;
00106 
00107     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; c_MaxTextureStages; i++) m_CurTex[i] = -1;
00108 
00109     m_TimeIsOverridden      = <span class="keyword">false</span>;
00110     m_RefreshRateIsOverridden = <span class="keyword">false</span>;
00111 } <span class="comment">// RenderSystemDX9::RenderSystemDX9</span>
00112 
00113 RenderSystemDX9::~RenderSystemDX9()
00114 {
00115     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_Textures.size(); i++) <span class="keyword">delete</span> m_Textures[i];
00116     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_Shaders.size(); i++)  <span class="keyword">delete</span> m_Shaders[i];
00117     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_IBuffers.size(); i++) <span class="keyword">delete</span> m_IBuffers[i];
00118     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_VBuffers.size(); i++) <span class="keyword">delete</span> m_VBuffers[i];
00119     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_Fonts.size(); i++)    <span class="keyword">delete</span> m_Fonts[i];
00120 
00121 } <span class="comment">// RenderSystemDX9::~RenderSystemDX9</span>
00122 
00123 <span class="comment">//-----------------------------------------------------------------------------</span>
00124 <span class="comment">// Name: OneTimeSceneInit()</span>
00125 <span class="comment">// Desc: Paired with FinalCleanup().</span>
00126 <span class="comment">//       The window has been created and the IDirect3D9 interface has been</span>
00127 <span class="comment">//       created, but the device has not been created yet.  Here you can</span>
00128 <span class="comment">//       perform application-related initialization and cleanup that does</span>
00129 <span class="comment">//       not depend on a device.</span>
00130 <span class="comment">//-----------------------------------------------------------------------------</span>
00131 HRESULT RenderSystemDX9::OneTimeSceneInit()
00132 {
00133     <span class="keywordflow">return</span> S_OK;
00134 }
00135 
00136 <span class="comment">//-----------------------------------------------------------------------------</span>
00137 <span class="comment">// Name: InitDeviceObjects()</span>
00138 <span class="comment">// Desc: Paired with DeleteDeviceObjects()</span>
00139 <span class="comment">//       The device has been created.  Resources that are not lost on</span>
00140 <span class="comment">//       Reset() can be created here -- resources in D3DPOOL_MANAGED,</span>
00141 <span class="comment">//       D3DPOOL_SCRATCH, or D3DPOOL_SYSTEMMEM.  Image surfaces created via</span>
00142 <span class="comment">//       CreateImageSurface are never lost and can be created here.  Vertex</span>
00143 <span class="comment">//       shaders and pixel shaders can also be created here as they are not</span>
00144 <span class="comment">//       lost on Reset().</span>
00145 <span class="comment">//-----------------------------------------------------------------------------</span>
00146 HRESULT RenderSystemDX9::InitDeviceObjects()
00147 {
00148     CreateVTypeTable();
00149     CreateIB( <span class="stringliteral">"SharedDynamic"</span>,  c_DynIBufferBytes,      isWORD, <span class="keyword">true</span>    );
00150     CreateIB( <span class="stringliteral">"SharedStatic"</span>,   c_StaticIBufferBytes,   isWORD, <span class="keyword">false</span>   );
00151     CreateIB( <span class="stringliteral">"Quads"</span>,          c_QuadIBufferBytes,     isWORD, <span class="keyword">false</span>   );
00152     CreateVB( <span class="stringliteral">"SharedDynamic"</span>,  c_DynVBufferBytes,      -1,     <span class="keyword">true</span>    );
00153     CreateVB( <span class="stringliteral">"SharedStatic"</span>,   c_StaticVBufferBytes,   -1,     <span class="keyword">false</span>   );
00154 
00155     m_ViewPort.x = 0.0f;
00156     m_ViewPort.y = 0.0f;
00157     m_ViewPort.w = m_d3dpp.BackBufferWidth;
00158     m_ViewPort.h = m_d3dpp.BackBufferHeight;
00159 
00160     SAFE_RELEASE(m_pBackBufferSurface);
00161     SAFE_RELEASE(m_pDepthStencilSurface);
00162     DX_CHK( m_pDevice-&gt;GetBackBuffer( 0, 0, D3DBACKBUFFER_TYPE_MONO, &amp;m_pBackBufferSurface ) );
00163     DX_CHK( m_pDevice-&gt;GetDepthStencilSurface( &amp;m_pDepthStencilSurface ) );
00164     <span class="keywordflow">return</span> S_OK;
00165 } <span class="comment">// RenderSystemDX9::InitDeviceObjects</span>
00166 
00167 <span class="comment">//-----------------------------------------------------------------------------</span>
00168 <span class="comment">// Name: RestoreDeviceObjects()</span>
00169 <span class="comment">// Desc: Paired with InvalidateDeviceObjects()</span>
00170 <span class="comment">//       The device exists, but may have just been Reset().  Resources in</span>
00171 <span class="comment">//       D3DPOOL_DEFAULT and any other device state that persists during</span>
00172 <span class="comment">//       rendering should be set here.  Render states, matrices, textures,</span>
00173 <span class="comment">//       etc., that don't change during rendering can be set once here to</span>
00174 <span class="comment">//       avoid redundant state setting during Render()</span>
00175 <span class="comment">//-----------------------------------------------------------------------------</span>
00176 HRESULT RenderSystemDX9::RestoreDeviceObjects()
00177 {
00178     HRESULT hr = S_OK;
00179     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_Textures.size();  i++) m_Textures[i]-&gt;RestoreDeviceObjects();
00180     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_Shaders.size();   i++) m_Shaders[i]-&gt;RestoreDeviceObjects();
00181     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_VBuffers.size();  i++) m_VBuffers[i]-&gt;RestoreDeviceObjects();
00182     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_IBuffers.size();  i++) m_IBuffers[i]-&gt;RestoreDeviceObjects();
00183     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_Fonts.size();     i++) m_Fonts[i]-&gt;RestoreDeviceObjects();
00184 
00185     m_ViewPort.x = 0.0f;
00186     m_ViewPort.y = 0.0f;
00187     m_ViewPort.w = m_d3dpp.BackBufferWidth;
00188     m_ViewPort.h = m_d3dpp.BackBufferHeight;
00189 
00190     SAFE_RELEASE(m_pBackBufferSurface);
00191     SAFE_RELEASE(m_pDepthStencilSurface);
00192     DX_CHK( m_pDevice-&gt;GetBackBuffer( 0, 0, D3DBACKBUFFER_TYPE_MONO, &amp;m_pBackBufferSurface ) );
00193     DX_CHK( m_pDevice-&gt;GetDepthStencilSurface( &amp;m_pDepthStencilSurface ) );
00194 
00195     FillQuadIndexBuffer();
00196 
00197     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_DeviceClients.size(); i++)
00198     {
00199         m_DeviceClients[i]-&gt;OnDestroyRS();
00200     }
00201 
00202     <span class="keywordflow">return</span> hr;
00203 } <span class="comment">// RenderSystemDX9::RestoreDeviceObjects</span>
00204 
00205 <span class="comment">//-----------------------------------------------------------------------------</span>
00206 <span class="comment">// Name: InvalidateDeviceObjects()</span>
00207 <span class="comment">// Desc: Invalidates device objects.  Paired with RestoreDeviceObjects()</span>
00208 <span class="comment">//-----------------------------------------------------------------------------</span>
00209 HRESULT RenderSystemDX9::InvalidateDeviceObjects()
00210 {
00211     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_Textures.size();  i++) m_Textures[i]-&gt;InvalidateDeviceObjects();
00212     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_Shaders.size();   i++) m_Shaders[i]-&gt;InvalidateDeviceObjects();
00213     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_VBuffers.size();  i++) m_VBuffers[i]-&gt;InvalidateDeviceObjects();
00214     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_IBuffers.size();  i++) m_IBuffers[i]-&gt;InvalidateDeviceObjects();
00215     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_Fonts.size();     i++) m_Fonts[i]-&gt;InvalidateDeviceObjects();
00216 
00217     SAFE_RELEASE( m_pBackBufferSurface );
00218     SAFE_RELEASE( m_pDepthStencilSurface );
00219 
00220     <span class="keywordflow">return</span> S_OK;
00221 } <span class="comment">// RenderSystemDX9::InvalidateDeviceObjects</span>
00222 
00223 <span class="comment">//-----------------------------------------------------------------------------</span>
00224 <span class="comment">// Name: DeleteDeviceObjects()</span>
00225 <span class="comment">// Desc: Paired with InitDeviceObjects()</span>
00226 <span class="comment">//       Called when the app is exiting, or the device is being changed,</span>
00227 <span class="comment">//       this function deletes any device dependent objects.  </span>
00228 <span class="comment">//-----------------------------------------------------------------------------</span>
00229 HRESULT RenderSystemDX9::DeleteDeviceObjects()
00230 {
00231     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_Textures.size();  i++) m_Textures[i]-&gt;DeleteDeviceObjects();
00232     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_Shaders.size();   i++) m_Shaders[i]-&gt;DeleteDeviceObjects();
00233     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_VBuffers.size();  i++) m_VBuffers[i]-&gt;DeleteDeviceObjects();
00234     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_IBuffers.size();  i++) m_IBuffers[i]-&gt;DeleteDeviceObjects();
00235     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_Fonts.size();     i++) m_Fonts[i]-&gt;DeleteDeviceObjects();
00236 
00237     SAFE_RELEASE( m_pBackBufferSurface );
00238     SAFE_RELEASE( m_pDepthStencilSurface );
00239 
00240     ClearVTypeTable();
00241     <span class="keywordflow">return</span> S_OK;
00242 } <span class="comment">// RenderSystemDX9::DeleteDeviceObjects</span>
00243 
00244 <span class="comment">//-----------------------------------------------------------------------------</span>
00245 <span class="comment">// Name: FinalCleanup()</span>
00246 <span class="comment">// Desc: Paired with OneTimeSceneInit()</span>
00247 <span class="comment">//       Called before the app exits, this function gives the app the chance</span>
00248 <span class="comment">//       to cleanup after itself.</span>
00249 <span class="comment">//-----------------------------------------------------------------------------</span>
00250 HRESULT RenderSystemDX9::FinalCleanup()
00251 {
00252     <span class="keywordflow">return</span> S_OK;
00253 } <span class="comment">// RenderSystemDX9::FinalCleanup</span>
00254 
00255 <span class="comment">//-----------------------------------------------------------------------------</span>
00256 <span class="comment">// Name: ConfirmDevice()</span>
00257 <span class="comment">// Desc: Called during device initialization, this code checks the device</span>
00258 <span class="comment">//       for some minimum set of capabilities</span>
00259 <span class="comment">//-----------------------------------------------------------------------------</span>
00260 HRESULT RenderSystemDX9::ConfirmDevice( D3DCAPS9* pCaps, DWORD dwBehavior,
00261                                           D3DFORMAT adapterFormat, 
00262                                           D3DFORMAT backBufferFormat )
00263 {
00264     <span class="comment">// Debugging vertex shaders requires either REF or software vertex processing </span>
00265     <span class="comment">// and debugging pixel shaders requires REF.  </span>
00266 <span class="preprocessor">    #ifdef DEBUG_VS</span>
00267 <span class="preprocessor"></span>        <span class="keywordflow">if</span>( pCaps-&gt;DeviceType != D3DDEVTYPE_REF &amp;&amp; 
00268             (dwBehavior &amp; D3DCREATE_SOFTWARE_VERTEXPROCESSING) == 0 )
00269             <span class="keywordflow">return</span> E_FAIL;
00270 <span class="preprocessor">    #endif</span>
00271 <span class="preprocessor"></span><span class="preprocessor">    #ifdef DEBUG_PS</span>
00272 <span class="preprocessor"></span>        <span class="keywordflow">if</span>( pCaps-&gt;DeviceType != D3DDEVTYPE_REF )
00273             <span class="keywordflow">return</span> E_FAIL;
00274 <span class="preprocessor">    #endif</span>
00275 <span class="preprocessor"></span>
00276     <span class="keywordflow">if</span> (dwBehavior &amp; D3DCREATE_PUREDEVICE) <span class="keywordflow">return</span> E_FAIL;
00277     <span class="comment">// No fallback, so need ps1.1</span>
00278     <span class="keywordflow">if</span> (pCaps-&gt;PixelShaderVersion &lt; D3DPS_VERSION(1,1))
00279     {
00280         <span class="keywordflow">return</span> E_FAIL;
00281     }
00282 
00283     <span class="comment">// If device doesn't support 1.1 vertex shaders in HW, switch to SWVP.</span>
00284     <span class="keywordflow">if</span> (pCaps-&gt;VertexShaderVersion &lt; D3DVS_VERSION(1,1))
00285     {
00286         <span class="keywordflow">if</span> ((dwBehavior &amp; D3DCREATE_SOFTWARE_VERTEXPROCESSING ) == 0)
00287         {
00288             <span class="keywordflow">return</span> E_FAIL;
00289         }
00290     }
00291 
00292     <span class="keywordflow">return</span> S_OK;
00293 } <span class="comment">// RenderSystemDX9::ConfirmDevice</span>
00294 
00295 <span class="keywordtype">void</span> InitMath();
00296 <span class="keywordtype">void</span> RenderSystemDX9::Init( HINSTANCE hInst, HWND hWnd )
00297 {
00298     <span class="keywordflow">if</span> (m_bInited)
00299     {
00300         Log.Warning( <span class="stringliteral">"RenderSystemDX9: trying to initialize twice."</span> );
00301         <span class="keywordflow">return</span>;
00302     }
00303 
00304     HRESULT hr = Create( hInst, hWnd );
00305     <span class="keywordtype">bool</span> sInst = SupportsInstancing();
00306     m_bInited = (hr == S_OK);
00307     
00308     InitMath();
00309 
00310     IRM-&gt;MountDataSource( <span class="stringliteral">"Shaders"</span>,        <span class="stringliteral">"Shaders"</span>   );
00311     IRM-&gt;MountDataSource( <span class="stringliteral">"Models"</span>,         <span class="stringliteral">"Models"</span>    );
00312     IRM-&gt;MountDataSource( <span class="stringliteral">"Textures"</span>,       <span class="stringliteral">"Textures"</span>  );
00313     IRM-&gt;MountDataSource( <span class="stringliteral">"Scripts"</span>,        <span class="stringliteral">"Scripts"</span>   );
00314 } <span class="comment">// RenderSystemDX9::Init</span>
00315 
00316 <span class="keywordtype">void</span> RenderSystemDX9::ShutDown()
00317 {
00318     Cleanup3DEnvironment();
00319 } <span class="comment">// RenderSystemDX9::ShutDown</span>
00320 
00321 <span class="keywordtype">bool</span> RenderSystemDX9::SetScreenProp( <span class="keyword">const</span> ScreenProp&amp; prop ) 
00322 { 
00323     <span class="keywordflow">if</span> (prop.m_Width == 0 || prop.m_Height == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00324     <span class="keywordflow">if</span> (prop.m_bFullScreen)
00325     {
00326         m_d3dSettings.m_bIsWindowed                 = <span class="keyword">true</span>;
00327         m_d3dSettings.Fullscreen_DisplayMode.Width  = prop.m_Width;
00328         m_d3dSettings.Fullscreen_DisplayMode.Height = prop.m_Height;
00329         FindBestFullscreenMode( <span class="keyword">true</span>, <span class="keyword">false</span> );
00330     }
00331     <span class="keywordflow">else</span>
00332     {
00333         m_d3dSettings.m_bIsWindowed     = <span class="keyword">true</span>;
00334         m_d3dSettings.Windowed_Width    = prop.m_Width;
00335         m_d3dSettings.Windowed_Height   = prop.m_Height;
00336 
00337         SetMonitorResolution();
00338         FindBestWindowedMode( <span class="keyword">true</span>, <span class="keyword">false</span> );
00339     }
00340 
00341     <span class="keywordflow">return</span> (HandlePossibleSizeChange() != S_OK);
00342 } <span class="comment">// RenderSystemDX9::SetScreenProp</span>
00343 
00344 <span class="keyword">const</span> <span class="keywordtype">char</span>* GetDispChangeErrorDesc( LONG result );
00345 <span class="keywordtype">bool</span> RenderSystemDX9::SetMonitorResolution()
00346 {
00347     DEVMODE devMode;
00348     ZeroMemory( &amp;devMode, <span class="keyword">sizeof</span>( devMode ) );
00349     devMode.dmSize              = <span class="keyword">sizeof</span>( DEVMODE );
00350 
00351     <span class="keywordtype">int</span> w = INT_MAX;
00352     <span class="keywordtype">int</span> h = INT_MAX;
00353     <span class="keywordtype">int</span> hz = 0;
00354 
00355     <span class="keywordtype">int</span> dw = m_d3dSettings.Windowed_Width;
00356     <span class="keywordtype">int</span> dh = m_d3dSettings.Windowed_Height;
00357 
00358     m_BestDisplayModes.clear();
00359 
00360     D3DAdapterInfo* pAd = m_d3dSettings.PAdapterInfo();
00361     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; pAd-&gt;m_DisplayModes.size(); i++)
00362     {
00363         D3DDISPLAYMODE&amp; dmode = pAd-&gt;m_DisplayModes[i];
00364         <span class="keywordflow">if</span> ((dmode.Width &gt;= dw &amp;&amp; dmode.Height &gt;= dh) &amp;&amp; 
00365             (dmode.Width &lt;= w &amp;&amp; dmode.Height &lt;= h &amp;&amp; dmode.RefreshRate &gt;= hz))
00366         {
00367             w  = dmode.Width;
00368             h  = dmode.Height; 
00369             hz = dmode.RefreshRate;
00370         }
00371     }
00372 
00373     <span class="keywordflow">if</span> (w == INT_MAX || h == INT_MAX || hz == INT_MAX)
00374     {
00375         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00376     }
00377     
00378     D3DFORMAT bbFormat = m_d3dSettings.BackBufferFormat();
00379 
00380     devMode.dmPelsWidth         = w;
00381     devMode.dmPelsHeight        = h;
00382     devMode.dmBitsPerPel        = (bbFormat == D3DFMT_R5G6B5) ? 16 : 32;
00383     devMode.dmDisplayFrequency  = m_RefreshRateIsOverridden ? m_HzOverriddenRefreshRate : hz;
00384     devMode.dmFields            =   DM_PELSWIDTH | 
00385                                     DM_PELSHEIGHT | 
00386                                     DM_DISPLAYFREQUENCY |
00387                                     DM_BITSPERPEL;
00388 
00389     DWORD displayModeFlags = 0;
00390     <span class="keywordflow">if</span> (!m_d3dSettings.m_bIsWindowed) displayModeFlags |= CDS_FULLSCREEN;
00391     <span class="keywordtype">int</span> devModeRes = ChangeDisplaySettings( &amp;devMode, displayModeFlags );
00392     DWORD winErr = GetLastError();
00393     <span class="keywordflow">if</span> (devModeRes != DISP_CHANGE_SUCCESSFUL)
00394     {
00395         Log.Error( GetDispChangeErrorDesc( devModeRes ) );
00396         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00397     }
00398 
00399     <span class="comment">/*if (m_ScreenProp.m_bCoverDesktop)</span>
00400 <span class="comment">    {</span>
00401 <span class="comment">        RECT drct;</span>
00402 <span class="comment">        HWND hDesk = GetDesktopWindow();</span>
00403 <span class="comment">        ::GetWindowRect( hDesk, &amp;drct );</span>
00404 <span class="comment">        SystemParametersInfo( SPI_GETWORKAREA, 0, &amp;drct, 0 );</span>
00405 <span class="comment">        m_ScreenProp.m_Width  = drct.right  - drct.left;</span>
00406 <span class="comment">        m_ScreenProp.m_Height = drct.bottom - drct.top;</span>
00407 <span class="comment">    }*/</span>
00408 
00409     <span class="keywordtype">int</span> wX = 0;
00410     <span class="keywordtype">int</span> wY = 0;
00411     <span class="keywordtype">int</span> wW = m_d3dSettings.Windowed_Width;
00412     <span class="keywordtype">int</span> wH = m_d3dSettings.Windowed_Height;
00413 
00414     SetWindowPos( m_hWnd, HWND_NOTOPMOST, wX, wY, wW, wH, SWP_SHOWWINDOW );
00415     ShowWindow( m_hWnd, SW_SHOW );
00416 
00417     RECT    wrct;
00418     ::GetWindowRect( m_hWnd, &amp;wrct );
00419     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00420 } <span class="comment">// RenderSystemDX9::SetMonitorResolution</span>
00421 
00422 ScreenProp RenderSystemDX9::GetScreenProp() 
00423 { 
00424     <span class="keywordflow">return</span> ScreenProp(); 
00425 }
00426 
00427 <span class="keywordtype">void</span> RenderSystemDX9::SetViewTM( <span class="keyword">const</span> Matrix4D&amp; vmatr )
00428 {
00429     m_ViewTM = vmatr;
00430     __beginT()
00431     DX_CHK( m_pDevice-&gt;SetTransform( D3DTS_VIEW, (D3DMATRIX*)&amp;vmatr ) );
00432     __endT(OtherTime);
00433 }
00434 
00435 <span class="keywordtype">void</span> RenderSystemDX9::SetProjTM( <span class="keyword">const</span> Matrix4D&amp; pmatr )
00436 {
00437     m_ProjTM = pmatr;
00438     __beginT();
00439     DX_CHK( m_pDevice-&gt;SetTransform( D3DTS_PROJECTION, (D3DMATRIX*)&amp;pmatr ) );
00440     __endT(OtherTime);
00441 } <span class="comment">// RenderSystemDX9::SetProjTM</span>
00442 <span class="keywordtype">int</span> TimeInSWTM=0;
00443 <span class="keywordtype">void</span> RenderSystemDX9::SetWorldTM( <span class="keyword">const</span> Matrix4D&amp; wmatr )
00444 {
00445     m_WorldTM = wmatr;
00446 
00447     __beginT();
00448 
00449     DX_CHK( m_pDevice-&gt;SetTransform( D3DTS_WORLD, (D3DMATRIX*)&amp;wmatr ) );
00450 
00451     __endT(TimeInSWTM);
00452 
00453     m_WTM_is1 = <span class="keyword">false</span>;
00454 } <span class="comment">// RenderSystemDX9::SetWorldTM</span>
00455 
00456 <span class="keywordtype">void</span> RenderSystemDX9::SetWorldViewProjTM( <span class="keyword">const</span> Matrix4D&amp; wmatr )
00457 {
00458     m_WorldViewProjTM = wmatr;  
00459 } <span class="comment">// RenderSystemDX9::SetWorldViewProjTM</span>
00460 
00461 <span class="keywordtype">void</span> RenderSystemDX9::ResetWorldTM()
00462 {
00463     <span class="keywordflow">if</span>(m_WTM_is1)<span class="keywordflow">return</span>;
00464     m_WorldTM = Matrix4D::identity;
00465 
00466     __beginT();
00467 
00468     DX_CHK( m_pDevice-&gt;SetTransform( D3DTS_WORLD, (D3DMATRIX*)&amp;Matrix4D::identity ) );
00469 
00470     __endT(TimeInSWTM);
00471 
00472     m_WTM_is1 = <span class="keyword">true</span>;
00473 } <span class="comment">// RenderSystemDX9::ResetWorldTM</span>
00474 
00475 <span class="keywordtype">void</span> RenderSystemDX9::SetTextureTM( <span class="keyword">const</span> Matrix4D&amp; tmatr, <span class="keywordtype">int</span> stage ) 
00476 {
00477     m_TextureTM[stage] = tmatr;
00478     __beginT();
00479     DX_CHK( m_pDevice-&gt;SetTransform( (D3DTRANSFORMSTATETYPE)(D3DTS_TEXTURE0 + stage), (D3DMATRIX*)&amp;tmatr ) );
00480     __endT(OtherTime);
00481 } <span class="comment">// RenderSystemDX9::SetTextureTM</span>
00482 
00483 <span class="keywordtype">void</span> RenderSystemDX9::SetBumpTM( <span class="keyword">const</span> Matrix3D&amp; bmatr, <span class="keywordtype">int</span> stage ) 
00484 {
00485     __beginT();
00486     DX_CHK( m_pDevice-&gt;SetTextureStageState( stage, D3DTSS_BUMPENVMAT00, F2DW( bmatr.e00 ) ) );
00487     DX_CHK( m_pDevice-&gt;SetTextureStageState( stage, D3DTSS_BUMPENVMAT10, F2DW( bmatr.e10 ) ) );
00488     DX_CHK( m_pDevice-&gt;SetTextureStageState( stage, D3DTSS_BUMPENVMAT01, F2DW( bmatr.e01 ) ) );
00489     DX_CHK( m_pDevice-&gt;SetTextureStageState( stage, D3DTSS_BUMPENVMAT11, F2DW( bmatr.e11 ) ) );
00490     DX_CHK( m_pDevice-&gt;SetTextureStageState( stage, D3DTSS_BUMPENVLSCALE,  F2DW(bmatr.e22) ) );
00491     DX_CHK( m_pDevice-&gt;SetTextureStageState( stage, D3DTSS_BUMPENVLOFFSET, F2DW(bmatr.e20) ) );
00492     __endT(OtherTime);
00493     m_BumpTM[stage] = bmatr;
00494 } <span class="comment">// RenderSystemDX9::SetBumpTM(</span>
00495 
00496 <span class="keywordtype">void</span> RenderSystemDX9::GetClientSize( <span class="keywordtype">int</span>&amp; width, <span class="keywordtype">int</span>&amp; height ) 
00497 {
00498 
00499 }
00500 
00501 <span class="keywordtype">void</span> RenderSystemDX9::AddClient( IDeviceClient* iNotify ) 
00502 {
00503     m_DeviceClients.push_back( iNotify );
00504 } <span class="comment">// RenderSystemDX9::AddClient </span>
00505 
00506 <span class="keywordtype">void</span> RenderSystemDX9::ClearDevice( DWORD color, <span class="keywordtype">bool</span> bColor, <span class="keywordtype">bool</span> bDepth, <span class="keywordtype">bool</span> bStencil ) 
00507 {
00508     DWORD flags = 0;
00509     <span class="keywordflow">if</span> (bColor) flags |= D3DCLEAR_TARGET;
00510     <span class="keywordflow">if</span> (bDepth) flags |= D3DCLEAR_ZBUFFER;
00511     <span class="keywordflow">if</span> (bStencil) flags |= D3DCLEAR_STENCIL;
00512 
00513     __beginT();
00514     DX_CHK( m_pDevice-&gt;Clear( 0, NULL, flags, color, 1.0, 0 ) );
00515     __endT(OtherTime);
00516 } <span class="comment">// RenderSystemDX9::ClearDevice</span>
00517 
00518 <span class="keywordtype">bool</span> RenderSystemDX9::SetCursor( <span class="keywordtype">int</span> texID, <span class="keyword">const</span> Rct&amp; rctOnTex, <span class="keywordtype">int</span> hotspotX, <span class="keywordtype">int</span> hotspotY ) 
00519 {
00520     <span class="keywordflow">return</span> <span class="keyword">false</span>; 
00521 }
00522 
00523 <span class="keywordtype">bool</span> RenderSystemDX9::UpdateCursor( <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">bool</span> drawNow ) 
00524 { 
00525     assert( m_pDevice );
00526     DWORD flags = drawNow ? D3DCURSOR_IMMEDIATE_UPDATE : 0;
00527     m_pDevice-&gt;SetCursorPosition( x, y, flags );
00528     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00529 } <span class="comment">// RenderSystemDX9::UpdateCursor</span>
00530 
00531 <span class="keywordtype">void</span> RenderSystemDX9::ShowCursor( <span class="keywordtype">bool</span> bShow ) 
00532 {
00533     __beginT();
00534     DX_CHK( m_pDevice-&gt;ShowCursor( bShow ? TRUE : FALSE ) );
00535     __endT(OtherTime);
00536 } <span class="comment">// RenderSystemDX9::ShowCursor</span>
00537 
00538 <span class="keywordtype">bool</span> RenderSystemDX9::StartFrame() 
00539 {
00540     <span class="keywordflow">if</span> (!m_bActive) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00541     HRESULT hr;
00542     <span class="keywordflow">if</span> (m_bDeviceLost)
00543     {
00544         <span class="comment">// Test the cooperative level to see if it's okay to render</span>
00545         <span class="keywordflow">if</span> (FAILED( hr = m_pDevice-&gt;TestCooperativeLevel() ))
00546         {
00547             <span class="comment">// If the device was lost, do not render until we get it back</span>
00548             <span class="keywordflow">if</span> (D3DERR_DEVICELOST == hr) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00549 
00550             <span class="comment">// Check if the device needs to be reset.</span>
00551             <span class="keywordflow">if</span> (D3DERR_DEVICENOTRESET == hr)
00552             {
00553                 <span class="comment">// If we are windowed, read the desktop mode and use the same format for</span>
00554                 <span class="comment">// the back buffer</span>
00555                 <span class="keywordflow">if</span> (m_bWindowed)
00556                 {
00557                     D3DAdapterInfo* pAdapterInfo = m_d3dSettings.PAdapterInfo();
00558                     m_pD3D-&gt;GetAdapterDisplayMode( pAdapterInfo-&gt;m_Ordinal, &amp;m_d3dSettings.Windowed_DisplayMode );
00559                     m_d3dpp.BackBufferFormat = m_d3dSettings.Windowed_DisplayMode.Format;
00560                 }
00561                 <span class="keywordflow">if</span> (FAILED( hr = Reset3DEnvironment() )) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00562             }
00563             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00564         }
00565         m_bDeviceLost = <span class="keyword">false</span>;
00566     }
00567 
00568 
00569     <span class="comment">// Get the app's time, in seconds. Skip rendering if no time elapsed</span>
00570     FLOAT fAppTime        = DXUtil_Timer( TIMER_GETAPPTIME );
00571     FLOAT fElapsedAppTime = DXUtil_Timer( TIMER_GETELAPSEDTIME );
00572     <span class="keywordflow">if</span> ((0.0f == fElapsedAppTime) &amp;&amp; m_bFrameMoving) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00573     m_fTime        = fAppTime;
00574     m_fElapsedTime = fElapsedAppTime;
00575 
00576     m_ViewPort.x = 0.0f;
00577     m_ViewPort.y = 0.0f;
00578     m_ViewPort.w = m_d3dpp.BackBufferWidth;
00579     m_ViewPort.h = m_d3dpp.BackBufferHeight;
00580     
00581     <span class="comment">// DX_CHK( m_pDevice-&gt;BeginScene() );</span>
00582     <span class="comment">//static int s_shID = IRS-&gt;GetShaderID( "lines.fx" );</span>
00583     <span class="comment">//SetShader( s_shID );</span>
00584 
00585     SetTextureFactor( 0xFFFFFFFF );
00586     SetTextureFactor( 0x00FFFFFF );
00587     SetTextureFactor( 0xFFFFFFFF );
00588 
00589     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00590 } <span class="comment">// RenderSystemDX9::StartFrame</span>
00591 
00592 <span class="keywordtype">bool</span> g_bKangaroo = <span class="keyword">false</span>;
00593 <span class="keywordtype">void</span> RenderSystemDX9::EndFrame() 
00594 {
00595     <span class="keywordtype">void</span> RenderUI();
00596     SetShader( -1 );
00597 
00598     <span class="keywordflow">if</span> (g_bKangaroo) RenderUI();
00599 
00600     m_CurrentFrame++;
00601     Flush();
00602 
00603     SetShader( -1 );
00604 
00605     <span class="keyword">static</span> Timer s_FPSTimer;
00606     <span class="keyword">static</span> <span class="keywordtype">float</span> s_Time = s_FPSTimer.seconds();
00607     <span class="keywordtype">float</span> dt = s_FPSTimer.seconds() - s_Time;
00608     m_FPS = 1.0f/dt;
00609     s_Time = s_FPSTimer.seconds();
00610 
00611     <span class="comment">//DX_CHK( m_pDevice-&gt;EndScene() );</span>
00612     <span class="comment">// Show the frame on the primary surface.</span>
00613     HRESULT hr = m_pDevice-&gt;Present( NULL, NULL, NULL, NULL );
00614     <span class="keywordflow">if</span> (D3DERR_DEVICELOST == hr) m_bDeviceLost = <span class="keyword">true</span>;
00615 } <span class="comment">// RenderSystemDX9::EndFrame</span>
00616 
00617 <span class="keywordtype">bool</span> RenderSystemDX9::ReloadShaders() 
00618 { 
00619     <span class="keywordtype">int</span> nS = m_Shaders.size();
00620     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nS; i++)
00621     {
00622         m_Shaders[i]-&gt;Reload();
00623     }
00624     <span class="keywordflow">return</span> <span class="keyword">true</span>; 
00625 } <span class="comment">// RenderSystemDX9::ReloadShaders</span>
00626 
00627 <span class="keywordtype">bool</span> RenderSystemDX9::ReloadTextures() 
00628 { 
00629     <span class="keywordtype">int</span> nT = m_Textures.size();
00630     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nT; i++)
00631     {
00632         m_Textures[i]-&gt;Reload();
00633     }
00634     <span class="keywordflow">return</span> <span class="keyword">true</span>; 
00635 } <span class="comment">// RenderSystemDX9::ReloadTextures</span>
00636 
00637 <span class="keywordtype">int</span> RenderSystemDX9::CreateTexture( <span class="keyword">const</span> <span class="keywordtype">char</span>* texName, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, 
00638                                     ColorFormat clrFormat, <span class="keywordtype">int</span> nMips, TextureMemoryPool memPool, 
00639                                     <span class="keywordtype">bool</span> bRenderTarget, DepthStencilFormat dsFormat,
00640                                     <span class="keywordtype">bool</span> bDynamic )
00641 {
00642     <span class="keywordtype">int</span> nTex = m_Textures.size();
00643     TextureDX9* pTex = NULL;
00644     <span class="keywordtype">bool</span> bFound = <span class="keyword">false</span>;
00645     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nTex; i++)
00646     {
00647         pTex = m_Textures[i];
00648         <span class="keywordflow">if</span> (!strcmp( pTex-&gt;GetName(), texName ))
00649         {
00650             pTex-&gt;DeleteDeviceObjects();
00651             bFound = <span class="keyword">true</span>;
00652             <span class="keywordflow">break</span>;
00653         }
00654     }
00655     <span class="keywordflow">if</span> (!bFound) 
00656     {
00657         pTex = <span class="keyword">new</span> TextureDX9( m_pDevice );
00658         pTex-&gt;SetID( m_Textures.size() );
00659         m_Textures.push_back( pTex );
00660         pTex-&gt;SetName( texName );
00661     }
00662     pTex-&gt;Create( width, height, clrFormat, nMips, memPool, bRenderTarget, dsFormat, bDynamic );
00663     <span class="keywordflow">return</span> pTex-&gt;GetID(); 
00664 } <span class="comment">// RenderSystemDX9::CreateTexture</span>
00665 
00666 <span class="keywordtype">void</span> RenderSystemDX9::SetTexture( <span class="keywordtype">int</span> texID, <span class="keywordtype">int</span> stage, <span class="keywordtype">bool</span> bCache ) 
00667 {
00668     <span class="keywordflow">if</span> (texID &lt; 0 || texID &gt;= m_Textures.size() <span class="comment">/*|| texID == m_CurTex[stage]*/</span>) <span class="keywordflow">return</span>;
00669     m_CurTex[stage] = texID;
00670     <span class="comment">//  FIXME:</span>
00671     <span class="comment">/*if (!bCache) */</span>m_Textures[texID]-&gt;Bind( stage );
00672 } <span class="comment">// RenderSystemDX9::SetTexture</span>
00673 
00674 IDirect3DSurface9* RenderSystemDX9::GetSurface( <span class="keywordtype">int</span> texID )
00675 {
00676      <span class="keywordflow">if</span> (texID &lt; 0 || texID &gt;= m_Textures.size()) <span class="keywordflow">return</span> NULL;
00677      <span class="keywordflow">return</span> m_Textures[texID]-&gt;GetSurface( 0 );
00678 } <span class="comment">// RenderSystemDX9::GetSurface</span>
00679 
00680 <span class="keywordtype">int</span> RenderSystemDX9::GetTexture( <span class="keywordtype">int</span> stage ) 
00681 { 
00682     <span class="keywordflow">if</span> (stage &lt; 0 || stage &gt;= c_MaxTextureStages) <span class="keywordflow">return</span> -1;
00683     <span class="keywordflow">return</span> m_CurTex[stage]; 
00684 } <span class="comment">// RenderSystemDX9::GetTexture</span>
00685 
00686 <span class="keywordtype">bool</span> RenderSystemDX9::SaveTexture( <span class="keywordtype">int</span> texID, <span class="keyword">const</span> <span class="keywordtype">char</span>* fname ) 
00687 {
00688     <span class="keywordflow">if</span> (texID &lt; 0 || texID &gt;= m_Textures.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00689     <span class="keywordflow">return</span> m_Textures[texID]-&gt;SaveToFile( fname );
00690 } <span class="comment">// RenderSystemDX9::SaveTexture</span>
00691 
00692 <span class="keywordtype">void</span> RenderSystemDX9::CopyTexture( <span class="keywordtype">int</span> destID, <span class="keywordtype">int</span> srcID, <span class="keyword">const</span> Rct* rct, <span class="keywordtype">int</span> nRect ) 
00693 { 
00694     <span class="keywordflow">if</span> (destID &lt; 0 || destID &gt;= m_Textures.size()) <span class="keywordflow">return</span>;
00695     <span class="keywordflow">if</span> (srcID &lt; 0 || srcID &gt;= m_Textures.size()) <span class="keywordflow">return</span>;
00696 
00697     Rct rect;
00698     <span class="keywordflow">if</span> (!rct)
00699     {
00700         rect.x = 0;
00701         rect.y = 0;
00702         rect.w = m_Textures[srcID]-&gt;GetWidth();
00703         rect.h = m_Textures[srcID]-&gt;GetHeight();
00704         nRect  = 1;
00705         rct    = &amp;rect;
00706     }
00707 
00708     IDirect3DTexture9* pSrc = m_Textures[srcID]-&gt;GetTexture2D();
00709     IDirect3DTexture9* pDst = m_Textures[destID]-&gt;GetTexture2D();
00710     <span class="keywordflow">if</span> (!pSrc || !pDst) <span class="keywordflow">return</span>;
00711 
00712     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nRect; i++)
00713     {
00714         RECT wrct;
00715         wrct.left    = rct[i].x;
00716         wrct.top     = rct[i].y;
00717         wrct.right   = rct[i].GetRight();
00718         wrct.bottom  = rct[i].GetBottom();
00719         pDst-&gt;AddDirtyRect( &amp;wrct );
00720     }
00721 
00722     __beginT();
00723     DX_CHK( m_pDevice-&gt;UpdateTexture( pSrc, pDst ) );
00724     __endT(OtherTime);
00725 } <span class="comment">//RenderSystemDX9::CopyTexture</span>
00726 
00727 <span class="keywordtype">void</span> RenderSystemDX9::CreateMipLevels( <span class="keywordtype">int</span> texID ) 
00728 {
00729     <span class="keywordflow">if</span> (texID &lt;= 0 || texID &gt;= m_Textures.size()) <span class="keywordflow">return</span>;
00730     TextureDX9&amp; tex = *(m_Textures[texID]);
00731     DX_CHK( D3DXFilterTexture( tex.GetTexture2D(), NULL, 
00732                                 0, 
00733                                 D3DX_FILTER_TRIANGLE | 
00734                                 D3DX_FILTER_DITHER   | 
00735                                 D3DX_FILTER_MIRROR_U |
00736                                 D3DX_FILTER_MIRROR_V ) );
00737 
00738 } <span class="comment">// RenderSystemDX9::CreateMipLevels</span>
00739 
00740 <span class="keywordtype">int</span> RenderSystemDX9::CreateNormalMap( <span class="keywordtype">int</span> texID, <span class="keywordtype">float</span> amplitude ) 
00741 { 
00742     <span class="keywordflow">if</span> (texID &lt;= 0 || texID &gt;= m_Textures.size()) <span class="keywordflow">return</span> -1;
00743     <span class="keywordtype">char</span> name[256];
00744     TextureDX9&amp; tex = *(m_Textures[texID]);
00745     sprintf( name, <span class="stringliteral">"%s_normalmap"</span>, tex.GetName() );
00746     <span class="keywordtype">int</span> dstID = CreateTexture( name, tex.GetWidth(), tex.GetHeight(), cfARGB8888, 1, tmpDefault );
00747     <span class="keywordflow">if</span> (dstID == -1) <span class="keywordflow">return</span> -1;
00748     
00749     <span class="comment">//int src_pitch;</span>
00750     <span class="comment">//BYTE* src = IRS-&gt;LockTexBits(texID,src_pitch);</span>
00751     <span class="comment">//int dst_pitch;</span>
00752     <span class="comment">//BYTE* dst = IRS-&gt;LockTexBits(dstID,dst_pitch);</span>
00753 
00754     TextureDX9&amp; dtex = *(m_Textures[dstID]);
00755     
00756     IDirect3DTexture9* pSrc  = tex.GetTexture2D();
00757     IDirect3DTexture9* pDest = dtex.GetTexture2D();
00758     <span class="keywordflow">if</span> (!pSrc || !pDest) <span class="keywordflow">return</span> -1;
00759 
00760     DX_CHK( D3DXComputeNormalMap( pDest, pSrc, NULL, 0, D3DX_CHANNEL_RED, amplitude ) );
00761     SaveTexture(dstID,<span class="stringliteral">"temp.dds"</span>);
00762     <span class="keywordflow">return</span> dstID; 
00763 } <span class="comment">// RenderSystemDX9::CreateNormalMap</span>
00764 
00765 <span class="keywordtype">int</span> RenderSystemDX9::GetTextureID( <span class="keyword">const</span> <span class="keywordtype">char</span>* texName ) 
00766 { 
00767     <span class="keywordflow">if</span> (!texName || texName[0] == 0) <span class="keywordflow">return</span> -1;
00768     <span class="keywordtype">int</span> nTex = m_Textures.size();
00769     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nTex; i++)
00770     {
00771         <span class="keyword">const</span> ITexture* pTex = m_Textures[i];
00772         <span class="keywordflow">if</span> (!stricmp( pTex-&gt;GetName(), texName )) <span class="keywordflow">return</span> i;
00773     }
00774     <span class="comment">//  load texture </span>
00775     TextureDX9* pTex = <span class="keyword">new</span> TextureDX9( m_pDevice );
00776     pTex-&gt;SetID( m_Textures.size() );
00777     pTex-&gt;SetName( texName );
00778     FilePath path; path.GetCWD();
00779     pTex-&gt;SetSearchPath( path.GetFullPath() );
00780     pTex-&gt;LoadHeader();
00781     
00782     m_Textures.push_back( pTex );
00783     path.SetCWD();
00784     <span class="keywordflow">return</span> pTex-&gt;GetID(); 
00785 } <span class="comment">// RenderSystemDX9::GetTextureID</span>
00786 
00787 <span class="keywordtype">bool</span> RenderSystemDX9::DeleteTexture( <span class="keywordtype">int</span> texID ) 
00788 { 
00789     <span class="keywordflow">if</span> (texID &lt; 0 || texID &gt;= m_Textures.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00790     m_Textures[texID]-&gt;DeleteDeviceObjects();
00791     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00792 } <span class="comment">// RenderSystemDX9::DeleteTexture</span>
00793 
00794 <span class="keyword">const</span> <span class="keywordtype">char</span>* RenderSystemDX9::GetTextureName( <span class="keywordtype">int</span> texID )
00795 { 
00796     <span class="keywordflow">if</span> (texID &lt; 0 || texID &gt;= m_Textures.size()) <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00797     <span class="keywordflow">return</span> m_Textures[texID]-&gt;GetName();
00798 } <span class="comment">// RenderSystemDX9::GetTextureName</span>
00799 
00800 <span class="keyword">const</span> <span class="keywordtype">char</span>* RenderSystemDX9::GetTexturePath( <span class="keywordtype">int</span> texID )<span class="keyword"> const</span>
00801 <span class="keyword"></span>{
00802     <span class="keywordflow">if</span> (texID &lt; 0 || texID &gt;= m_Textures.size()) <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00803     <span class="keywordflow">return</span> m_Textures[texID]-&gt;GetSearchPath();
00804 } <span class="comment">// RenderSystemDX9::GetTexturePath</span>
00805 
00806 BYTE* RenderSystemDX9::LockTexBits( <span class="keywordtype">int</span> texID, <span class="keywordtype">int</span>&amp; pitch, <span class="keywordtype">int</span> level ) 
00807 { 
00808     <span class="keywordflow">if</span> (texID &lt; 0 || texID &gt;= m_Textures.size()) <span class="keywordflow">return</span> NULL;
00809     <span class="keywordflow">return</span> m_Textures[texID]-&gt;LockBits( pitch, level );
00810 } <span class="comment">// RenderSystemDX9::LockTexBits</span>
00811 
00812 BYTE* RenderSystemDX9::LockTexBits( <span class="keywordtype">int</span> texID, <span class="keyword">const</span> Rct&amp; rect, <span class="keywordtype">int</span>&amp; pitch, <span class="keywordtype">int</span> level ) 
00813 { 
00814     <span class="keywordflow">if</span> (texID &lt; 0 || texID &gt;= m_Textures.size()) <span class="keywordflow">return</span> NULL;
00815     <span class="keywordflow">return</span> m_Textures[texID]-&gt;LockBits( pitch, rect, level );
00816 } <span class="comment">// RenderSystemDX9::LockTexBits</span>
00817 
00818 <span class="keywordtype">void</span> RenderSystemDX9::UnlockTexBits( <span class="keywordtype">int</span> texID, <span class="keywordtype">int</span> level ) 
00819 {
00820     <span class="keywordflow">if</span> (texID &lt; 0 || texID &gt;= m_Textures.size()) <span class="keywordflow">return</span>;
00821     m_Textures[texID]-&gt;UnlockBits( level );
00822 } <span class="comment">// RenderSystemDX9::UnlockTexBits</span>
00823 
00824 <span class="keywordtype">int</span> RenderSystemDX9::GetShaderID( <span class="keyword">const</span> <span class="keywordtype">char</span>* shaderName ) 
00825 { 
00826     <span class="keywordflow">if</span> (!m_bInited) <span class="keywordflow">return</span> -1;
00827     <span class="keywordtype">int</span> lqShaderID = -1;
00828     _chdir(IRM-&gt;GetHomeDirectory());
00829     <span class="keywordflow">if</span>(!strstr(shaderName,<span class="stringliteral">"low\\"</span>)){
00830         <span class="keywordtype">char</span> sh[MAX_PATH];
00831         sprintf(sh,<span class="stringliteral">"Shaders\\low\\%s.fx"</span>,shaderName);        
00832         <span class="keywordflow">if</span>(FileExists(sh)){
00833             sprintf(sh,<span class="stringliteral">"low\\%s"</span>,shaderName);
00834             lqShaderID = GetShaderID(sh);
00835         }
00836     }
00837     <span class="keywordtype">int</span> nSha = m_Shaders.size();
00838     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nSha; i++)
00839     {
00840         <span class="keyword">const</span> IShader* pSha = m_Shaders[i];
00841         <span class="keywordflow">if</span> (!stricmp( pSha-&gt;GetName(), shaderName )) <span class="keywordflow">return</span> i;
00842     }
00843     <span class="keywordtype">char</span> fname[MAX_PATH];
00844     sprintf(fname,<span class="stringliteral">"Shaders\\%s"</span>,shaderName);
00845     <span class="keywordflow">if</span>(!strstr(fname,<span class="stringliteral">".fx"</span>))strcat(fname,<span class="stringliteral">".fx"</span>);
00846     ShaderFX* pSha = NULL;        
00847     pSha = <span class="keyword">new</span> ShaderFX( m_pDevice );    
00848     <span class="keywordflow">if</span> (!pSha-&gt;Load( fname ))
00849     {
00850         <span class="keywordflow">if</span>(strstr(shaderName,<span class="stringliteral">"low\\"</span>)){
00851             {
00852                 Log.Error( <span class="stringliteral">"Could not load shader: %s"</span>, shaderName+4 );
00853             }            
00854         }
00855         <span class="keyword">delete</span>(pSha);
00856         <span class="keywordflow">return</span> lqShaderID;
00857     }
00858     pSha-&gt;SetName( shaderName );
00859     pSha-&gt;SetID( nSha );
00860     m_Shaders.push_back( pSha );
00861     m_LowShaderID.push_back( lqShaderID );
00862     <span class="keywordflow">return</span> nSha; 
00863 } <span class="comment">// RenderSystemDX9::GetShaderID</span>
00864 
00865 <span class="keywordtype">int</span> RenderSystemDX9::GetNShaderVars( <span class="keywordtype">int</span> shID )<span class="keyword"> const</span>
00866 <span class="keyword"></span>{
00867     <span class="keywordflow">if</span> (shID &lt; 0 || shID &gt;= m_Shaders.size() || m_Shaders[shID] == NULL) <span class="keywordflow">return</span> 0;
00868     <span class="keywordflow">return</span> m_Shaders[shID]-&gt;GetNShaderVars();
00869 } <span class="comment">// RenderSystemDX9::GetNShaderVars</span>
00870 
00871 <span class="keywordtype">int</span> RenderSystemDX9::GetNShaderPasses( <span class="keywordtype">int</span> shID )<span class="keyword"> const</span>
00872 <span class="keyword"></span>{
00873     <span class="keywordflow">if</span> (shID &lt; 0 || shID &gt;= m_Shaders.size() || m_Shaders[shID] == NULL) <span class="keywordflow">return</span> 0;
00874     <span class="keywordflow">return</span> m_Shaders[shID]-&gt;GetNPasses();
00875 } <span class="comment">// RenderSystemDX9::GetNShaderPasses     </span>
00876 
00877 <span class="keywordtype">bool</span> RenderSystemDX9::SetShaderTech( <span class="keywordtype">int</span> shID, <span class="keywordtype">int</span> techID )
00878 {
00879     <span class="keywordflow">if</span> (shID &lt; 0 || shID &gt;= m_Shaders.size() || m_Shaders[shID] == NULL) <span class="keywordflow">return</span> 0;
00880     <span class="keywordflow">return</span> m_Shaders[shID]-&gt;SetActiveTech( techID );
00881 } <span class="comment">// RenderSystemDX9::SetShaderTech</span>
00882 
00883 IShader* RenderSystemDX9::GetShader( <span class="keywordtype">int</span> shID )<span class="keyword"> const </span>
00884 <span class="keyword"></span>{ 
00885     <span class="keywordflow">if</span> (shID &lt; 0 || shID &gt;= m_Shaders.size()) <span class="keywordflow">return</span> NULL;
00886     <span class="keywordflow">return</span> m_Shaders[shID]; 
00887 } <span class="comment">// RenderSystemDX9::GetShaderName</span>
00888 
00889 
00890 <span class="keyword">const</span> <span class="keywordtype">char</span>* RenderSystemDX9::GetShaderName( <span class="keywordtype">int</span> shID )<span class="keyword"> const </span>
00891 <span class="keyword"></span>{ 
00892     <span class="keywordflow">if</span> (shID &lt; 0 || shID &gt;= m_Shaders.size() || m_Shaders[shID] == NULL) <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00893     <span class="keywordflow">return</span> m_Shaders[shID]-&gt;GetName(); 
00894 } <span class="comment">// RenderSystemDX9::GetShaderName</span>
00895 
00896 <span class="keywordtype">bool</span> RenderSystemDX9::SetClipPlane( DWORD idx, <span class="keyword">const</span> Plane&amp; plane ) 
00897 { 
00898     HRESULT hres = m_pDevice-&gt;SetClipPlane( idx, (<span class="keywordtype">float</span>*)&amp;plane );
00899     <span class="keywordflow">if</span> (hres != S_OK)
00900     {
00901         Log.Error( <span class="stringliteral">"Could not set user clipping plane %d"</span>, idx );
00902         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00903     }
00904     <span class="keywordflow">return</span> <span class="keyword">true</span>; 
00905 } <span class="comment">// RenderSystemDX9::SetClipPlane</span>
00906 <span class="keywordtype">int</span> SetRenderTargetTime=0;
00907 <span class="keywordtype">bool</span> RenderSystemDX9::PushRenderTarget( <span class="keywordtype">int</span> texID, <span class="keywordtype">int</span> dsID ) 
00908 { 
00909     <span class="keywordflow">if</span> (texID &gt;= m_Textures.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00910 
00911     IDirect3DSurface9* pPrevColor = NULL;
00912     IDirect3DSurface9* pNewColor  = NULL;
00913     IDirect3DSurface9* pPrevDS    = NULL;
00914     IDirect3DSurface9* pNewDS     = NULL;
00915 
00916     <span class="keywordflow">if</span> (m_RTStack.size() &gt; 0)
00917     {
00918         <span class="keyword">const</span> RenderTargetPair&amp; rt = m_RTStack.top();
00919         <span class="keywordflow">if</span> (rt.m_Color &gt;= 0) 
00920         {
00921             pPrevColor = m_Textures[rt.m_Color]-&gt;GetSurface(); 
00922         } <span class="keywordflow">else</span> pPrevColor = NULL; 
00923         <span class="keywordflow">if</span> (rt.m_DepthStencil &gt;= 0)  
00924         {
00925             pPrevDS = m_Textures[rt.m_DepthStencil]-&gt;GetSurface(); 
00926         } <span class="keywordflow">else</span> pPrevDS = NULL;  
00927     }
00928     <span class="keywordflow">else</span>
00929     {
00930         pPrevColor = m_pBackBufferSurface;
00931         pPrevDS    = m_pDepthStencilSurface;
00932     }
00933 
00934     <span class="keywordflow">if</span> (texID &gt;= 0) pNewColor = m_Textures[texID]-&gt;GetSurface(); <span class="keywordflow">else</span> pNewColor = NULL;
00935     <span class="keywordflow">if</span> (dsID &gt; 0) pNewDS = m_Textures[dsID]-&gt;GetSurface(); <span class="keywordflow">else</span> pNewDS = NULL;
00936 
00937     <span class="keywordflow">if</span> (dsID == 0) pNewDS = m_pDepthStencilSurface;
00938 
00939     m_RTStack.push( RenderTargetPair( texID, dsID ) );
00940     
00941     HRESULT hRes = S_OK;
00942     <span class="keywordflow">if</span> (pPrevColor != pNewColor)
00943     {
00944         __beginT();
00945         hRes &amp;= m_pDevice-&gt;SetRenderTarget( 0, pNewColor );
00946         __endT(SetRenderTargetTime);
00947     }
00948     
00949     <span class="keywordflow">if</span> (pPrevColor != m_pBackBufferSurface) 
00950     {
00951         SAFE_DECREF( pPrevColor );
00952         SAFE_DECREF( pPrevColor );
00953     }
00954     
00955     <span class="keywordflow">if</span> (pPrevDS != pNewDS)
00956     {
00957         hRes &amp;= m_pDevice-&gt;SetDepthStencilSurface( pNewDS );
00958     }
00959 
00960     <span class="keywordflow">if</span> (pPrevDS != m_pDepthStencilSurface) 
00961     {
00962         SAFE_DECREF( pPrevDS );
00963         SAFE_DECREF( pPrevDS );
00964     }
00965 
00966     <span class="keywordflow">return</span> (hRes == S_OK);
00967 } <span class="comment">// RenderSystemDX9::PushRenderTarget</span>
00968 
00969 <span class="keywordtype">bool</span> RenderSystemDX9::PopRenderTarget() 
00970 {
00971     <span class="keywordflow">if</span> (m_RTStack.size() == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00972 
00973     IDirect3DSurface9* pPrevColor   = NULL;
00974     IDirect3DSurface9* pNewColor    = NULL;
00975     IDirect3DSurface9* pPrevDS      = NULL;
00976     IDirect3DSurface9* pNewDS       = NULL;
00977 
00978     <span class="keyword">const</span> RenderTargetPair&amp; rt = m_RTStack.top();
00979     <span class="keywordflow">if</span> (rt.m_Color &gt;= 0) pPrevColor = m_Textures[rt.m_Color]-&gt;GetSurface();  
00980     <span class="keywordflow">if</span> (rt.m_DepthStencil &gt;= 0) pPrevDS = m_Textures[rt.m_DepthStencil]-&gt;GetSurface();  
00981     m_RTStack.pop();
00982     
00983     <span class="keywordflow">if</span> (m_RTStack.size() &gt; 0)
00984     {
00985         <span class="keyword">const</span> RenderTargetPair&amp; nrt = m_RTStack.top();
00986         <span class="keywordflow">if</span> (nrt.m_Color &gt;= 0) pNewColor = m_Textures[nrt.m_Color]-&gt;GetSurface(); 
00987         <span class="keywordflow">if</span> (nrt.m_DepthStencil &gt;= 0) pNewDS = m_Textures[nrt.m_DepthStencil]-&gt;GetSurface(); 
00988     }
00989     <span class="keywordflow">else</span>
00990     {
00991         pNewColor = m_pBackBufferSurface;
00992         pNewDS    = m_pDepthStencilSurface;    
00993     }
00994 
00995     HRESULT hRes = S_OK;
00996     <span class="keywordflow">if</span> (pPrevColor != pNewColor)
00997     {
00998         __beginT();
00999         hRes &amp;= m_pDevice-&gt;SetRenderTarget( 0, pNewColor );
01000         __endT(SetRenderTargetTime);
01001     }
01002 
01003     <span class="keywordflow">if</span> (pPrevColor != m_pBackBufferSurface) 
01004     {
01005         SAFE_DECREF( pPrevColor );
01006         SAFE_DECREF( pPrevColor );
01007     }
01008 
01009     <span class="keywordflow">if</span> (pPrevDS != pNewDS)
01010     {
01011         hRes &amp;= m_pDevice-&gt;SetDepthStencilSurface( pNewDS );
01012     }
01013 
01014     <span class="keywordflow">if</span> (pPrevDS != m_pDepthStencilSurface) 
01015     {
01016         <span class="comment">//SAFE_DECREF( pPrevDS );</span>
01017         <span class="comment">//SAFE_DECREF( pPrevDS );</span>
01018     }
01019 
01020     <span class="keywordflow">return</span> (hRes == S_OK);
01021 } <span class="comment">// RenderSystemDX9::PopRenderTarget</span>
01022 <span class="keywordtype">int</span> TimeInSVP=0;
01023 <span class="keywordtype">void</span> RenderSystemDX9::SetViewPort( <span class="keyword">const</span> Rct&amp; vp, <span class="keywordtype">float</span> zn, <span class="keywordtype">float</span> zf, <span class="keywordtype">bool</span> bClip ) 
01024 { 
01025     m_ViewPort      = vp; 
01026     m_ViewPortZNear = zn;
01027     m_ViewPortZFar  = zf;
01028 
01029     <span class="keywordflow">if</span> (bClip)
01030     {
01031         Rct svp( 0, 0, GetBackBufferW(), GetBackBufferH() );
01032         svp.Clip( m_ViewPort );
01033     }
01034 
01035     D3DVIEWPORT9 dvp;
01036     dvp.X       = m_ViewPort.x;
01037     dvp.Y       = m_ViewPort.y;
01038     dvp.Width   = m_ViewPort.w;
01039     dvp.Height  = m_ViewPort.h;
01040     dvp.MinZ    = m_ViewPortZNear;
01041     dvp.MaxZ    = m_ViewPortZFar;
01042 
01043     __beginT();
01044 
01045     DX_CHK( m_pDevice-&gt;SetViewport( (D3DVIEWPORT9*)&amp;dvp ) );    
01046 
01047     __endT(TimeInSVP);
01048 
01049 } <span class="comment">// RenderSystemDX9::SetViewPort</span>
01050 
01051 <span class="keywordtype">void</span> RenderSystemDX9::SetShaderAutoVars()
01052 {
01053     <span class="keywordflow">if</span> (m_CurShader == -1) <span class="keywordflow">return</span>;
01054     m_Shaders[m_CurShader]-&gt;SetAutoVars();
01055 } <span class="comment">// RenderSystemDX9::SetShaderAutoVars</span>
01056 <span class="keywordtype">int</span> BEffTime=0;
01057 <span class="keywordtype">void</span> RenderSystemDX9::SetShader( <span class="keywordtype">int</span> shaderID, <span class="keywordtype">int</span> passID ) 
01058 {
01059     <span class="keywordflow">if</span>(m_ShadersQuality &amp;&amp; shaderID&gt;0)
01060     {
01061         <span class="keywordtype">int</span> shL = m_LowShaderID[shaderID];
01062         <span class="keywordflow">if</span>(shL&gt;0)shaderID = shL;
01063     }
01064     <span class="keywordflow">if</span> (m_CurPass == passID &amp;&amp; m_CurShader == shaderID) <span class="keywordflow">return</span>;
01065     <span class="keywordflow">if</span> (m_CurShader &gt;= 0) 
01066     {
01067         m_Shaders[m_CurShader]-&gt;EndPass();
01068         <span class="keywordflow">if</span> (shaderID != m_CurShader)
01069         {
01070             m_Shaders[m_CurShader]-&gt;End();
01071         }
01072     }
01073     <span class="keywordflow">if</span> (shaderID &lt; 0 || shaderID &gt;= m_Shaders.size())
01074     {
01075         m_CurShader = -1;
01076         <span class="keywordflow">return</span>;
01077     }
01078     m_CurShader = shaderID;
01079     <span class="keywordflow">if</span> (m_CurShader &gt;= 0) 
01080     {
01081         __beginT();
01082         m_Shaders[m_CurShader]-&gt;Begin();
01083         m_Shaders[m_CurShader]-&gt;BeginPass( passID );
01084         ApplyFogStateBlock();
01085         __endT(BEffTime);
01086     }
01087     m_CurPass = passID;
01088 } <span class="comment">// RenderSystemDX9::SetShader</span>
01089 <span class="keywordtype">void</span> RenderSystemDX9::SetShadersQuality( <span class="keywordtype">int</span> Level ){
01090     m_ShadersQuality = Level;
01091 }
01092 <span class="keywordtype">int</span> RenderSystemDX9::GetShadersQuality(){
01093     <span class="keywordflow">return</span> m_ShadersQuality;
01094 }
01095 <span class="keywordtype">bool</span> RenderSystemDX9::IsShaderValid( <span class="keywordtype">int</span> shID, <span class="keywordtype">int</span> techID )
01096 { 
01097     assert( <span class="keyword">false</span> );
01098     <span class="keywordflow">return</span> <span class="keyword">false</span>; 
01099 } <span class="comment">// RenderSystemDX9::IsShaderValid</span>
01100 
01101 RenderTask&amp; RenderSystemDX9::AddTask() 
01102 { 
01103     <span class="keywordflow">if</span> (m_NTasks == c_MaxRenderTasks) Flush();
01104     RenderTask&amp; task = m_Tasks[m_NTasks];
01105     m_NTasks++;
01106     task.m_TFactor = m_TFactor;
01107     <span class="keywordflow">return</span> task; 
01108 }  <span class="comment">// RenderSystemDX9::AddTask</span>
01109 <span class="keywordtype">int</span> SetTextureFactorTime=0;
01110 <span class="keywordtype">void</span> RenderSystemDX9::SetTextureFactor( DWORD tfactor )
01111 {
01112     <span class="comment">//if (m_TFactor == tfactor) return;</span>
01113     __beginT();
01114     DX_CHK( m_pDevice-&gt;SetRenderState( D3DRS_TEXTUREFACTOR, tfactor ) );    
01115     __endT(SetTextureFactorTime);
01116     m_TFactor = tfactor;
01117 } <span class="comment">// RenderSystemDX9::SetTextureFactor</span>
01118 
01119 <span class="keywordtype">void</span> RenderSystemDX9::SetZEnable( <span class="keywordtype">bool</span> bEnable )
01120 {
01121     __beginT();
01122     DX_CHK( m_pDevice-&gt;SetRenderState( D3DRS_ZENABLE, bEnable ? TRUE : FALSE ) );   
01123     __endT(OtherTime);
01124 }
01125 
01126 <span class="keywordtype">void</span> RenderSystemDX9::SetZWriteEnable( <span class="keywordtype">bool</span> bEnable )
01127 {
01128     __beginT();
01129     DX_CHK( m_pDevice-&gt;SetRenderState( D3DRS_ZWRITEENABLE, bEnable ? TRUE : FALSE ) );  
01130     __endT(OtherTime);
01131 }
01132 
01133 <span class="keywordtype">void</span> RenderSystemDX9::SetDitherEnable( <span class="keywordtype">bool</span> bEnable )
01134 {
01135     __beginT();
01136     DX_CHK( m_pDevice-&gt;SetRenderState( D3DRS_DITHERENABLE, bEnable ? TRUE : FALSE ) );
01137     __endT(OtherTime);
01138 }
01139 
01140 <span class="keywordtype">void</span> RenderSystemDX9::SetTexFilterEnable( <span class="keywordtype">bool</span> bEnable ) 
01141 {
01142     __beginT();
01143     <span class="keywordflow">if</span> (bEnable)
01144     {
01145         DX_CHK( m_pDevice-&gt;SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR  ) );  
01146         DX_CHK( m_pDevice-&gt;SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR  ) );  
01147     }
01148     <span class="keywordflow">else</span>
01149     {
01150         DX_CHK( m_pDevice-&gt;SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_POINT  ) );  
01151         DX_CHK( m_pDevice-&gt;SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_POINT  ) );  
01152     }
01153     __endT(OtherTime);
01154 } <span class="comment">// RenderSystemDX9::SetTexFilterEnable     </span>
01155 <span class="keywordtype">void</span> RenderSystemDX9::SetColorConst   ( DWORD Color )
01156 {
01157     m_ColorConst=Color;
01158 }
01159 DWORD RenderSystemDX9::GetColorConst()
01160 {
01161     <span class="keywordflow">return</span> m_ColorConst;
01162 }
01163 <span class="keywordtype">void</span> RenderSystemDX9::SetWireframe( <span class="keywordtype">bool</span> bEnable )
01164 {
01165     __beginT();
01166     DX_CHK( m_pDevice-&gt;SetRenderState( D3DRS_FILLMODE, bEnable ? D3DFILL_WIREFRAME : D3DFILL_SOLID ) ); 
01167     __endT(OtherTime);
01168 }
01169 
01170 <span class="keywordtype">void</span>  RenderSystemDX9::SetAlphaRef( BYTE alphaRef )
01171 {
01172     __beginT();
01173     DX_CHK( m_pDevice-&gt;SetRenderState( D3DRS_ALPHAREF, alphaRef ) );    
01174     __endT(OtherTime);
01175 }
01176 
01177 <span class="keywordtype">void</span> RenderSystemDX9::Dump( <span class="keyword">const</span> <span class="keywordtype">char</span>* fname )
01178 {
01179 }
01180 
01181 <span class="keywordtype">bool</span> RenderSystemDX9::ApplyStateBlock( DWORD id ) 
01182 { 
01183     <span class="keywordflow">return</span> <span class="keyword">false</span>; 
01184 }
01185 
01186 <span class="keywordtype">bool</span> RenderSystemDX9::DeleteStateBlock( DWORD id ) 
01187 { 
01188     <span class="keywordflow">return</span> <span class="keyword">false</span>; 
01189 }
01190 
01191 <span class="keywordtype">int</span> RenderSystemDX9::GetTexMemorySize()<span class="keyword"> const </span>
01192 <span class="keyword"></span>{
01193     <span class="keywordflow">if</span> (!m_pDevice) <span class="keywordflow">return</span> 0;
01194     <span class="keywordflow">return</span> m_pDevice-&gt;GetAvailableTextureMem();
01195 } <span class="comment">// RenderSystemDX9::GetTexMemorySize</span>
01196 
01197 <span class="keywordtype">int</span> RenderSystemDX9::GetNDisplayModes() 
01198 { 
01199     <span class="keywordflow">if</span> (m_BestDisplayModes.size() == 0)
01200     {
01201         D3DAdapterInfo* pAd = m_d3dSettings.PAdapterInfo();
01202         <span class="keywordflow">if</span> (!pAd) <span class="keywordflow">return</span> 0;
01203         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; pAd-&gt;m_DisplayModes.size(); i++)
01204         {
01205             D3DDISPLAYMODE&amp; dmode = pAd-&gt;m_DisplayModes[i];
01206             <span class="keywordtype">int</span> nB = m_BestDisplayModes.size();
01207             <span class="keywordtype">bool</span> bPresent = <span class="keyword">false</span>;
01208             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nB; j++)
01209             {
01210                 D3DDISPLAYMODE&amp; m = m_BestDisplayModes[j];
01211                 <span class="keywordflow">if</span> (m.Width == dmode.Width &amp;&amp; 
01212                     m.Height == dmode.Height &amp;&amp;
01213                     m.RefreshRate &lt; dmode.RefreshRate)
01214                 {
01215                     m = dmode;
01216                     bPresent = <span class="keyword">true</span>;
01217                 }
01218             }
01219             <span class="keywordflow">if</span> (!bPresent) m_BestDisplayModes.push_back( dmode );
01220         }
01221     }
01222     <span class="keywordflow">return</span> m_BestDisplayModes.size(); 
01223 } <span class="comment">// RenderSystemDX9::GetNDisplayModes</span>
01224 
01225 <span class="keywordtype">void</span> RenderSystemDX9::GetDisplayMode( <span class="keywordtype">int</span> idx, <span class="keywordtype">int</span>&amp; width, <span class="keywordtype">int</span>&amp; height ) 
01226 {
01227     <span class="keywordflow">if</span> (idx &lt; 0 || idx &gt;= m_BestDisplayModes.size()) <span class="keywordflow">return</span>;
01228     D3DDISPLAYMODE&amp; mode = m_BestDisplayModes[idx];
01229     width = mode.Width;
01230     height = mode.Height;
01231 } <span class="comment">// RenderSystemDX9::GetDisplayMode</span>
01232 
01233 D3DCOLORVALUE DwordToD3DCOLORVALUE( DWORD col )
01234 {
01235     D3DCOLORVALUE res;
01236     res.a = float( (col &amp; 0xFF000000)&gt;&gt;24 ) / 255.0f;
01237     res.r = float( (col &amp; 0x00FF0000)&gt;&gt;16 ) / 255.0f;
01238     res.g = float( (col &amp; 0x0000FF00)&gt;&gt;8  ) / 255.0f;
01239     res.b = float( (col &amp; 0x000000FF)     ) / 255.0f;
01240     <span class="keywordflow">return</span> res;
01241 }
01242 
01243 <span class="keywordtype">void</span> RenderSystemDX9::SetDirLight( DirectionalLight* pLight, <span class="keywordtype">int</span>&amp; index ) 
01244 {
01245     <span class="keywordflow">if</span> (!pLight) <span class="keywordflow">return</span>;
01246     <span class="keywordflow">if</span> (index == -1){
01247         index=0;
01248     }
01249     <span class="comment">//if (index == -1)</span>
01250     <span class="comment">//{</span>
01251     <span class="comment">//    index = m_NumActiveLights;</span>
01252     <span class="comment">//    if (m_NumActiveLights == c_MaxLights) return;</span>
01253     <span class="comment">//}</span>
01254 
01255     <span class="comment">//m_NumActiveLights++;</span>
01256 
01257 
01258     Vector3D dir = pLight-&gt;GetDir();
01259 
01260     D3DLIGHT9 light;
01261     light.Type      = D3DLIGHT_DIRECTIONAL ;            
01262     light.Diffuse   = DwordToD3DCOLORVALUE( pLight-&gt;GetDiffuse()  );
01263     light.Specular  = DwordToD3DCOLORVALUE( pLight-&gt;GetSpecular() );        
01264     light.Ambient   = DwordToD3DCOLORVALUE( pLight-&gt;GetAmbient()  );   
01265 
01266     light.Direction.x   = dir.x; 
01267     light.Direction.y   = dir.y;
01268     light.Direction.z   = dir.z;
01269 
01270     <span class="comment">//  Now, folks, docs say that "for directional light position/range is ignored"</span>
01271     <span class="comment">//  That is not true, at least on some drivers. So do them happy:</span>
01272     light.Range         = 100000.0f;
01273     light.Position.x    = 0.0f; 
01274     light.Position.y    = 0.0f;
01275     light.Position.z    = 0.0f;
01276 
01277     light.Attenuation0  = 1.0f;
01278     light.Attenuation1  = 0.0f;
01279     light.Attenuation2  = 0.0f;
01280 
01281     light.Falloff       = 1.0f;
01282     light.Theta         = c_PI;
01283     light.Phi           = c_PI;
01284 
01285     __beginT()
01286     DX_CHK( m_pDevice-&gt;SetLight( index, &amp;light ) );
01287     DX_CHK( m_pDevice-&gt;LightEnable( index, TRUE ) );
01288     __endT(OtherTime);
01289 }
01290 <span class="keywordtype">void</span> RenderSystemDX9::SetPointLight( PointLight* pLight, <span class="keywordtype">int</span>&amp; index ) 
01291 {
01292 }
01293 
01294 <span class="keywordtype">void</span> RenderSystemDX9::SetSpotLight( SpotLight* pLight, <span class="keywordtype">int</span>&amp; index ) 
01295 {
01296 }   
01297 
01298 <span class="keywordtype">void</span> RenderSystemDX9::SetRSBlock( RenderStateBlock* pBlock ) 
01299 {
01300 }
01301 
01302 <span class="keywordtype">void</span> RenderSystemDX9::SetTSBlock( TextureStateBlock* pBlock, <span class="keywordtype">int</span> stage ) 
01303 {
01304 }
01305 
01306 DWORD RenderSystemDX9::CreateStateBlock( StateBlock* pBlock ) 
01307 {
01308     <span class="keywordflow">return</span> 0; 
01309 }
01310 
01311 <span class="keywordtype">void</span> RenderSystemDX9::SetMaterial( DWORD ambient, DWORD diffuse, DWORD specular, DWORD emissive, <span class="keywordtype">float</span> power )
01312 {
01313     D3DMATERIAL9 mtl;
01314 
01315     mtl.Ambient     = ToD3DCOLORVALUE( ambient  );
01316     mtl.Diffuse     = ToD3DCOLORVALUE( diffuse  );
01317     mtl.Specular    = ToD3DCOLORVALUE( specular );
01318     mtl.Emissive    = ToD3DCOLORVALUE( emissive );
01319     mtl.Power       = power;
01320 
01321     __beginT();
01322     DX_CHK( m_pDevice-&gt;SetMaterial( &amp;mtl ) );
01323     __endT(OtherTime);
01324 } <span class="comment">// D3DRenderSystem::SetMaterial</span>
01325 
01326 <span class="keywordtype">void</span> RenderSystemDX9::SetFog( DWORD FogColor,<span class="keywordtype">float</span> FogStart,<span class="keywordtype">float</span> FogEnd,<span class="keywordtype">float</span> FogDensity,<span class="keywordtype">int</span> FogMode )          
01327 {
01328     m_FogColor=FogColor; 
01329     m_FogStart=FogStart; 
01330     m_FogEnd=FogEnd; 
01331     m_FogDensity=FogDensity; 
01332     m_FogMode=FogMode;
01333 } <span class="comment">// RenderSystemDX9::SetFog</span>
01334 
01335 <span class="keywordtype">void</span> RenderSystemDX9::ApplyFogStateBlock(){
01336     <span class="comment">//DX_CHK( m_pDevice-&gt;SetRenderState(D3DRS_FOGENABLE, TRUE)); </span>
01337     <span class="comment">//DX_CHK( m_pDevice-&gt;SetRenderState(D3DRS_RANGEFOGENABLE, TRUE));</span>
01338     <span class="comment">//if(!(GetKeyState(VK_'N'))){</span>
01339     __beginT();
01340     <span class="keywordflow">if</span>(m_FogColor){        
01341         DX_CHK( m_pDevice-&gt;SetRenderState(D3DRS_FOGCOLOR,m_FogColor)); 
01342         DX_CHK( m_pDevice-&gt;SetRenderState(D3DRS_FOGSTART,*(DWORD *)(&amp;m_FogStart))); 
01343         DX_CHK( m_pDevice-&gt;SetRenderState(D3DRS_FOGEND,*(DWORD *)(&amp;m_FogEnd))); 
01344         DX_CHK( m_pDevice-&gt;SetRenderState(D3DRS_FOGDENSITY,*(DWORD *)(&amp;m_FogDensity))); 
01345         DX_CHK( m_pDevice-&gt;SetRenderState(D3DRS_FOGTABLEMODE,m_FogMode));   
01346         DX_CHK( m_pDevice-&gt;SetRenderState(D3DRS_FOGVERTEXMODE,m_FogMode));
01347     }<span class="keywordflow">else</span>{
01348         DX_CHK( m_pDevice-&gt;SetRenderState(D3DRS_FOGENABLE,0)); 
01349     }
01350     __endT(OtherTime);
01351         <span class="comment">//Log.Warning("C=%X st=%f fn=%f d=%f,)</span>
01352     <span class="comment">//}</span>
01353 }
01354 
01355 <span class="keywordtype">void</span> RenderSystemDX9::DisableLights() 
01356 {
01357 } <span class="comment">// RenderSystemDX9::DisableLights</span>
01358 
01359 BYTE* RenderSystemDX9::LockAppendVB( <span class="keywordtype">int</span> vbID, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span>&amp; offset, DWORD&amp; stamp )
01360 {
01361     <span class="keywordflow">if</span> (vbID &lt; 0 || vbID &gt;= m_VBuffers.size()) <span class="keywordflow">return</span> NULL;
01362     <span class="keywordflow">if</span> (!m_VBuffers[vbID]-&gt;HasAppendSpace( size )) 
01363     {
01364         Flush();
01365     }
01366     <span class="keywordflow">return</span> m_VBuffers[vbID]-&gt;LockAppend( size, offset, stamp ); 
01367 } <span class="comment">// RenderSystemDX9::LockAppendVB</span>
01368 
01369 BYTE* RenderSystemDX9::LockAppendIB( <span class="keywordtype">int</span> ibID, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span>&amp; offset, DWORD&amp; stamp )
01370 {
01371     <span class="keywordflow">if</span> (ibID &lt; 0 || ibID &gt;= m_IBuffers.size()) <span class="keywordflow">return</span> NULL;
01372     <span class="keywordflow">if</span> (!m_IBuffers[ibID]-&gt;HasAppendSpace( size )) 
01373     {
01374         Flush();
01375     }
01376     <span class="keywordflow">return</span> m_IBuffers[ibID]-&gt;LockAppend( size, offset, stamp );
01377 } <span class="comment">// RenderSystemDX9::LockAppendIB</span>
01378 
01379 BYTE* RenderSystemDX9::LockVB( <span class="keywordtype">int</span> vbID, <span class="keywordtype">int</span> firstV, <span class="keywordtype">int</span> numV, DWORD&amp; stamp ) 
01380 { 
01381     <span class="keywordflow">if</span> (vbID &lt; 0 || vbID &gt;= m_VBuffers.size()) <span class="keywordflow">return</span> NULL;
01382     <span class="keywordflow">return</span> m_VBuffers[vbID]-&gt;Lock( firstV, numV, stamp ); 
01383 } <span class="comment">// RenderSystemDX9::LockVB</span>
01384 
01385 <span class="keywordtype">bool</span> RenderSystemDX9::IsVBStampValid( <span class="keywordtype">int</span> vbID, DWORD stamp )
01386 {
01387     <span class="keywordflow">if</span> (vbID &lt; 0 || vbID &gt;= m_VBuffers.size()) <span class="keywordflow">return</span> <span class="keyword">true</span>;
01388     <span class="keywordflow">return</span> m_VBuffers[vbID]-&gt;IsStampValid( stamp );
01389 } <span class="comment">// RenderSystemDX9::IsVBStampValid</span>
01390 
01391 <span class="keywordtype">int</span> RenderSystemDX9::GetVBufferID( <span class="keyword">const</span> <span class="keywordtype">char</span>* vbName )
01392 {
01393     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_VBuffers.size(); i++)
01394     {
01395         <span class="keywordflow">if</span> (!stricmp( vbName, m_VBuffers[i]-&gt;GetName() )) <span class="keywordflow">return</span> i;
01396     }
01397     <span class="keywordflow">return</span> -1;
01398 } <span class="comment">// RenderSystemDX9::GetVBufferID</span>
01399 
01400 <span class="keywordtype">bool</span> RenderSystemDX9::SetVB( <span class="keywordtype">int</span> vbID, <span class="keywordtype">int</span> vType, <span class="keywordtype">int</span> stream, <span class="keywordtype">int</span> frequency )
01401 {
01402     <span class="keywordflow">if</span> (vbID &lt; 0 || vbID &gt;= m_VBuffers.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
01403     IVertexBuffer* ivb = m_VBuffers[vbID];
01404     <span class="keywordflow">if</span> (vType &lt; 0) vType = ivb-&gt;GetVType();
01405     <span class="keyword">const</span> VertexTypeEntry&amp; vt = m_VertexTypes[vType];
01406     <span class="keywordtype">int</span> vSize = vt.m_VDecl.m_VertexSize;
01407     <span class="keywordflow">if</span> (vSize == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
01408     ivb-&gt;SetVType( vType );  
01409     ivb-&gt;SetVertexSize( vSize );
01410     __beginT();
01411     <span class="keywordflow">if</span>(vt.m_FVF){
01412         DX_CHK( m_pDevice-&gt;SetFVF( vt.m_FVF ) );
01413     }<span class="keywordflow">else</span>{
01414         DX_CHK( m_pDevice-&gt;SetVertexDeclaration( vt.m_pVDeclD3D ) );
01415     }    
01416     __endT(OtherTime);
01417     ivb-&gt;Bind( stream, frequency );
01418     <span class="keywordflow">return</span> <span class="keyword">true</span>;
01419 } <span class="comment">// RenderSystemDX9::SetVB</span>
01420 
01421 <span class="keywordtype">bool</span> RenderSystemDX9::DiscardVB( <span class="keywordtype">int</span> vbID ) 
01422 { 
01423     <span class="keywordflow">return</span> <span class="keyword">false</span>; 
01424 } <span class="comment">// RenderSystemDX9::DiscardVB</span>
01425 
01426 <span class="keywordtype">void</span> RenderSystemDX9::UnlockVB( <span class="keywordtype">int</span> vbID ) 
01427 { 
01428     <span class="keywordflow">if</span> (vbID &lt; 0 || vbID &gt;= m_VBuffers.size()) <span class="keywordflow">return</span>;
01429     m_VBuffers[vbID]-&gt;Unlock();
01430 } <span class="comment">// RenderSystemDX9::UnlockVB</span>
01431 
01432 <span class="keywordtype">int</span> RenderSystemDX9::CreateVB( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> vType, <span class="keywordtype">bool</span> bDynamic ) 
01433 { 
01434     <span class="keywordtype">int</span> vbID = GetVBufferID( name );
01435     <span class="keywordflow">if</span> (vbID != -1) <span class="keywordflow">return</span> vbID;
01436     
01437     VertexBufferDX9* vbuf = <span class="keyword">new</span> VertexBufferDX9( name, m_pDevice );
01438     <span class="keyword">const</span> VertexDeclaration* pVDecl = NULL;
01439     <span class="keywordflow">if</span> (vType &gt;= 0)
01440     {
01441         <span class="keyword">const</span> VertexTypeEntry&amp; vt = m_VertexTypes[vType];
01442         pVDecl = &amp;vt.m_VDecl;
01443     }
01444     <span class="keywordtype">bool</span> res = vbuf-&gt;Create( size, bDynamic, pVDecl );
01445     <span class="keywordflow">if</span> (!res)
01446     {
01447         <span class="keywordflow">if</span> (bDynamic) Log.Error( <span class="stringliteral">"Could not create dynamic vertex buffer. Name: %s, Size: %d"</span>, name, size );
01448         <span class="keywordflow">else</span> Log.Error( <span class="stringliteral">"Could not create static vertex buffer. Name: %s, Size: %d"</span>, name, size );
01449         <span class="keyword">delete</span> vbuf;
01450         <span class="keywordflow">return</span> -1;
01451     }
01452     vbID = m_VBuffers.size();
01453     m_VBuffers.push_back( vbuf );
01454     <span class="keywordflow">return</span> vbID; 
01455 } <span class="comment">// RenderSystemDX9::CreateVB</span>
01456 
01457 <span class="keywordtype">bool</span> RenderSystemDX9::DeleteVB( <span class="keywordtype">int</span> vbID ) 
01458 { 
01459     <span class="keywordflow">return</span> <span class="keyword">false</span>; 
01460 } <span class="comment">// RenderSystemDX9::DeleteVB</span>
01461 
01462 
01463 <span class="keywordtype">int</span> RenderSystemDX9::GetShaderVarID( <span class="keywordtype">int</span> shID, <span class="keyword">const</span> <span class="keywordtype">char</span>* constantName ) 
01464 { 
01465     <span class="keywordflow">if</span> (shID &lt; 0 || shID &gt;= m_Shaders.size()) <span class="keywordflow">return</span> -1;
01466     <span class="keywordflow">return</span> m_Shaders[shID]-&gt;GetShaderVarID( constantName );
01467 } <span class="comment">// RenderSystemDX9::GetShaderVarID</span>
01468 
01469 <span class="keywordtype">bool</span> RenderSystemDX9::SetShaderVar( <span class="keywordtype">int</span> shID, <span class="keywordtype">int</span> cID, <span class="keywordtype">bool</span> val ) 
01470 {
01471     <span class="keywordflow">if</span> (shID &lt; 0 || shID &gt;= m_Shaders.size()) <span class="keywordflow">return</span> -1;
01472     <span class="keywordflow">return</span> m_Shaders[shID]-&gt;SetShaderVar( cID, val );
01473 } <span class="comment">// RenderSystemDX9::SetShaderVar</span>
01474 
01475 <span class="keywordtype">bool</span> RenderSystemDX9::SetShaderVar( <span class="keywordtype">int</span> shID, <span class="keywordtype">int</span> cID, <span class="keywordtype">float</span> val ) 
01476 { 
01477     <span class="keywordflow">if</span> (shID &lt; 0 || shID &gt;= m_Shaders.size()) <span class="keywordflow">return</span> -1;
01478     <span class="keywordflow">return</span> m_Shaders[shID]-&gt;SetShaderVar( cID, val );
01479 } <span class="comment">// RenderSystemDX9::SetShaderVar</span>
01480 
01481 <span class="keywordtype">bool</span> RenderSystemDX9::SetShaderVar( <span class="keywordtype">int</span> shID, <span class="keywordtype">int</span> cID, <span class="keywordtype">int</span> val ) 
01482 { 
01483     <span class="keywordflow">if</span> (shID &lt; 0 || shID &gt;= m_Shaders.size()) <span class="keywordflow">return</span> -1;
01484     <span class="keywordflow">return</span> m_Shaders[shID]-&gt;SetShaderVar( cID, val ); 
01485 } <span class="comment">// RenderSystemDX9::SetShaderVar</span>
01486 
01487 <span class="keywordtype">bool</span> RenderSystemDX9::SetShaderVar( <span class="keywordtype">int</span> shID, <span class="keywordtype">int</span> cID, <span class="keyword">const</span> Matrix4D&amp; val ) 
01488 { 
01489     <span class="keywordflow">if</span> (shID &lt; 0 || shID &gt;= m_Shaders.size()) <span class="keywordflow">return</span> -1;
01490     <span class="keywordflow">return</span> m_Shaders[shID]-&gt;SetShaderVar( cID, val ); 
01491 } <span class="comment">// RenderSystemDX9::SetShaderVar</span>
01492 
01493 <span class="keywordtype">bool</span> RenderSystemDX9::SetShaderVar( <span class="keywordtype">int</span> shID, <span class="keywordtype">int</span> cID, <span class="keyword">const</span> Vector4D&amp; val ) 
01494 { 
01495     <span class="keywordflow">if</span> (shID &lt; 0 || shID &gt;= m_Shaders.size()) <span class="keywordflow">return</span> -1;
01496     <span class="keywordflow">return</span> m_Shaders[shID]-&gt;SetShaderVar( cID, val ); 
01497 } <span class="comment">// RenderSystemDX9::SetShaderVar</span>
01498 
01499 <span class="keywordtype">bool</span> RenderSystemDX9::SetShaderVar( <span class="keywordtype">int</span> shID, <span class="keywordtype">int</span> cID, <span class="keyword">const</span> Vector3D&amp; val ) 
01500 { 
01501     <span class="keywordflow">if</span> (shID &lt; 0 || shID &gt;= m_Shaders.size()) <span class="keywordflow">return</span> -1;
01502     <span class="keywordflow">return</span> m_Shaders[shID]-&gt;SetShaderVar( cID, val ); 
01503 } <span class="comment">// RenderSystemDX9::SetShaderVar</span>
01504 
01505 <span class="keywordtype">int</span> RenderSystemDX9::GetTextureWidth( <span class="keywordtype">int</span> texID )<span class="keyword"> const</span>
01506 <span class="keyword"></span>{
01507     <span class="keywordflow">if</span> (texID &lt; 0 || texID &gt;= m_Textures.size()) <span class="keywordflow">return</span> 0;
01508     <span class="keywordflow">return</span> m_Textures[texID]-&gt;GetWidth();
01509 } <span class="comment">// RenderSystemDX9::GetTextureWidth</span>
01510 
01511 <span class="keywordtype">int</span> RenderSystemDX9::GetNTextures()<span class="keyword"> const</span>
01512 <span class="keyword"></span>{
01513     <span class="keywordflow">return</span> m_Textures.size();
01514 } <span class="comment">// RenderSystemDX9::GetNTextures</span>
01515 
01516 <span class="keywordtype">int</span> RenderSystemDX9::GetTextureSize( <span class="keywordtype">int</span> texID )<span class="keyword"> const</span>
01517 <span class="keyword"></span>{
01518     <span class="keywordflow">if</span> (texID &lt; 0 || texID &gt;= m_Textures.size()) <span class="keywordflow">return</span> 0;
01519     <span class="keywordflow">return</span> m_Textures[texID]-&gt;GetSize();
01520 } <span class="comment">// RenderSystemDX9::GetTextureSize</span>
01521 
01522 TextureMemoryPool RenderSystemDX9::GetTexturePool( <span class="keywordtype">int</span> texID )<span class="keyword"> const</span>
01523 <span class="keyword"></span>{
01524     <span class="keywordflow">if</span> (texID &lt; 0 || texID &gt;= m_Textures.size()) <span class="keywordflow">return</span> tmpUnknown;
01525     <span class="keywordflow">return</span> m_Textures[texID]-&gt;GetPool();
01526 } <span class="comment">// RenderSystemDX9::GetTexturePool</span>
01527 
01528 ColorFormat RenderSystemDX9::GetTextureFormat( <span class="keywordtype">int</span> texID )
01529 {
01530     <span class="keywordflow">if</span> (texID &lt; 0 || texID &gt;= m_Textures.size()) <span class="keywordflow">return</span> cfUnknown;
01531     <span class="keywordflow">return</span> m_Textures[texID]-&gt;GetColorFormat();
01532 } <span class="comment">// RenderSystemDX9::GetTextureFormat</span>
01533 
01534 <span class="keywordtype">int</span> RenderSystemDX9::GetTextureHeight( <span class="keywordtype">int</span> texID )<span class="keyword"> const</span>
01535 <span class="keyword"></span>{
01536     <span class="keywordflow">if</span> (texID &lt; 0 || texID &gt;= m_Textures.size()) <span class="keywordflow">return</span> 0;
01537     <span class="keywordflow">return</span> m_Textures[texID]-&gt;GetHeight();
01538 } <span class="comment">// RenderSystemDX9::GetTextureHeight</span>
01539 
01540 <span class="keywordtype">int</span> RenderSystemDX9::GetTextureNMips( <span class="keywordtype">int</span> texID )<span class="keyword"> const</span>
01541 <span class="keyword"></span>{
01542     <span class="keywordflow">if</span> (texID &lt; 0 || texID &gt;= m_Textures.size()) <span class="keywordflow">return</span> 0;
01543     <span class="keywordflow">return</span> m_Textures[texID]-&gt;GetNMipMaps();
01544 } <span class="comment">// RenderSystemDX9::GetTextureNMips</span>
01545 
01546 
01547 BYTE* RenderSystemDX9::LockIB( <span class="keywordtype">int</span> ibID, <span class="keywordtype">int</span> firstIdx, <span class="keywordtype">int</span> numIdx, DWORD&amp; stamp )
01548 {
01549     <span class="keywordflow">if</span> (ibID &lt; 0 || ibID &gt;= m_IBuffers.size()) <span class="keywordflow">return</span> NULL;
01550     <span class="keywordflow">return</span> m_IBuffers[ibID]-&gt;Lock( firstIdx, numIdx, stamp );
01551 } <span class="comment">// RenderSystemDX9::LockIB</span>
01552 
01553 
01554 <span class="keywordtype">bool</span> RenderSystemDX9::DiscardIB( <span class="keywordtype">int</span> ibID )
01555 {
01556     <span class="keywordflow">if</span> (ibID &lt; 0 || ibID &gt;= m_IBuffers.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
01557     <span class="keywordflow">return</span> <span class="keyword">false</span>;<span class="comment">//m_IBuffers[ibID]-&gt;Discard();</span>
01558 } <span class="comment">// RenderSystemDX9::LockIB</span>
01559 
01560 <span class="keywordtype">void</span> RenderSystemDX9::UnlockIB( <span class="keywordtype">int</span> ibID )
01561 {
01562     <span class="keywordflow">if</span> (ibID &lt; 0 || ibID &gt;= m_IBuffers.size()) <span class="keywordflow">return</span>;
01563     <span class="keywordflow">return</span> m_IBuffers[ibID]-&gt;Unlock();
01564 } <span class="comment">// RenderSystemDX9::UnlockIB</span>
01565 
01566 <span class="keywordtype">int</span> RenderSystemDX9::CreateIB( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">int</span> size, IndexSize idxSize, <span class="keywordtype">bool</span> bDynamic )
01567 {
01568     <span class="keywordtype">int</span> ibID = GetIBufferID( name );
01569     <span class="keywordflow">if</span> (ibID != -1) <span class="keywordflow">return</span> ibID;
01570 
01571     IndexBufferDX9* ibuf = <span class="keyword">new</span> IndexBufferDX9( name );
01572     <span class="keyword">const</span> VertexDeclaration* pVDecl = NULL;
01573     <span class="keywordtype">bool</span> res = ibuf-&gt;Create( size, bDynamic, idxSize );
01574     <span class="keywordflow">if</span> (!res)
01575     {
01576         <span class="keywordflow">if</span> (bDynamic) Log.Error( <span class="stringliteral">"Could not create dynamic index buffer. Name: %s, Size: %d"</span>, name, size );
01577         <span class="keywordflow">else</span> Log.Error( <span class="stringliteral">"Could not create static index buffer. Name: %s, Size: %d"</span>, name, size );
01578         <span class="keyword">delete</span> ibuf;
01579         <span class="keywordflow">return</span> -1;
01580     }
01581     ibID = m_IBuffers.size();
01582     m_IBuffers.push_back( ibuf );
01583     <span class="keywordflow">return</span> ibID; 
01584 } <span class="comment">// RenderSystemDX9::CreateIB</span>
01585 
01586 <span class="keywordtype">bool</span> RenderSystemDX9::IsIBStampValid( <span class="keywordtype">int</span> ibID, DWORD stamp )
01587 {
01588     <span class="keywordflow">if</span> (ibID &lt; 0 || ibID &gt;= m_IBuffers.size()) <span class="keywordflow">return</span> <span class="keyword">true</span>;
01589     <span class="keywordflow">return</span> m_IBuffers[ibID]-&gt;IsStampValid( stamp );
01590 } <span class="comment">// RenderSystemDX9::IsIBStampValid</span>
01591 
01592 <span class="keywordtype">int</span> RenderSystemDX9::GetIBufferID( <span class="keyword">const</span> <span class="keywordtype">char</span>* ibName )
01593 {
01594     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_IBuffers.size(); i++)
01595     {
01596         <span class="keywordflow">if</span> (!stricmp( ibName, m_IBuffers[i]-&gt;GetName() )) <span class="keywordflow">return</span> i;
01597     }
01598     <span class="keywordflow">return</span> -1;
01599 } <span class="comment">// RenderSystemDX9::GetIBufferID</span>
01600 
01601 <span class="keywordtype">bool</span> RenderSystemDX9::SetIB( <span class="keywordtype">int</span> ibID )
01602 {
01603     <span class="keywordflow">if</span> (ibID &lt; 0 || ibID &gt;= m_IBuffers.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
01604     <span class="keywordflow">return</span> m_IBuffers[ibID]-&gt;Bind();
01605 } <span class="comment">// RenderSystemDX9::SetIB</span>
01606 
01607 <span class="keywordtype">bool</span> RenderSystemDX9::DeleteIB( <span class="keywordtype">int</span> ibID )
01608 {
01609     <span class="keywordflow">return</span> <span class="keyword">false</span>;
01610 } <span class="comment">// RenderSystemDX9::DeleteIB</span>
01611 
01612 <span class="keywordtype">int</span> RenderSystemDX9::RegisterVType( <span class="keyword">const</span> VertexDeclaration&amp; vdecl )
01613 {
01614     <span class="keywordtype">int</span> nVT = m_VertexTypes.size();
01615     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nVT; i++)
01616     {
01617         <span class="keywordflow">if</span> (m_VertexTypes[i].m_VDecl == vdecl) <span class="keywordflow">return</span> i;
01618     }
01619     <span class="comment">// search whether already registered </span>
01620     VertexTypeEntry ve;
01621     VertexFormat vf = (VertexFormat)i;
01622     ve.m_VFormat    = vf;
01623     ve.m_VDecl      = vdecl;
01624     ve.m_pVDeclD3D  = CreateVDecl( m_pDevice, vdecl );
01625     ve.m_FVF        = CreateFVF( vdecl );
01626     m_VertexTypes.push_back( ve );
01627     <span class="keywordflow">return</span> m_VertexTypes.size() - 1;
01628 } <span class="comment">// RenderSystemDX9::RegisterVType</span>
01629 
01630 <span class="keywordtype">int</span> TimeInDrawPrim=0;
01631 <span class="keywordtype">int</span> Diplimit=1000000;
01632 <span class="keywordtype">int</span> NumDips=0;
01633 <span class="keywordtype">void</span> RenderSystemDX9::Draw( <span class="keywordtype">int</span> firstVert, <span class="keywordtype">int</span> nVert, <span class="keywordtype">int</span> firstIdx, <span class="keywordtype">int</span> nIdx, PrimitiveType priType )
01634 {
01635     <span class="keywordflow">if</span> (nVert == 0 || Diplimit == 0) <span class="keywordflow">return</span>;
01636     Diplimit--;
01637     NumDips++;
01638     <span class="comment">//  draw primitives</span>
01639     <span class="keywordtype">bool</span> bIndexed   = <span class="keyword">true</span>; 
01640     <span class="keywordtype">int</span> numPri      = 0;
01641     <span class="keywordflow">if</span> (nIdx == 0)
01642     {
01643         numPri = GetNumPrimitives( priType, nVert );
01644         bIndexed = <span class="keyword">false</span>;
01645         <span class="keywordflow">if</span> (priType == ptQuadList)
01646         {
01647             numPri      = nVert/2;
01648             bIndexed    = <span class="keyword">true</span>;
01649             firstIdx    = 0;
01650             <span class="keyword">static</span> <span class="keywordtype">int</span> s_QuadIB = GetIBufferID( <span class="stringliteral">"Quads"</span> );
01651             SetIB( s_QuadIB );
01652         }
01653     }
01654     <span class="keywordflow">else</span>
01655     {
01656         numPri = GetNumPrimitives( priType, nIdx );
01657     }
01658 
01659     <span class="comment">//SetFogOverride();</span>
01660     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;8;i++){
01661         <span class="keywordflow">if</span>(m_TextureOverride[i]&gt;0){
01662             IRS-&gt;SetTexture( m_TextureOverride[i],i );
01663         }
01664     }
01665 
01666     __beginT();
01667 
01668     DX_CHK( m_pDevice-&gt;BeginScene() );
01669     <span class="keywordflow">if</span> (bIndexed)
01670     {
01671         DX_CHK( m_pDevice-&gt;DrawIndexedPrimitive( ConvertPrimitiveType( priType ), 
01672                                                     firstVert, 
01673                                                     0, 
01674                                                     nVert, 
01675                                                     firstIdx, 
01676                                                     numPri ) );
01677     }
01678     <span class="keywordflow">else</span>
01679     {
01680         DX_CHK( m_pDevice-&gt;DrawPrimitive( ConvertPrimitiveType( priType ), firstVert, numPri ) );
01681     }
01682     DX_CHK( m_pDevice-&gt;EndScene() );
01683 
01684     __endT(TimeInDrawPrim);
01685 
01686 
01687 } <span class="comment">// RenderSystemDX9::Draw</span>
01688 
01689 
01690 <span class="keywordtype">int</span> RenderSystemDX9::GetFontID( <span class="keyword">const</span> <span class="keywordtype">char</span>* name ) 
01691 {
01692     <span class="keywordtype">int</span> nF = m_Fonts.size();
01693     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nF; i++)
01694     {
01695         <span class="keyword">const</span> IFont* pTex = m_Fonts[i];
01696         <span class="keywordflow">if</span> (!strcmp( pTex-&gt;GetName(), name )) <span class="keywordflow">return</span> i;
01697     }
01698     <span class="comment">//  load texture </span>
01699     IFont* pFont = <span class="keyword">new</span> FontDX9( m_pDevice );
01700     
01701     <span class="comment">//  create font here...</span>
01702 
01703     m_Fonts.push_back( pFont );
01704     pFont-&gt;SetID( nF );
01705     <span class="keywordflow">return</span> nF; 
01706 } <span class="comment">// RenderSystemDX9::GetFontID </span>
01707 
01708 <span class="keywordtype">void</span> RenderSystemDX9::DestroyFont( <span class="keywordtype">int</span> fontID ) 
01709 {
01710 
01711 } <span class="comment">// RenderSystemDX9::DestroyFont</span>
01712 
01713 <span class="keywordtype">int</span> RenderSystemDX9::CreateFont( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keywordtype">int</span> height, DWORD charset, <span class="keywordtype">bool</span> bBold, <span class="keywordtype">bool</span> bItalic )                            
01714 {
01715     <span class="keywordflow">return</span> -1;
01716 }
01717 
01718 <span class="keywordtype">int</span> RenderSystemDX9::CreateFont( <span class="keyword">const</span> <span class="keywordtype">char</span>* texName, <span class="keywordtype">int</span> charW, <span class="keywordtype">int</span> charH ) 
01719 {
01720     <span class="keywordflow">return</span> -1;
01721 }
01722 
01723 <span class="keywordtype">int</span> RenderSystemDX9::GetStringWidth( <span class="keywordtype">int</span> fontID, <span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keywordtype">int</span> spacing ) 
01724 {
01725     <span class="keywordflow">return</span> 0;
01726 }
01727 
01728 <span class="keywordtype">int</span> RenderSystemDX9::GetCharWidth( <span class="keywordtype">int</span> fontID, BYTE ch ) 
01729 {
01730     <span class="keywordflow">return</span> 0;
01731 }
01732 
01733 <span class="keywordtype">int</span> RenderSystemDX9::GetCharHeight( <span class="keywordtype">int</span> fontID, BYTE ch ) 
01734 {
01735     <span class="keywordflow">return</span> 0; 
01736 }
01737 
01738 <span class="keywordtype">void</span> RenderSystemDX9::SetCurrentFont( <span class="keywordtype">int</span> fontID ) 
01739 {
01740 
01741 }
01742 
01743 <span class="keywordtype">bool</span> RenderSystemDX9::DrawString( <span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keyword">const</span> Vector3D&amp; pos, DWORD color, <span class="keywordtype">int</span> spacing ) 
01744 {
01745     <span class="keywordflow">return</span> <span class="keyword">false</span>;
01746 }
01747 
01748 <span class="keywordtype">bool</span> RenderSystemDX9::DrawString3D( <span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keyword">const</span> Vector3D&amp; pos, DWORD color, <span class="keywordtype">int</span> spacing ) 
01749 {
01750     <span class="keywordflow">return</span> <span class="keyword">false</span>;
01751 }
01752 
01753 <span class="keywordtype">bool</span> RenderSystemDX9::DrawChar( <span class="keyword">const</span> Vector3D&amp; pos, BYTE ch, DWORD color ) 
01754 {
01755     <span class="keywordflow">return</span> <span class="keyword">false</span>;
01756 }
01757 
01758 <span class="keywordtype">bool</span> RenderSystemDX9::DrawChar( <span class="keyword">const</span> Vector3D&amp; pos, <span class="keyword">const</span> Rct&amp; uv, DWORD color )
01759 {
01760     <span class="keywordflow">return</span> <span class="keyword">false</span>;
01761 }
01762 
01763 <span class="keywordtype">bool</span> RenderSystemDX9::DrawChar( <span class="keyword">const</span> Vector3D&amp; pos, <span class="keyword">const</span> Rct&amp; uv, <span class="keywordtype">float</span> w, <span class="keywordtype">float</span> h, DWORD color )
01764 {
01765     <span class="keywordflow">return</span> <span class="keyword">false</span>;
01766 }
01767 
01768 <span class="keywordtype">void</span> RenderSystemDX9::FlushText() 
01769 {
01770 
01771 }
01772 
01773 <span class="keywordtype">void</span> RenderSystemDX9::DrawLine( <span class="keywordtype">float</span> x1, <span class="keywordtype">float</span> y1, <span class="keywordtype">float</span> x2, <span class="keywordtype">float</span> y2, <span class="keywordtype">float</span> z, DWORD color1, DWORD color2 )
01774 {
01775 
01776 } <span class="comment">// RenderSystemDX9::DrawLine</span>
01777 
01778 <span class="keywordtype">void</span> RenderSystemDX9::DrawLine( <span class="keyword">const</span> Vector3D&amp; a, <span class="keyword">const</span> Vector3D&amp; b, DWORD color1, DWORD color2 )
01779 {
01780 
01781 } <span class="comment">// RenderSystemDX9::DrawLine</span>
01782 
01783 <span class="keywordtype">void</span> RenderSystemDX9::DrawRect( <span class="keyword">const</span> Rct&amp; rct, <span class="keyword">const</span> Rct&amp; uv, <span class="keywordtype">float</span> z, DWORD ca, DWORD cb, DWORD cc, DWORD cd )
01784 {
01785 
01786 } <span class="comment">// RenderSystemDX9::DrawRect</span>
01787 
01788 <span class="keywordtype">void</span> RenderSystemDX9::DrawPoly( <span class="keywordtype">float</span> ax, <span class="keywordtype">float</span> ay, <span class="keywordtype">float</span> bx, <span class="keywordtype">float</span> by, <span class="keywordtype">float</span> cx, <span class="keywordtype">float</span> cy,
01789                                  <span class="keywordtype">float</span> au, <span class="keywordtype">float</span> av, <span class="keywordtype">float</span> bu, <span class="keywordtype">float</span> bv, <span class="keywordtype">float</span> cu, <span class="keywordtype">float</span> cv )
01790 {
01791 
01792 } <span class="comment">// RenderSystemDX9::DrawPoly</span>
01793 
01794 <span class="keywordtype">void</span> RenderSystemDX9::DrawPoly( <span class="keyword">const</span> Vector3D&amp; a, <span class="keyword">const</span> Vector3D&amp; b, <span class="keyword">const</span> Vector3D&amp; c, DWORD acol, DWORD bcol, DWORD ccol,
01795                                  <span class="keywordtype">float</span> au, <span class="keywordtype">float</span> av, <span class="keywordtype">float</span> bu, <span class="keywordtype">float</span> bv, <span class="keywordtype">float</span> cu, <span class="keywordtype">float</span> cv )
01796 {
01797 
01798 } <span class="comment">// RenderSystemDX9::DrawPoly</span>
01799 
01800 <span class="keywordtype">void</span> RenderSystemDX9::FlushPrim( <span class="keywordtype">bool</span> bShaded )
01801 {
01802 
01803 } <span class="comment">// RenderSystemDX9::FlushPrim</span>
01804 
01805 LRESULT RenderSystemDX9::MsgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
01806 {
01807     <span class="keywordflow">if</span> (!IInput) <span class="keywordflow">return</span> D3DApplication::MsgProc( hWnd, uMsg, wParam, lParam );
01808     
01809     <span class="keywordflow">switch</span> (uMsg) 
01810     {
01811     <span class="keywordflow">case</span> WM_LBUTTONDBLCLK:
01812         IInput-&gt;MouseLBDbl( LOWORD( lParam ), HIWORD( lParam ) );
01813         <span class="keywordflow">break</span>;
01814 
01815     <span class="keywordflow">case</span> WM_MBUTTONDBLCLK:
01816         IInput-&gt;MouseMBDbl( LOWORD( lParam ), HIWORD( lParam ) );
01817         <span class="keywordflow">break</span>;
01818 
01819     <span class="keywordflow">case</span> WM_RBUTTONDBLCLK:
01820         IInput-&gt;MouseRBDbl( LOWORD( lParam ), HIWORD( lParam ) );
01821         <span class="keywordflow">break</span>;
01822 
01823     <span class="keywordflow">case</span> WM_RBUTTONDOWN:
01824         IInput-&gt;MouseRBDown( LOWORD( lParam ), HIWORD( lParam ) );
01825         <span class="keywordflow">break</span>;
01826 
01827     <span class="keywordflow">case</span> WM_RBUTTONUP:
01828         IInput-&gt;MouseRBUp( LOWORD( lParam ), HIWORD( lParam ) );
01829         <span class="keywordflow">break</span>;
01830 
01831     <span class="keywordflow">case</span> WM_LBUTTONDOWN:
01832         IInput-&gt;MouseLBDown( LOWORD( lParam ), HIWORD( lParam ) );
01833         <span class="keywordflow">break</span>;
01834 
01835     <span class="keywordflow">case</span> WM_LBUTTONUP:
01836         IInput-&gt;MouseLBUp( LOWORD( lParam ), HIWORD( lParam ) );
01837         <span class="keywordflow">break</span>;
01838 
01839     <span class="keywordflow">case</span> WM_MBUTTONDOWN:
01840         IInput-&gt;MouseMBDown( LOWORD( lParam ), HIWORD( lParam ) );
01841         <span class="keywordflow">break</span>;
01842 
01843     <span class="keywordflow">case</span> WM_MBUTTONUP:
01844         IInput-&gt;MouseMBUp( LOWORD( lParam ), HIWORD( lParam ) );
01845         <span class="keywordflow">break</span>;
01846 
01847     <span class="keywordflow">case</span> WM_MOUSEMOVE:
01848         IInput-&gt;MouseMove( LOWORD( lParam ), HIWORD( lParam ), wParam );
01849         <span class="keywordflow">break</span>;
01850 
01851     <span class="keywordflow">case</span> WM_MOUSEWHEEL:
01852         {
01853             <span class="keywordtype">short</span> WheelDelta = (<span class="keywordtype">short</span>) HIWORD( wParam );
01854             IInput-&gt;MouseWheel( WheelDelta );
01855         }<span class="keywordflow">break</span>;
01856 
01857     <span class="keywordflow">case</span> WM_KEYDOWN:
01858             IInput-&gt;KeyDown( wParam, lParam );
01859         <span class="keywordflow">break</span>;
01860 
01861     <span class="keywordflow">case</span> WM_CHAR:
01862             IInput-&gt;Char( wParam, lParam );
01863         <span class="keywordflow">break</span>;
01864 
01865     <span class="keywordflow">case</span> WM_KEYUP:
01866             IInput-&gt;KeyUp( wParam, lParam );
01867         <span class="keywordflow">break</span>;
01868 
01869     <span class="keywordflow">case</span> WM_ERASEBKGND: <span class="keywordflow">return</span> TRUE;
01870     }
01871 
01872     <span class="keywordflow">return</span> D3DApplication::MsgProc( hWnd, uMsg, wParam, lParam );
01873 } <span class="comment">// RenderSystemDX9::MsgProc</span>
01874 
01875 <span class="keywordtype">void</span> RenderSystemDX9::CreateVTypeTable()
01876 {
01877     <span class="keywordtype">int</span> nVTypes = (<span class="keywordtype">int</span>)vfLAST;
01878     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nVTypes; i++)
01879     {
01880         VertexFormat vf = (VertexFormat)i;
01881         VertexDeclaration vdecl = CreateVertexDeclaration( vf );
01882         <span class="keywordtype">int</span> vtype = RegisterVType( vdecl );
01883         assert( i == vtype );
01884     }
01885 } <span class="comment">// RenderSystemDX9::CreateVTypeTable</span>
01886 
01887 <span class="keywordtype">void</span> RenderSystemDX9::ClearVTypeTable()
01888 {
01889     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_VertexTypes.size(); i++)
01890     {
01891         <span class="keywordflow">if</span> (m_VertexTypes[i].m_pVDeclD3D) 
01892         {
01893             SAFE_RELEASE( m_VertexTypes[i].m_pVDeclD3D );
01894         }
01895     }
01896     m_VertexTypes.clear();
01897 } <span class="comment">// RenderSystemDX9::ClearVTypeTable</span>
01898 
01899 <span class="keywordtype">void</span> RenderSystemDX9::FillQuadIndexBuffer()
01900 {
01901     <span class="keywordtype">int</span> ibID = GetIBufferID( <span class="stringliteral">"Quads"</span> );
01902     <span class="keywordflow">if</span> (ibID == -1) <span class="keywordflow">return</span>;
01903     IIndexBuffer* ibuf = m_IBuffers[ibID];
01904     <span class="keywordtype">int</span> nIdx = c_QuadIBufferBytes/2;
01905     <span class="keywordtype">int</span> nQuads = nIdx/6;
01906     DWORD stamp;
01907     WORD* pIdx = (WORD*)ibuf-&gt;Lock( 0, nQuads*6, stamp, <span class="keyword">true</span> );
01908     <span class="keywordflow">if</span> (!pIdx) 
01909     {
01910         Log.Error( <span class="stringliteral">"Could not lock quad index buffer."</span> );
01911         <span class="keywordflow">return</span>;
01912     }
01913     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nQuads; i++)
01914     {
01915         <span class="keywordtype">int</span> cV = i*4;
01916         pIdx[i*6 + 0] = cV + 0;
01917         pIdx[i*6 + 1] = cV + 1;
01918         pIdx[i*6 + 2] = cV + 2;
01919         pIdx[i*6 + 3] = cV + 2;
01920         pIdx[i*6 + 4] = cV + 1;
01921         pIdx[i*6 + 5] = cV + 3;
01922     }
01923     ibuf-&gt;Unlock();
01924 } <span class="comment">// RenderSystemDX9::FillQuadIndexBuffer</span>
01925 
01926 <span class="keywordtype">void</span> RenderSystemDX9::PurgeStaticBuffers()
01927 {
01928     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_VBuffers.size(); i++)
01929     {
01930         <span class="keywordflow">if</span> (!m_VBuffers[i]-&gt;IsDynamic()) m_VBuffers[i]-&gt;Purge();
01931     }
01932 
01933     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_IBuffers.size(); i++)
01934     {
01935         <span class="keywordflow">if</span> (!m_IBuffers[i]-&gt;IsDynamic() &amp;&amp; 
01936             stricmp( m_IBuffers[i]-&gt;GetName(), <span class="stringliteral">"Quads"</span> )) m_IBuffers[i]-&gt;Purge();
01937     }
01938 } <span class="comment">// RenderSystemDX9::PurgeStaticBuffers</span>
01939 
01940 
01941 <span class="keyword">struct </span>TaskCompare
01942 {
01943     <span class="keywordtype">bool</span> operator ()( <span class="keyword">const</span> RenderTask* l, <span class="keyword">const</span> RenderTask* r ) { <span class="keywordflow">return</span> (*l &lt; *r); }
01944 }; <span class="comment">// struct TaskCompare</span>
01945 
01946 <span class="keywordtype">void</span> RenderSystemDX9::SortTasks()
01947 {
01948     <span class="keywordflow">if</span> (m_bSorted) <span class="keywordflow">return</span>;
01949     m_SortedTasks.resize( m_NTasks );
01950     <span class="keywordtype">int</span> nT = m_NTasks;
01951     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nT; i++) { m_SortedTasks[i] = &amp;m_Tasks[i]; }
01952     std::sort( m_SortedTasks.begin(), m_SortedTasks.end(), TaskCompare() );
01953     m_bSorted = <span class="keyword">true</span>;
01954 } <span class="comment">// RenderSystemDX9::SortTasks</span>
01955 
01956 <span class="keywordtype">void</span> RenderSystemDX9::Flush()
01957 {
01958     SortTasks();
01959     <span class="keywordtype">int</span> nT = m_SortedTasks.size();
01960     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nT; i++)
01961     {
01962         <span class="keyword">const</span> RenderTask&amp; rt = *m_SortedTasks[i];
01963         <span class="keyword">const</span> RenderTask&amp; pt = (i == 0) ? RenderTask::c_Invalid : *m_SortedTasks[i - 1];
01964 
01965         <span class="keywordflow">if</span> (rt.m_ShaderID != pt.m_ShaderID) 
01966         {
01967             SetShader( rt.m_ShaderID, rt.m_Pass );
01968         }
01969         
01970         <span class="keywordflow">if</span> (rt.m_bHasTM) SetWorldTM( rt.m_TM );<span class="comment">// else ResetWorldTM();</span>
01971         <span class="keywordflow">if</span> (rt.m_ShaderID != pt.m_ShaderID) 
01972         {
01973             SetShaderAutoVars();
01974         }
01975 
01976         <span class="keywordflow">if</span> (rt.m_VBufID != pt.m_VBufID || rt.m_VType != pt.m_VType) SetVB( rt.m_VBufID, rt.m_VType );
01977         <span class="keywordflow">if</span> (rt.m_IBufID != pt.m_IBufID) 
01978         {
01979             SetIB( rt.m_IBufID );
01980         }
01981 
01982         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; c_MaxTextureStages; j++) 
01983         {
01984             <span class="keyword">const</span> <span class="keywordtype">int</span> texID = rt.m_TexID[j];
01985             <span class="keywordflow">if</span> (texID != pt.m_TexID[j] &amp;&amp; texID &gt;= 0) 
01986             {
01987                 m_Textures[texID]-&gt;Bind( j );
01988             }
01989         }
01990 
01991         SetTextureFactor( rt.m_TFactor );
01992         <span class="keywordtype">int</span> nP = IRS-&gt;GetNShaderPasses( rt.m_ShaderID );
01993         <span class="keywordflow">if</span> (nP == 1)
01994         <span class="comment">//  single-pass shader</span>
01995         {
01996             Draw( rt.m_FirstVert, rt.m_NVert, rt.m_FirstIdx, rt.m_NIdx, rt.m_PriType );
01997         }
01998         <span class="keywordflow">else</span>
01999         <span class="comment">//  multipass shader</span>
02000         {
02001             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nP; i++)
02002             {
02003                 IRS-&gt;SetShader( rt.m_ShaderID, i );
02004                 SetShaderAutoVars();
02005                 Draw( rt.m_FirstVert, rt.m_NVert, rt.m_FirstIdx, rt.m_NIdx, rt.m_PriType );
02006             }
02007         }
02008     }
02009 
02010     m_NTasks  = 0; 
02011     m_bSorted = <span class="keyword">false</span>; 
02012 } <span class="comment">// RenderSystemDX9::RenderScene</span>
02013 
02014 <span class="comment">//-------------------------------------------------------------------------------------</span>
02015 <span class="comment">// RenderSystemDX9::ScreenShot : void(const char *, _D3DXIMAGE_FILEFORMAT)</span>
02016 <span class="comment">//-------------------------------------------------------------------------------------</span>
02017 <span class="keywordtype">void</span> RenderSystemDX9::ScreenShot(<span class="keyword">const</span> <span class="keywordtype">char</span> *pFileName, _D3DXIMAGE_FILEFORMAT Format) {
02018     LPDIRECT3DSURFACE9 Buffer;
02019     <span class="keywordtype">int</span> W = GetSystemMetrics(SM_CXSCREEN);
02020     <span class="keywordtype">int</span> H = GetSystemMetrics(SM_CYSCREEN);
02021     
02022     HRESULT hr = m_pDevice-&gt;CreateOffscreenPlainSurface(W, H, D3DFMT_A8R8G8B8, D3DPOOL_SCRATCH, &amp;Buffer, NULL);
02023     <span class="keywordflow">if</span>(FAILED(hr)) <span class="keywordflow">return</span>;
02024     hr = m_pDevice-&gt;GetFrontBufferData(NULL, Buffer);
02025     <span class="keywordflow">if</span>(SUCCEEDED(hr)) {
02026         D3DXSaveSurfaceToFile(pFileName, Format, Buffer, NULL, NULL);
02027     }
02028     Buffer-&gt;Release();
02029 } <span class="comment">// RenderSystemDX9::ScreenShot</span>
02030 
02031 <span class="comment">//-----------------------------------------------------------------------------</span>
02032 <span class="comment">// RenderSystemDX9::ScreenShotBMP : void(const char *)</span>
02033 <span class="comment">//-----------------------------------------------------------------------------</span>
02034 <span class="keywordtype">void</span> RenderSystemDX9::ScreenShotBMP(<span class="keyword">const</span> <span class="keywordtype">char</span> *pBMPFileName) {
02035     ScreenShot(pBMPFileName, D3DXIFF_BMP);
02036 } <span class="comment">// RenderSystemDX9::ScreenShotBMP</span>
02037 
02038 <span class="comment">//-----------------------------------------------------------------------------</span>
02039 <span class="comment">// RenderSystemDX9::ScreenShotJPG : void(const char *)</span>
02040 <span class="comment">//-----------------------------------------------------------------------------</span>
02041 <span class="keywordtype">void</span> RenderSystemDX9::ScreenShotJPG(<span class="keyword">const</span> <span class="keywordtype">char</span> *pJPGFileName) {
02042     ScreenShot(pJPGFileName, D3DXIFF_JPG);
02043 } <span class="comment">// RenderSystemDX9::ScreenShotJPG</span>
02044 
02045 <span class="comment">//-----------------------------------------------------------------------------</span>
02046 <span class="comment">// RenderSystemDX9::TimeOverrideEnable</span>
02047 <span class="comment">//-----------------------------------------------------------------------------</span>
02048 <span class="keywordtype">void</span> RenderSystemDX9::TimeOverrideEnable(<span class="keyword">const</span> <span class="keywordtype">float</span> secNewTime) {
02049     m_TimeIsOverridden = <span class="keyword">true</span>;
02050     m_secOverriddenTime = secNewTime;
02051 } <span class="comment">// RenderSystemDX9::TimeOverrideEnable</span>
02052 
02053 <span class="comment">//-----------------------------------------------------------------------------</span>
02054 <span class="comment">// RenderSystemDX9::TimeOverrideDisable</span>
02055 <span class="comment">//-----------------------------------------------------------------------------</span>
02056 <span class="keywordtype">void</span> RenderSystemDX9::TimeOverrideDisable() {
02057     m_TimeIsOverridden = <span class="keyword">false</span>;
02058 } <span class="comment">// RenderSystemDX9::TimeOverrideDisable</span>
02059 
02060 <span class="comment">//-----------------------------------------------------------------------------</span>
02061 <span class="comment">// RenderSystemDX9::TimeOverrideIsEnabled</span>
02062 <span class="comment">//-----------------------------------------------------------------------------</span>
02063 <span class="keywordtype">bool</span> RenderSystemDX9::TimeOverrideIsEnabled(<span class="keywordtype">float</span> *pSecTime) {
02064     <span class="keywordflow">if</span>(!m_TimeIsOverridden) {
02065         <span class="keywordflow">return</span> <span class="keyword">false</span>;
02066     }
02067     <span class="keywordflow">if</span>(pSecTime) {
02068         *pSecTime = m_secOverriddenTime;
02069     }
02070     <span class="keywordflow">return</span> <span class="keyword">true</span>;
02071 } <span class="comment">// RenderSystemDX9::TimeOverrideIsEnabled</span>
02072 
02073 <span class="comment">//-----------------------------------------------------------------------------</span>
02074 <span class="comment">// RenderSystemDX9::AntialiasingIsEnabled</span>
02075 <span class="comment">//-----------------------------------------------------------------------------</span>
02076 <span class="keywordtype">bool</span> RenderSystemDX9::AntialiasingIsEnabled() {
02077     <span class="keywordflow">return</span> m_d3dpp.MultiSampleType == m_d3dSettings.MultisampleTypeBest();
02078 } <span class="comment">// RenderSystemDX9::AntialiasingIsEnabled</span>
02079 
02080 <span class="comment">//-----------------------------------------------------------------------------</span>
02081 <span class="comment">// RenderSystemDX9::AntialiasingEnable</span>
02082 <span class="comment">//-----------------------------------------------------------------------------</span>
02083 <span class="keywordtype">void</span> RenderSystemDX9::AntialiasingEnable() {
02084     m_d3dSettings.SetMultisampleTypeToBest();
02085     m_d3dpp.MultiSampleType = m_d3dSettings.MultisampleType();
02086     Reset3DEnvironment();
02087 }<span class="comment">// RenderSystemDX9::AntialiasingEnable</span>
02088 
02089 <span class="comment">//-----------------------------------------------------------------------------</span>
02090 <span class="comment">// RenderSystemDX9::AntialiasingDisable</span>
02091 <span class="comment">//-----------------------------------------------------------------------------</span>
02092 <span class="keywordtype">void</span> RenderSystemDX9::AntialiasingDisable() {
02093     m_d3dSettings.SetMultisampleTypeToWorst();
02094     m_d3dpp.MultiSampleType = m_d3dSettings.MultisampleType();
02095     Reset3DEnvironment();
02096 } <span class="comment">// RenderSystemDX9::AntialiasingDisable</span>
02097 
02098 <span class="comment">//-----------------------------------------------------------------------------</span>
02099 <span class="comment">// RenderSystemDX9::TrueColorEnable</span>
02100 <span class="comment">//-----------------------------------------------------------------------------</span>
02101 <span class="keywordtype">void</span> RenderSystemDX9::TrueColorEnable() {
02102     m_d3dSettings.BackBufferForceTrueColorEnable();
02103     m_d3dpp.BackBufferFormat = m_d3dSettings.BackBufferFormat();
02104     Reset3DEnvironment();
02105 } <span class="comment">// RenderSystemDX9::TrueColorEnable</span>
02106 
02107 <span class="comment">//-----------------------------------------------------------------------------</span>
02108 <span class="comment">// RenderSystemDX9::TrueColorDisable</span>
02109 <span class="comment">//-----------------------------------------------------------------------------</span>
02110 <span class="keywordtype">void</span> RenderSystemDX9::TrueColorDisable() {
02111     m_d3dSettings.BackBufferForceTrueColorDisable();
02112     m_d3dpp.BackBufferFormat = m_d3dSettings.BackBufferFormat();
02113     Reset3DEnvironment();
02114 } <span class="comment">// RenderSystemDX9::TrueColorDisable</span>
02115 
02116 <span class="comment">//-----------------------------------------------------------------------------</span>
02117 <span class="comment">// RenderSystemDX9::TrueColorIsEnabled</span>
02118 <span class="comment">//-----------------------------------------------------------------------------</span>
02119 <span class="keywordtype">bool</span> RenderSystemDX9::TrueColorIsEnabled() {
02120     <span class="keywordflow">return</span> m_d3dpp.BackBufferFormat == D3DFMT_X8R8G8B8;
02121     <span class="keywordflow">return</span> <span class="keyword">false</span>;
02122 } <span class="comment">// RenderSystemDX9::TrueColorIsEnabled</span>
02123 
02124 <span class="comment">//-----------------------------------------------------------------------------------------------</span>
02125 <span class="comment">// RenderSystemDX9::GetDeviceDisplayMode</span>
02126 <span class="comment">//-----------------------------------------------------------------------------------------------</span>
02127 <span class="keywordtype">bool</span> RenderSystemDX9::GetDeviceDisplayMode(<span class="keywordtype">int</span> *pWidth, <span class="keywordtype">int</span> *pHeight, <span class="keywordtype">int</span> *pBpp, <span class="keywordtype">int</span> *pRefreshRate) {
02128     <span class="keywordflow">if</span>(!m_pDevice) <span class="keywordflow">return</span> <span class="keyword">false</span>;
02129     D3DDISPLAYMODE dm;
02130     m_pDevice-&gt;GetDisplayMode(0, &amp;dm);
02131     <span class="keywordflow">if</span>(pWidth) {
02132         *pWidth = dm.Width;
02133     }
02134     <span class="keywordflow">if</span>(pHeight) {
02135         *pHeight = dm.Height;
02136     }
02137     <span class="keywordflow">if</span>(pBpp) {
02138         <span class="keywordflow">switch</span>(dm.Format) {
02139             <span class="keywordflow">case</span> D3DFMT_A2R10G10B10:
02140             <span class="keywordflow">case</span> D3DFMT_X8R8G8B8:
02141                 *pBpp = 32;
02142                 <span class="keywordflow">break</span>;
02143             <span class="keywordflow">case</span> D3DFMT_X1R5G5B5:
02144             <span class="keywordflow">case</span> D3DFMT_R5G6B5:
02145                 *pBpp = 16;
02146                 <span class="keywordflow">break</span>;
02147             <span class="keywordflow">default</span>:
02148                 assert(0);
02149         }
02150     }
02151     <span class="keywordflow">if</span>(pRefreshRate) {
02152         *pRefreshRate = dm.RefreshRate;
02153     }
02154     <span class="keywordflow">return</span> <span class="keyword">false</span>;
02155 } <span class="comment">// RenderSystemDX9::GetDeviceDisplayMode</span>
02156 <span class="keywordtype">void</span> RenderSystemDX9::SetTextureOverride( <span class="keywordtype">int</span> TextureID,<span class="keywordtype">int</span> Stage ){
02157     assert(Stage&gt;=0 &amp;&amp; Stage&lt;8);
02158     m_TextureOverride[Stage] = TextureID;
02159 }
02160 <span class="keywordtype">int</span> RenderSystemDX9::GetTextureOverride( <span class="keywordtype">int</span> Stage ){
02161     assert(Stage&gt;=0 &amp;&amp; Stage&lt;8);
02162     <span class="keywordflow">return</span> m_TextureOverride[Stage];
02163 }
02164 <span class="keywordtype">void</span> RenderSystemDX9::SetTransparentTexOverride( <span class="keywordtype">int</span> Stage ){
02165     <span class="keyword">static</span> <span class="keywordtype">int</span> texid=-1;
02166     <span class="keywordflow">if</span>(texid==-1){
02167         texid = CreateTexture(<span class="stringliteral">"transtex"</span>,2,2,cfARGB4444);
02168         <span class="keywordtype">int</span> Pitch;
02169         BYTE* ptr = IRS-&gt;LockTexBits(texid,Pitch);
02170         <span class="keywordflow">if</span>( ptr ){
02171             memset(ptr,0,Pitch*2);
02172             IRS-&gt;UnlockTexBits( texid );
02173         }
02174     }
02175     SetTextureOverride( texid,Stage );
02176 }
02177 
02178 <span class="comment">//-----------------------------------------------------------------------------</span>
02179 <span class="comment">// RenderSystemDX9::RefreshRateOverrideEnable</span>
02180 <span class="comment">//-----------------------------------------------------------------------------</span>
02181 <span class="keywordtype">void</span> RenderSystemDX9::RefreshRateOverrideEnable(<span class="keyword">const</span> <span class="keywordtype">int</span> Hz) {
02182     m_RefreshRateIsOverridden = <span class="keyword">true</span>;
02183     m_HzOverriddenRefreshRate = Hz;
02184 <span class="comment">//  m_HzDefaultRefreshRate = m_d3dSettings.Fullscreen_DisplayMode.RefreshRate;</span>
02185 <span class="comment">//  m_d3dSettings.Fullscreen_DisplayMode.RefreshRate = Hz;</span>
02186 <span class="comment">//  m_d3dSettings.Windowed_DisplayMode.RefreshRate = Hz;</span>
02187     Reset3DEnvironment();
02188 } <span class="comment">// RenderSystemDX9::RefreshRateOverrideEnable</span>
02189 
02190 <span class="comment">//-----------------------------------------------------------------------------</span>
02191 <span class="comment">// RenderSystemDX9::RefreshRateOverrideDisable</span>
02192 <span class="comment">//-----------------------------------------------------------------------------</span>
02193 <span class="keywordtype">void</span> RenderSystemDX9::RefreshRateOverrideDisable() {
02194     <span class="keywordflow">if</span>(!m_RefreshRateIsOverridden) <span class="keywordflow">return</span>;
02195 <span class="comment">//  m_d3dSettings.Fullscreen_DisplayMode.RefreshRate = m_HzDefaultRefreshRate;</span>
02196 <span class="comment">//  m_d3dSettings.Windowed_DisplayMode.RefreshRate = m_HzDefaultRefreshRate;</span>
02197     m_RefreshRateIsOverridden = <span class="keyword">false</span>;
02198     Reset3DEnvironment();
02199 } <span class="comment">// RenderSystemDX9::RefreshRateOverrideDisable</span>
02200 
02201 <span class="comment">//-----------------------------------------------------------------------------</span>
02202 <span class="comment">// RenderSystemDX9::RefreshRateOverrideIsEnabled</span>
02203 <span class="comment">//-----------------------------------------------------------------------------</span>
02204 <span class="keywordtype">bool</span> RenderSystemDX9::RefreshRateOverrideIsEnabled(<span class="keywordtype">int</span> *pHz) {
02205     <span class="keywordflow">if</span>(!m_RefreshRateIsOverridden) {
02206         <span class="keywordflow">return</span> <span class="keyword">false</span>;
02207     }
02208     <span class="keywordflow">if</span>(pHz) {
02209         *pHz = m_HzOverriddenRefreshRate;
02210     }
02211     <span class="keywordflow">return</span> <span class="keyword">true</span>;
02212 } <span class="comment">// RenderSystemDX9::RefreshRateOverrideIsEnabled</span>
</pre></div><hr><address style="align: right;"><small>
Generated on Tue Jun 13 11:14:33 2006 for gRenderDX9 by <a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 width=110 height=53>
</a> 1.3.1 using KingsTools</small></address>
</body>
</html>
