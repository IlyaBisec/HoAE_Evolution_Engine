<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gRenderDX9: d3dEnumeration.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.1 -->
<h1>d3dEnumeration.cpp</h1><div class="fragment"><pre>00001 <span class="comment">//-----------------------------------------------------------------------------</span>
00002 <span class="comment">// File: D3DEnumeration.cpp</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// Desc: Enumerates D3D adapters, devices, modes, etc.</span>
00005 <span class="comment">//</span>
00006 <span class="comment">// Copyright (c) Microsoft Corporation. All rights reserved.</span>
00007 <span class="comment">//-----------------------------------------------------------------------------</span>
00008 <span class="preprocessor">#include "gRenderPch.h"</span>
00009 
00010 <span class="comment">//-----------------------------------------------------------------------------</span>
00011 <span class="comment">// Name: ColorChannelBits</span>
00012 <span class="comment">// Desc: Returns the number of color channel bits in the specified D3DFORMAT</span>
00013 <span class="comment">//-----------------------------------------------------------------------------</span>
00014 <span class="keyword">static</span> UINT ColorChannelBits( D3DFORMAT fmt )
00015 {
00016     <span class="keywordflow">switch</span>( fmt )
00017     {
00018         <span class="keywordflow">case</span> D3DFMT_R8G8B8:         <span class="keywordflow">return</span> 8;
00019         <span class="keywordflow">case</span> D3DFMT_A8R8G8B8:       <span class="keywordflow">return</span> 8;
00020         <span class="keywordflow">case</span> D3DFMT_X8R8G8B8:       <span class="keywordflow">return</span> 8;
00021         <span class="keywordflow">case</span> D3DFMT_R5G6B5:         <span class="keywordflow">return</span> 5;
00022         <span class="keywordflow">case</span> D3DFMT_X1R5G5B5:       <span class="keywordflow">return</span> 5;
00023         <span class="keywordflow">case</span> D3DFMT_A1R5G5B5:       <span class="keywordflow">return</span> 5;
00024         <span class="keywordflow">case</span> D3DFMT_A4R4G4B4:       <span class="keywordflow">return</span> 4;
00025         <span class="keywordflow">case</span> D3DFMT_R3G3B2:         <span class="keywordflow">return</span> 2;
00026         <span class="keywordflow">case</span> D3DFMT_A8R3G3B2:       <span class="keywordflow">return</span> 2;
00027         <span class="keywordflow">case</span> D3DFMT_X4R4G4B4:       <span class="keywordflow">return</span> 4;
00028         <span class="keywordflow">case</span> D3DFMT_A2B10G10R10:    <span class="keywordflow">return</span> 10;
00029         <span class="keywordflow">case</span> D3DFMT_A2R10G10B10:    <span class="keywordflow">return</span> 10;
00030         <span class="keywordflow">default</span>:                    <span class="keywordflow">return</span> 0;
00031     }
00032 } <span class="comment">// ColorChannelBits</span>
00033 
00034 <span class="comment">//-----------------------------------------------------------------------------</span>
00035 <span class="comment">// Name: AlphaChannelBits</span>
00036 <span class="comment">// Desc: Returns the number of alpha channel bits in the specified D3DFORMAT</span>
00037 <span class="comment">//-----------------------------------------------------------------------------</span>
00038 <span class="keyword">static</span> UINT AlphaChannelBits( D3DFORMAT fmt )
00039 {
00040     <span class="keywordflow">switch</span>( fmt )
00041     {
00042         <span class="keywordflow">case</span> D3DFMT_R8G8B8:          <span class="keywordflow">return</span> 0;
00043         <span class="keywordflow">case</span> D3DFMT_A8R8G8B8:       <span class="keywordflow">return</span> 8;
00044         <span class="keywordflow">case</span> D3DFMT_X8R8G8B8:       <span class="keywordflow">return</span> 0;
00045         <span class="keywordflow">case</span> D3DFMT_R5G6B5:         <span class="keywordflow">return</span> 0;
00046         <span class="keywordflow">case</span> D3DFMT_X1R5G5B5:       <span class="keywordflow">return</span> 0;
00047         <span class="keywordflow">case</span> D3DFMT_A1R5G5B5:       <span class="keywordflow">return</span> 1;
00048         <span class="keywordflow">case</span> D3DFMT_A4R4G4B4:       <span class="keywordflow">return</span> 4;
00049         <span class="keywordflow">case</span> D3DFMT_R3G3B2:         <span class="keywordflow">return</span> 0;
00050         <span class="keywordflow">case</span> D3DFMT_A8R3G3B2:       <span class="keywordflow">return</span> 8;
00051         <span class="keywordflow">case</span> D3DFMT_X4R4G4B4:       <span class="keywordflow">return</span> 0;
00052         <span class="keywordflow">case</span> D3DFMT_A2B10G10R10:    <span class="keywordflow">return</span> 2;
00053         <span class="keywordflow">case</span> D3DFMT_A2R10G10B10:    <span class="keywordflow">return</span> 2;
00054         <span class="keywordflow">default</span>:                    <span class="keywordflow">return</span> 0;
00055     }
00056 } <span class="comment">// AlphaChannelBits</span>
00057 
00058 <span class="comment">//-----------------------------------------------------------------------------</span>
00059 <span class="comment">// Name: DepthBits</span>
00060 <span class="comment">// Desc: Returns the number of depth bits in the specified D3DFORMAT</span>
00061 <span class="comment">//-----------------------------------------------------------------------------</span>
00062 <span class="keyword">static</span> UINT DepthBits( D3DFORMAT fmt )
00063 {
00064     <span class="keywordflow">switch</span>( fmt )
00065     {
00066         <span class="keywordflow">case</span> D3DFMT_D16:        <span class="keywordflow">return</span> 16;
00067         <span class="keywordflow">case</span> D3DFMT_D15S1:      <span class="keywordflow">return</span> 15;
00068         <span class="keywordflow">case</span> D3DFMT_D24X8:      <span class="keywordflow">return</span> 24;
00069         <span class="keywordflow">case</span> D3DFMT_D24S8:      <span class="keywordflow">return</span> 24;
00070         <span class="keywordflow">case</span> D3DFMT_D24X4S4:    <span class="keywordflow">return</span> 24;
00071         <span class="keywordflow">case</span> D3DFMT_D32:        <span class="keywordflow">return</span> 32;
00072         <span class="keywordflow">default</span>:                <span class="keywordflow">return</span> 0;
00073     }
00074 } <span class="comment">// DepthBits</span>
00075 
00076 <span class="comment">//-----------------------------------------------------------------------------</span>
00077 <span class="comment">// Name: StencilBits</span>
00078 <span class="comment">// Desc: Returns the number of stencil bits in the specified D3DFORMAT</span>
00079 <span class="comment">//-----------------------------------------------------------------------------</span>
00080 <span class="keyword">static</span> UINT StencilBits( D3DFORMAT fmt )
00081 {
00082     <span class="keywordflow">switch</span>( fmt )
00083     {
00084         <span class="keywordflow">case</span> D3DFMT_D16:        <span class="keywordflow">return</span> 0;
00085         <span class="keywordflow">case</span> D3DFMT_D15S1:      <span class="keywordflow">return</span> 1;
00086         <span class="keywordflow">case</span> D3DFMT_D24X8:      <span class="keywordflow">return</span> 0;
00087         <span class="keywordflow">case</span> D3DFMT_D24S8:      <span class="keywordflow">return</span> 8;
00088         <span class="keywordflow">case</span> D3DFMT_D24X4S4:    <span class="keywordflow">return</span> 4;
00089         <span class="keywordflow">case</span> D3DFMT_D32:        <span class="keywordflow">return</span> 0;
00090         <span class="keywordflow">default</span>:                <span class="keywordflow">return</span> 0;
00091     }
00092 } <span class="comment">// StencilBits</span>
00093 
00094 <span class="comment">//-----------------------------------------------------------------------------</span>
00095 <span class="comment">// Name: D3DEnumeration constructor</span>
00096 <span class="comment">// Desc: </span>
00097 <span class="comment">//-----------------------------------------------------------------------------</span>
00098 D3DEnumeration::D3DEnumeration()
00099 {
00100     m_AppMinFullscreenWidth     = 640;
00101     m_AppMinFullscreenHeight    = 480;
00102     m_AppMinColorChannelBits    = 5;
00103     m_AppMinAlphaChannelBits    = 0;
00104     m_AppMinDepthBits           = 15;
00105     m_AppMinStencilBits         = 0;
00106     m_bUseZBuffer               = <span class="keyword">false</span>;
00107     m_bAppUsesMixedVP           = <span class="keyword">false</span>;
00108     m_bAppRequiresWindowed      = <span class="keyword">false</span>;
00109     m_bAppRequiresFullscreen    = <span class="keyword">false</span>;
00110 } <span class="comment">// D3DEnumeration::D3DEnumeration</span>
00111 
00112 <span class="comment">//-----------------------------------------------------------------------------</span>
00113 <span class="comment">// Name: SortModesCallback</span>
00114 <span class="comment">// Desc: Used to sort D3DDISPLAYMODEs</span>
00115 <span class="comment">//-----------------------------------------------------------------------------</span>
00116 <span class="keyword">static</span> <span class="keywordtype">int</span> __cdecl SortModesCallback( <span class="keyword">const</span> <span class="keywordtype">void</span>* arg1, <span class="keyword">const</span> <span class="keywordtype">void</span>* arg2 )
00117 {
00118     D3DDISPLAYMODE* pdm1 = (D3DDISPLAYMODE*)arg1;
00119     D3DDISPLAYMODE* pdm2 = (D3DDISPLAYMODE*)arg2;
00120 
00121     <span class="keywordflow">if</span> (pdm1-&gt;Width &gt; pdm2-&gt;Width)              <span class="keywordflow">return</span>  1;
00122     <span class="keywordflow">if</span> (pdm1-&gt;Width &lt; pdm2-&gt;Width)              <span class="keywordflow">return</span> -1;
00123     <span class="keywordflow">if</span> (pdm1-&gt;Height &gt; pdm2-&gt;Height)            <span class="keywordflow">return</span>  1;
00124     <span class="keywordflow">if</span> (pdm1-&gt;Height &lt; pdm2-&gt;Height)            <span class="keywordflow">return</span> -1;
00125     <span class="keywordflow">if</span> (pdm1-&gt;Format &gt; pdm2-&gt;Format)            <span class="keywordflow">return</span>  1;
00126     <span class="keywordflow">if</span> (pdm1-&gt;Format &lt; pdm2-&gt;Format)            <span class="keywordflow">return</span> -1;
00127     <span class="keywordflow">if</span> (pdm1-&gt;RefreshRate &gt; pdm2-&gt;RefreshRate)  <span class="keywordflow">return</span>  1;
00128     <span class="keywordflow">if</span> (pdm1-&gt;RefreshRate &lt; pdm2-&gt;RefreshRate)  <span class="keywordflow">return</span> -1;
00129     <span class="keywordflow">return</span> 0;
00130 } <span class="comment">// SortModesCallback</span>
00131 
00132 <span class="comment">//-----------------------------------------------------------------------------</span>
00133 <span class="comment">// Name: Enumerate</span>
00134 <span class="comment">// Desc: Enumerates available D3D adapters, devices, modes, etc.</span>
00135 <span class="comment">//-----------------------------------------------------------------------------</span>
00136 HRESULT D3DEnumeration::Enumerate()
00137 {
00138     HRESULT                 hr;
00139     std::vector&lt;D3DFORMAT&gt;  adapterFormatList;
00140 
00141     <span class="keywordflow">if</span> (m_pD3D == NULL) <span class="keywordflow">return</span> E_FAIL;
00142     
00143     m_AllowedFormats.push_back( D3DFMT_X8R8G8B8     );
00144     m_AllowedFormats.push_back( D3DFMT_X1R5G5B5     );
00145     m_AllowedFormats.push_back( D3DFMT_R5G6B5       );
00146     m_AllowedFormats.push_back( D3DFMT_A2R10G10B10  );
00147 
00148     UINT numAdapters = m_pD3D-&gt;GetAdapterCount();
00149     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m_Ordinal = 0; m_Ordinal &lt; numAdapters; m_Ordinal++)
00150     {
00151         D3DAdapterInfo adapterInfo;
00152         adapterInfo.m_Ordinal = m_Ordinal;
00153         m_pD3D-&gt;GetAdapterIdentifier( m_Ordinal, 0, &amp;adapterInfo.m_Identifier );
00154 
00155         <span class="comment">// Get list of all display modes on this adapter.  </span>
00156         <span class="comment">// Also build a temporary list of all display adapter formats.</span>
00157         adapterFormatList.clear();
00158         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_AllowedFormats.size(); i++ )
00159         {
00160             D3DFORMAT allowedAdapterFormat = m_AllowedFormats[i];
00161             UINT numAdapterModes = m_pD3D-&gt;GetAdapterModeCount( m_Ordinal, allowedAdapterFormat );
00162             <span class="keywordflow">for</span> (UINT mode = 0; mode &lt; numAdapterModes; mode++)
00163             {
00164                 D3DDISPLAYMODE displayMode;
00165                 m_pD3D-&gt;EnumAdapterModes( m_Ordinal, allowedAdapterFormat, mode, &amp;displayMode );
00166                 <span class="keywordflow">if</span>( displayMode.Width &lt; m_AppMinFullscreenWidth ||
00167                     displayMode.Height &lt; m_AppMinFullscreenHeight ||
00168                     ColorChannelBits(displayMode.Format) &lt; m_AppMinColorChannelBits )
00169                 {
00170                     <span class="keywordflow">continue</span>;
00171                 }
00172                 adapterInfo.m_DisplayModes.push_back( displayMode );
00173                 <span class="keywordtype">int</span> nF = adapterFormatList.size();
00174                 <span class="keywordtype">bool</span> bPresent = <span class="keyword">false</span>;
00175                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; adapterFormatList.size(); j++)
00176                     <span class="keywordflow">if</span> (adapterFormatList[j] == displayMode.Format) bPresent = <span class="keyword">true</span>;
00177                 <span class="keywordflow">if</span> (!bPresent) adapterFormatList.push_back( displayMode.Format );
00178             }
00179         }
00180 
00181         <span class="comment">// Sort displaymode list</span>
00182         qsort( &amp;adapterInfo.m_DisplayModes[0], adapterInfo.m_DisplayModes.size(), <span class="keyword">sizeof</span>( D3DDISPLAYMODE ),SortModesCallback );
00183 
00184         <span class="comment">// Get info for each device on this adapter</span>
00185         <span class="keywordflow">if</span>( FAILED( hr = EnumerateDevices( &amp;adapterInfo, adapterFormatList ) ) )
00186         {
00187             <span class="keywordflow">return</span> hr;
00188         }
00189 
00190         <span class="comment">// If at least one device on this adapter is available and compatible</span>
00191         <span class="comment">// with the app, add the adapterInfo to the list</span>
00192         <span class="keywordflow">if</span> (adapterInfo.m_DevInfos.size() != 0) m_AdapterInfoList.push_back( adapterInfo );
00193     }
00194     <span class="keywordflow">return</span> S_OK;
00195 } <span class="comment">// D3DEnumeration::Enumerate</span>
00196 
00197 <span class="comment">//-----------------------------------------------------------------------------</span>
00198 <span class="comment">// Name: EnumerateDevices</span>
00199 <span class="comment">// Desc: Enumerates D3D devices for a particular adapter.</span>
00200 <span class="comment">//-----------------------------------------------------------------------------</span>
00201 HRESULT D3DEnumeration::EnumerateDevices( D3DAdapterInfo* pAdapterInfo, 
00202                                           std::vector&lt;D3DFORMAT&gt;&amp; adapterFormatList )
00203 {
00204     <span class="keyword">const</span> D3DDEVTYPE devTypeArray[] = { D3DDEVTYPE_HAL, D3DDEVTYPE_SW, D3DDEVTYPE_REF };
00205     <span class="keyword">const</span> UINT devTypeArrayCount = <span class="keyword">sizeof</span>(devTypeArray) / <span class="keyword">sizeof</span>(devTypeArray[0]);
00206     HRESULT hr;
00207 
00208     D3DDeviceInfo devInfo;
00209     <span class="keywordflow">for</span>( UINT idt = 0; idt &lt; devTypeArrayCount; idt++ )
00210     {
00211         devInfo.m_Ordinal = pAdapterInfo-&gt;m_Ordinal;
00212         devInfo.m_DevType = devTypeArray[idt];
00213         <span class="keywordflow">if</span>( FAILED( m_pD3D-&gt;GetDeviceCaps( pAdapterInfo-&gt;m_Ordinal, 
00214             devInfo.m_DevType, &amp;devInfo.m_Caps ) ) ) <span class="keywordflow">continue</span>;
00215         <span class="comment">// Get info for each devicecombo on this device</span>
00216         <span class="keywordflow">if</span>( FAILED( hr = EnumerateDeviceCombos( &amp;devInfo, adapterFormatList ) ) ) <span class="keywordflow">return</span> hr;
00217         <span class="comment">// If at least one devicecombo for this device is found, </span>
00218         <span class="comment">// add the deviceInfo to the list</span>
00219         <span class="keywordflow">if</span> (devInfo.m_DevCombos.size() == 0) <span class="keywordflow">continue</span>;
00220         pAdapterInfo-&gt;m_DevInfos.push_back( devInfo );
00221     }
00222     <span class="keywordflow">return</span> S_OK;
00223 } <span class="comment">// D3DEnumeration::EnumerateDevices</span>
00224 
00225 <span class="comment">//-----------------------------------------------------------------------------</span>
00226 <span class="comment">// Name: EnumerateDeviceCombos</span>
00227 <span class="comment">// Desc: Enumerates DeviceCombos for a particular device.</span>
00228 <span class="comment">//-----------------------------------------------------------------------------</span>
00229 HRESULT D3DEnumeration::EnumerateDeviceCombos( D3DDeviceInfo* pDeviceInfo, std::vector&lt;D3DFORMAT&gt;&amp; adapterFormatList )
00230 {
00231     <span class="keyword">const</span> D3DFORMAT backBufferFormats[] = { D3DFMT_A8R8G8B8, D3DFMT_X8R8G8B8, D3DFMT_A2R10G10B10, 
00232                                             D3DFMT_R5G6B5, D3DFMT_A1R5G5B5, D3DFMT_X1R5G5B5 };
00233     <span class="keyword">const</span> UINT nBackBufferFormats = <span class="keyword">sizeof</span>(backBufferFormats) / <span class="keyword">sizeof</span>(backBufferFormats[0]);
00234     <span class="keywordtype">bool</span> bIsWindowed[] = { <span class="keyword">false</span>, <span class="keyword">true</span> };
00235 
00236     <span class="comment">// See which adapter formats are supported by this device</span>
00237     D3DFORMAT adapterFormat;
00238     <span class="keywordflow">for</span> (UINT iaf = 0; iaf &lt; adapterFormatList.size(); iaf++)
00239     {
00240         adapterFormat = adapterFormatList[iaf];
00241         D3DFORMAT backBufferFormat;
00242         <span class="keywordflow">for</span>( UINT ibbf = 0; ibbf &lt; nBackBufferFormats; ibbf++ )
00243         {
00244             backBufferFormat = backBufferFormats[ibbf];
00245             <span class="keywordflow">if</span> (AlphaChannelBits(backBufferFormat) &lt; m_AppMinAlphaChannelBits) <span class="keywordflow">continue</span>;
00246             <span class="keywordtype">bool</span> isWindowed;
00247             <span class="keywordflow">for</span>( UINT iiw = 0; iiw &lt; 2; iiw++)
00248             {
00249                 isWindowed = bIsWindowed[iiw];
00250                 <span class="keywordflow">if</span> (!isWindowed &amp;&amp; m_bAppRequiresWindowed)
00251                     <span class="keywordflow">continue</span>;
00252                 <span class="keywordflow">if</span> (isWindowed &amp;&amp; m_bAppRequiresFullscreen)
00253                     <span class="keywordflow">continue</span>;
00254                 <span class="keywordflow">if</span> (FAILED(m_pD3D-&gt;CheckDeviceType( pDeviceInfo-&gt;m_Ordinal, pDeviceInfo-&gt;m_DevType, 
00255                     adapterFormat, backBufferFormat, isWindowed )))
00256                 {
00257                     <span class="keywordflow">continue</span>;
00258                 }
00259                 <span class="comment">// At this point, we have an adapter/device/adapterformat/backbufferformat/iswindowed</span>
00260                 <span class="comment">// DeviceCombo that is supported by the system.  We still need to confirm that it's </span>
00261                 <span class="comment">// compatible with the app, and find one or more suitable depth/stencil buffer format,</span>
00262                 <span class="comment">// multisample type, vertex processing type, and present interval.</span>
00263                 D3DDeviceCombo devCombo;
00264                 devCombo.m_Ordinal          = pDeviceInfo-&gt;m_Ordinal;
00265                 devCombo.m_DevType          = pDeviceInfo-&gt;m_DevType;
00266                 devCombo.m_AdapterFormat    = adapterFormat;
00267                 devCombo.m_BackBufferFormat = backBufferFormat;
00268                 devCombo.m_bIsWindowed      = isWindowed;
00269                 <span class="keywordflow">if</span> (m_bUseZBuffer)
00270                 {
00271                     BuildDepthStencilFormatList( &amp;devCombo );
00272                     <span class="keywordflow">if</span> (devCombo.m_DepthStencilFormats.size() == 0) <span class="keywordflow">continue</span>;
00273                 }
00274                 BuildMultiSampleTypeList( &amp;devCombo );
00275                 <span class="keywordflow">if</span> (devCombo.m_MSampleTypes.size() == 0) <span class="keywordflow">continue</span>;
00276                 BuildDSMSConflictList( &amp;devCombo );
00277                 BuildVertexProcessingTypeList( pDeviceInfo, &amp;devCombo );
00278                 <span class="keywordflow">if</span> (devCombo.m_VProcessTypes.size() == 0) <span class="keywordflow">continue</span>;
00279                 BuildPresentIntervalList( pDeviceInfo, &amp;devCombo );
00280                 pDeviceInfo-&gt;m_DevCombos.push_back( devCombo );
00281             }
00282         }
00283     }
00284     <span class="keywordflow">return</span> S_OK;
00285 } <span class="comment">// D3DEnumeration::EnumerateDeviceCombos</span>
00286 
00287 <span class="comment">//-----------------------------------------------------------------------------</span>
00288 <span class="comment">// Name: BuildDepthStencilFormatList</span>
00289 <span class="comment">// Desc: Adds all depth/stencil formats that are compatible with the device </span>
00290 <span class="comment">//       and app to the given D3DDeviceCombo.</span>
00291 <span class="comment">//-----------------------------------------------------------------------------</span>
00292 <span class="keywordtype">void</span> D3DEnumeration::BuildDepthStencilFormatList( D3DDeviceCombo* pDeviceCombo )
00293 {
00294     <span class="keyword">const</span> D3DFORMAT dsFormats[] = 
00295     {
00296         D3DFMT_D16,
00297         D3DFMT_D15S1,
00298         D3DFMT_D24X8,
00299         D3DFMT_D24S8,
00300         D3DFMT_D24X4S4,
00301         D3DFMT_D32,
00302     };
00303     <span class="keyword">const</span> UINT nDsFormats = <span class="keyword">sizeof</span>(dsFormats) / <span class="keyword">sizeof</span>(dsFormats[0]);
00304 
00305     D3DFORMAT depthStencilFmt;
00306     <span class="keywordflow">for</span>( UINT idsf = 0; idsf &lt; nDsFormats; idsf++ )
00307     {
00308         depthStencilFmt = dsFormats[idsf];
00309         <span class="keywordflow">if</span> (DepthBits(depthStencilFmt) &lt; m_AppMinDepthBits)
00310             <span class="keywordflow">continue</span>;
00311         <span class="keywordflow">if</span> (StencilBits(depthStencilFmt) &lt; m_AppMinStencilBits)
00312             <span class="keywordflow">continue</span>;
00313         <span class="keywordflow">if</span> (SUCCEEDED(m_pD3D-&gt;CheckDeviceFormat(pDeviceCombo-&gt;m_Ordinal, 
00314                                 pDeviceCombo-&gt;m_DevType, pDeviceCombo-&gt;m_AdapterFormat, 
00315                                 D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, depthStencilFmt)))
00316         {
00317             <span class="keywordflow">if</span> (SUCCEEDED( m_pD3D-&gt;CheckDepthStencilMatch(pDeviceCombo-&gt;m_Ordinal, 
00318                             pDeviceCombo-&gt;m_DevType, pDeviceCombo-&gt;m_AdapterFormat, 
00319                             pDeviceCombo-&gt;m_BackBufferFormat, depthStencilFmt )))
00320             {
00321                 pDeviceCombo-&gt;m_DepthStencilFormats.push_back( depthStencilFmt );
00322             }
00323         }
00324     }
00325 } <span class="comment">// D3DEnumeration::BuildDepthStencilFormatList</span>
00326 
00327 <span class="comment">//-----------------------------------------------------------------------------</span>
00328 <span class="comment">// Name: BuildMultiSampleTypeList</span>
00329 <span class="comment">// Desc: Adds all multisample types that are compatible with the device and app to</span>
00330 <span class="comment">//       the given D3DDeviceCombo.</span>
00331 <span class="comment">//-----------------------------------------------------------------------------</span>
00332 <span class="keywordtype">void</span> D3DEnumeration::BuildMultiSampleTypeList( D3DDeviceCombo* pDeviceCombo )
00333 {
00334     <span class="keyword">const</span> D3DMULTISAMPLE_TYPE msTypeArray[] = 
00335     { 
00336         D3DMULTISAMPLE_NONE,
00337         D3DMULTISAMPLE_NONMASKABLE,
00338         D3DMULTISAMPLE_2_SAMPLES,
00339         D3DMULTISAMPLE_3_SAMPLES,
00340         D3DMULTISAMPLE_4_SAMPLES,
00341         D3DMULTISAMPLE_5_SAMPLES,
00342         D3DMULTISAMPLE_6_SAMPLES,
00343         D3DMULTISAMPLE_7_SAMPLES,
00344         D3DMULTISAMPLE_8_SAMPLES,
00345         D3DMULTISAMPLE_9_SAMPLES,
00346         D3DMULTISAMPLE_10_SAMPLES,
00347         D3DMULTISAMPLE_11_SAMPLES,
00348         D3DMULTISAMPLE_12_SAMPLES,
00349         D3DMULTISAMPLE_13_SAMPLES,
00350         D3DMULTISAMPLE_14_SAMPLES,
00351         D3DMULTISAMPLE_15_SAMPLES,
00352         D3DMULTISAMPLE_16_SAMPLES,
00353     };
00354     <span class="keyword">const</span> UINT msTypeArrayCount = <span class="keyword">sizeof</span>(msTypeArray) / <span class="keyword">sizeof</span>(msTypeArray[0]);
00355 
00356     D3DMULTISAMPLE_TYPE msType;
00357     DWORD msQuality;
00358     <span class="keywordflow">for</span>( UINT imst = 0; imst &lt; msTypeArrayCount; imst++ )
00359     {
00360         msType = msTypeArray[imst];
00361         <span class="keywordflow">if</span> (SUCCEEDED(m_pD3D-&gt;CheckDeviceMultiSampleType(   pDeviceCombo-&gt;m_Ordinal, 
00362                                                             pDeviceCombo-&gt;m_DevType, 
00363                                                             pDeviceCombo-&gt;m_BackBufferFormat, 
00364                                                             pDeviceCombo-&gt;m_bIsWindowed, 
00365                                                             msType, 
00366                                                             &amp;msQuality ) ))
00367         {
00368             pDeviceCombo-&gt;m_MSampleTypes.push_back( msType );
00369             pDeviceCombo-&gt;m_MSampleQualities.push_back( msQuality );
00370         }
00371     }
00372 } <span class="comment">// D3DEnumeration::BuildMultiSampleTypeList</span>
00373 
00374 <span class="comment">//-----------------------------------------------------------------------------</span>
00375 <span class="comment">// Name: BuildDSMSConflictList</span>
00376 <span class="comment">// Desc: Find any conflicts between the available depth/stencil formats and</span>
00377 <span class="comment">//       multisample types.</span>
00378 <span class="comment">//-----------------------------------------------------------------------------</span>
00379 <span class="keywordtype">void</span> D3DEnumeration::BuildDSMSConflictList( D3DDeviceCombo* pDeviceCombo )
00380 {
00381     D3DDSMSConflict DSMSConflict;
00382 
00383     <span class="keywordflow">for</span>( UINT i = 0; i &lt; pDeviceCombo-&gt;m_DepthStencilFormats.size(); i++ )
00384     {
00385         D3DFORMAT dsFmt = pDeviceCombo-&gt;m_DepthStencilFormats[i];
00386         <span class="keywordflow">for</span>( UINT j = 0; j &lt; pDeviceCombo-&gt;m_MSampleTypes.size(); j++ )
00387         {
00388             D3DMULTISAMPLE_TYPE msType = pDeviceCombo-&gt;m_MSampleTypes[j];
00389             <span class="keywordflow">if</span>( FAILED( m_pD3D-&gt;CheckDeviceMultiSampleType( pDeviceCombo-&gt;m_Ordinal, pDeviceCombo-&gt;m_DevType,
00390                 dsFmt, pDeviceCombo-&gt;m_bIsWindowed, msType, NULL ) ) )
00391             {
00392                 DSMSConflict.m_DSFormat = dsFmt;
00393                 DSMSConflict.m_MSType = msType;
00394                 pDeviceCombo-&gt;m_DSMSConflicts.push_back( DSMSConflict );
00395             }
00396         }
00397     }
00398 } <span class="comment">// D3DEnumeration::BuildDSMSConflictList</span>
00399 
00400 <span class="comment">//-----------------------------------------------------------------------------</span>
00401 <span class="comment">// Name: BuildVertexProcessingTypeList</span>
00402 <span class="comment">// Desc: Adds all vertex processing types that are compatible with the device </span>
00403 <span class="comment">//       and app to the given D3DDeviceCombo.</span>
00404 <span class="comment">//-----------------------------------------------------------------------------</span>
00405 <span class="keywordtype">void</span> D3DEnumeration::BuildVertexProcessingTypeList( D3DDeviceInfo* pDeviceInfo, D3DDeviceCombo* pDeviceCombo )
00406 {
00407     VertexProcessingType vpt;
00408     <span class="keywordflow">if</span> ((pDeviceInfo-&gt;m_Caps.DevCaps &amp; D3DDEVCAPS_HWTRANSFORMANDLIGHT) != 0)
00409     {
00410         <span class="keywordflow">if</span> ((pDeviceInfo-&gt;m_Caps.DevCaps &amp; D3DDEVCAPS_PUREDEVICE) != 0)
00411         {
00412             <span class="keywordflow">if</span> (ConfirmDevice == NULL ||
00413                 ConfirmDevice( &amp;pDeviceInfo-&gt;m_Caps, vpPureHardware, 
00414                 pDeviceCombo-&gt;m_AdapterFormat, pDeviceCombo-&gt;m_BackBufferFormat))
00415             {
00416                 vpt = vpPureHardware;
00417                 pDeviceCombo-&gt;m_VProcessTypes.push_back( vpt );
00418             }
00419         }
00420         <span class="keywordflow">if</span> (ConfirmDevice == NULL ||
00421             ConfirmDevice(&amp;pDeviceInfo-&gt;m_Caps, vpHardware, 
00422             pDeviceCombo-&gt;m_AdapterFormat, pDeviceCombo-&gt;m_BackBufferFormat))
00423         {
00424             vpt = vpHardware;
00425             pDeviceCombo-&gt;m_VProcessTypes.push_back( vpt );
00426         }
00427         <span class="keywordflow">if</span> (m_bAppUsesMixedVP &amp;&amp; (ConfirmDevice == NULL ||
00428             ConfirmDevice(&amp;pDeviceInfo-&gt;m_Caps, vpMixed, 
00429             pDeviceCombo-&gt;m_AdapterFormat, pDeviceCombo-&gt;m_BackBufferFormat)))
00430         {
00431             vpt = vpMixed;
00432             pDeviceCombo-&gt;m_VProcessTypes.push_back( vpt );
00433         }
00434     }
00435     <span class="keywordflow">if</span> (ConfirmDevice == NULL || ConfirmDevice(&amp;pDeviceInfo-&gt;m_Caps, vpSoftware, 
00436         pDeviceCombo-&gt;m_AdapterFormat, pDeviceCombo-&gt;m_BackBufferFormat))
00437     {
00438         vpt = vpSoftware;
00439         pDeviceCombo-&gt;m_VProcessTypes.push_back( vpt );
00440     }
00441 } <span class="comment">// D3DEnumeration::BuildVertexProcessingTypeList</span>
00442 
00443 <span class="comment">//-----------------------------------------------------------------------------</span>
00444 <span class="comment">// Name: BuildPresentIntervalList</span>
00445 <span class="comment">// Desc: Adds all present intervals that are compatible with the device and app </span>
00446 <span class="comment">//       to the given D3DDeviceCombo.</span>
00447 <span class="comment">//-----------------------------------------------------------------------------</span>
00448 <span class="keywordtype">void</span> D3DEnumeration::BuildPresentIntervalList( D3DDeviceInfo* pDeviceInfo, D3DDeviceCombo* pDeviceCombo )
00449 {
00450     <span class="keyword">const</span> UINT piArray[] = { 
00451         D3DPRESENT_INTERVAL_IMMEDIATE,
00452         D3DPRESENT_INTERVAL_DEFAULT,
00453         D3DPRESENT_INTERVAL_ONE,
00454         D3DPRESENT_INTERVAL_TWO,
00455         D3DPRESENT_INTERVAL_THREE,
00456         D3DPRESENT_INTERVAL_FOUR,
00457     };
00458     <span class="keyword">const</span> UINT piArrayCount = <span class="keyword">sizeof</span>(piArray) / <span class="keyword">sizeof</span>(piArray[0]);
00459 
00460     UINT pi;
00461     <span class="keywordflow">for</span>( UINT ipi = 0; ipi &lt; piArrayCount; ipi++ )
00462     {
00463         pi = piArray[ipi];
00464         <span class="keywordflow">if</span>( pDeviceCombo-&gt;m_bIsWindowed )
00465         {
00466             <span class="keywordflow">if</span>( pi == D3DPRESENT_INTERVAL_TWO ||
00467                 pi == D3DPRESENT_INTERVAL_THREE ||
00468                 pi == D3DPRESENT_INTERVAL_FOUR )
00469             {
00470                 <span class="comment">// These intervals are not supported in windowed mode.</span>
00471                 <span class="keywordflow">continue</span>;
00472             }
00473         }
00474         <span class="comment">// Note that D3DPRESENT_INTERVAL_DEFAULT is zero, so you</span>
00475         <span class="comment">// can't do a caps check for it -- it is always available.</span>
00476         <span class="keywordflow">if</span>( pi == D3DPRESENT_INTERVAL_DEFAULT ||
00477             (pDeviceInfo-&gt;m_Caps.PresentationIntervals &amp; pi) )
00478         {
00479             pDeviceCombo-&gt;m_PresentIntervals.push_back( pi );
00480         }
00481     }
00482 } <span class="comment">// D3DEnumeration::BuildPresentIntervalList</span>
</pre></div><hr><address style="align: right;"><small>
Generated on Tue Jun 13 11:14:33 2006 for gRenderDX9 by <a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 width=110 height=53>
</a> 1.3.1 using KingsTools</small></address>
</body>
</html>
