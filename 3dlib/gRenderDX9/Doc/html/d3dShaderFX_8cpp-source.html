<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gRenderDX9: d3dShaderFX.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.1 -->
<h1>d3dShaderFX.cpp</h1><div class="fragment"><pre>00001 <span class="comment">/*****************************************************************************/</span>
00002 <span class="comment">/*  File:   d3dShaderFX.cpp</span>
00003 <span class="comment">/*  Desc:   ShaderFX interface implementation for DirectX9 </span>
00004 <span class="comment">/*  Author: Ruslan Shestopalyuk</span>
00005 <span class="comment">/*  Date:   02.11.2004</span>
00006 <span class="comment">/*****************************************************************************/</span>
00007 <span class="preprocessor">#include "gRenderPch.h"</span>
00008 <span class="preprocessor">#include "d3dx9shader.h"</span>
00009 <span class="preprocessor">#include "d3dShaderFX.h"</span>
00010 <span class="preprocessor">#include "direct.h"</span>
00011 <span class="preprocessor">#include "IMediaManager.h"</span>
00012 
00013 <span class="comment">/*****************************************************************************/</span>
00014 <span class="comment">/*  FXIncluder implementation</span>
00015 <span class="comment">/*****************************************************************************/</span>
00016 HRESULT FXIncluder::Open( D3DXINCLUDE_TYPE IncludeType, LPCSTR pFileName, 
00017                             LPCVOID pParentData, LPCVOID *ppData, UINT *pBytes )
00018 {
00019     <span class="keywordtype">int</span> size = 0;
00020     <span class="keywordtype">int</span> resID = IRM-&gt;FindResource( pFileName );
00021     <span class="keywordflow">if</span> (resID == -1) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00022     <span class="keywordflow">if</span> (m_pCurShader) IRM-&gt;BindResource( resID, m_pCurShader );
00023 
00024 <span class="preprocessor">#ifdef DEBUG_VS</span>
00025 <span class="preprocessor"></span>    FILE* fp = fopen( IRM-&gt;GetPath( resID ), <span class="stringliteral">"rb"</span> );
00026     <span class="keywordflow">if</span> (!fp) <span class="keywordflow">return</span> E_FAIL;
00027     fseek( fp, 0, SEEK_END );
00028     size = ftell( fp );
00029     fseek( fp, 0, SEEK_SET );
00030     <span class="keyword">delete</span> []m_pData;
00031     m_pData = <span class="keyword">new</span> BYTE[size + 1];
00032     m_pData[size] = 0;
00033     fread( m_pData, size, 1, fp );
00034     fclose( fp );
00035     *ppData = m_pData;
00036     *pBytes = size;
00037     m_ResID = 0xFFFFFFFF;
00038     <span class="keywordflow">return</span> S_OK;
00039 <span class="preprocessor">#endif </span>
00040 <span class="preprocessor"></span>
00041     m_pData = IRM-&gt;LockData( resID, size );
00042     <span class="keywordflow">if</span> (!m_pData) <span class="keywordflow">return</span> E_FAIL;
00043     *pBytes = size;
00044     *ppData = m_pData;
00045     m_ResID = resID;
00046     <span class="keywordflow">return</span> S_OK;
00047 } <span class="comment">// FXIncluder::Open</span>
00048 
00049 HRESULT FXIncluder::Close( LPCVOID pData )
00050 {
00051     <span class="keywordflow">if</span> (m_ResID == 0xFFFFFFFF)
00052     {
00053         <span class="keyword">delete</span> []m_pData;
00054         m_pData = NULL;
00055         <span class="keywordflow">return</span> S_OK;
00056     }
00057     IRM-&gt;UnlockData( m_ResID );
00058     m_pData = NULL;
00059     <span class="keywordflow">return</span> S_OK;
00060 } <span class="comment">// FXIncluder::Close</span>
00061 
00062 <span class="keywordtype">void</span> FXIncluder::SetCurShader( ShaderFX* pShader ) 
00063 { 
00064     m_pCurShader = pShader; 
00065 }
00066 
00067 <span class="comment">/*****************************************************************************/</span>
00068 <span class="comment">/*  ShaderFX implementation</span>
00069 <span class="comment">/*****************************************************************************/</span>
00070 Timer       ShaderFX::s_Timer;
00071 FXIncluder  ShaderFX::s_FXIncluder;
00072 
00073 ShaderFX::ShaderFX( IDirect3DDevice9* pDevice )
00074 {
00075     m_pEffect       = NULL;
00076     m_ID            = -1;
00077     m_ActiveTech    = 0;
00078 } <span class="comment">// ShaderFX::ShaderFX</span>
00079 
00080 ShaderFX::ShaderFX()
00081 {
00082     m_pEffect = NULL;
00083 } <span class="comment">// ShaderFX::ShaderFX</span>
00084 
00085 ShaderFX::~ShaderFX()
00086 {
00087 }
00088 
00089 <span class="keywordtype">int</span> ShaderFX::GetNTech()<span class="keyword"> const</span>
00090 <span class="keyword"></span>{
00091     <span class="keywordflow">return</span> m_Techniques.size();
00092 } <span class="comment">// ShaderFX::GetNTechniques</span>
00093 
00094 <span class="keyword">const</span> <span class="keywordtype">char</span>* ShaderFX::GetTechName( <span class="keywordtype">int</span> techID )<span class="keyword"> const</span>
00095 <span class="keyword"></span>{
00096     <span class="keywordflow">if</span> (techID &lt; 0 || techID &gt;= m_Techniques.size()) <span class="keywordflow">return</span> <span class="stringliteral">""</span>; 
00097     <span class="keywordflow">return</span>  m_Techniques[techID].m_Name.c_str();
00098 } <span class="comment">// ShaderFX::GetTechName</span>
00099 
00100 <span class="keywordtype">bool</span> ShaderFX::IsTechValid( <span class="keywordtype">int</span> techID )<span class="keyword"> const</span>
00101 <span class="keyword"></span>{
00102     <span class="keywordflow">if</span> (techID &lt; 0 || techID &gt;= m_Techniques.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00103     <span class="keywordflow">return</span> (m_pEffect-&gt;ValidateTechnique( m_Techniques[techID].m_Handle ) == D3D_OK);
00104 } <span class="comment">// ShaderFX::IsTechValid</span>
00105 
00106 <span class="keywordtype">int</span> ShaderFX::GetNPasses( <span class="keywordtype">int</span> techID )<span class="keyword"> const</span>
00107 <span class="keyword"></span>{
00108     <span class="keywordflow">if</span> (techID &lt; 0 || techID &gt;= m_Techniques.size()) <span class="keywordflow">return</span> 0;
00109     <span class="keywordflow">return</span> m_Techniques[techID].m_NPasses;
00110 } <span class="comment">// ShaderFX::GetNPasses</span>
00111 
00112 <a class="code" href="unionShaderVarValue.html">ShaderVarValue</a> ShaderFX::GetVariableValue( D3DXHANDLE h, ShaderVarType type )
00113 {
00114     <a class="code" href="unionShaderVarValue.html">ShaderVarValue</a> v;
00115     <span class="keywordflow">switch</span> (type)
00116     {
00117     <span class="keywordflow">case</span> svtBool:   
00118         {
00119             BOOL bVal;
00120             DX_CHK( m_pEffect-&gt;GetBool( h, &amp;bVal ) ); 
00121             v.<a class="code" href="unionShaderVarValue.html#o1">bVal</a> = (bVal == 0) ? FALSE : TRUE;
00122         }<span class="keywordflow">break</span>;
00123     <span class="keywordflow">case</span> svtFloat:  DX_CHK( m_pEffect-&gt;GetFloat( h, &amp;v.<a class="code" href="unionShaderVarValue.html#o2">fVal</a> ) ); <span class="keywordflow">break</span>;
00124     <span class="keywordflow">case</span> svtInt:    DX_CHK( m_pEffect-&gt;GetInt( h, &amp;v.<a class="code" href="unionShaderVarValue.html#o0">nVal</a> ) ); <span class="keywordflow">break</span>;
00125     <span class="keywordflow">case</span> svtMatrix: 
00126         DX_CHK( m_pEffect-&gt;GetMatrix( h, (D3DXMATRIX*)&amp;v.<a class="code" href="unionShaderVarValue.html#o4">mVal</a> ) ); 
00127         <span class="keywordflow">break</span>;
00128     <span class="keywordflow">case</span> svtVector: 
00129         DX_CHK( m_pEffect-&gt;GetVector( h, (D3DXVECTOR4*)&amp;v.<a class="code" href="unionShaderVarValue.html#o3">vVal</a> ) ); 
00130         <span class="keywordflow">break</span>;
00131     }
00132     <span class="keywordflow">return</span> v;
00133 } <span class="comment">// ShaderFX::GetVariableValue</span>
00134 
00135 <span class="keywordtype">void</span> ShaderFX::EnumerateTechniques()
00136 {
00137     m_Techniques.clear();
00138     <span class="keywordflow">if</span> (!m_pEffect) <span class="keywordflow">return</span>;
00139     D3DXEFFECT_DESC desc;
00140     m_pEffect-&gt;GetDesc( &amp;desc );
00141     <span class="keywordtype">int</span> nT = desc.Techniques;
00142     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nT; i++)
00143     {
00144         D3DXHANDLE h = m_pEffect-&gt;GetTechnique( i );
00145         ShaderFXTechnique tech;
00146         D3DXTECHNIQUE_DESC desc;
00147         m_pEffect-&gt;GetTechniqueDesc( h, &amp;desc );
00148         tech.m_Handle       = h;
00149         tech.m_Name         = desc.Name;
00150         tech.m_NPasses      = desc.Passes;
00151         tech.m_NAnnotations = desc.Annotations;
00152         m_Techniques.push_back( tech );
00153     }
00154 } <span class="comment">// ShaderFX::EnumerateTechniques</span>
00155 
00156 <span class="keywordtype">void</span> ShaderFX::EnumerateVariables()
00157 {
00158     <span class="keywordflow">if</span> (!m_pEffect) <span class="keywordflow">return</span>;
00159     D3DXEFFECT_DESC desc;
00160     m_pEffect-&gt;GetDesc( &amp;desc );
00161     <span class="keywordtype">int</span> nC = desc.Parameters;
00162 
00163     m_Variables.clear();
00164     m_Variables.resize( nC );
00165     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nC; i++)
00166     {
00167         ShaderFXVariable&amp; c = m_Variables[i];
00168         D3DXHANDLE h = m_pEffect-&gt;GetParameter( NULL, i );
00169         D3DXPARAMETER_DESC desc;
00170         m_pEffect-&gt;GetParameterDesc( h, &amp;desc );
00171         c.m_Name    = desc.Name;
00172         c.m_Type    = GetShaderVarType( desc.Class, desc.Type );
00173         <span class="comment">//c.m_Value   = GetVariableValue( h, c.m_Type );</span>
00174         c.m_Handle  = h;
00175     }
00176     <span class="comment">//  search for automatic variables</span>
00177     m_AutoVars.clear();
00178     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nC; i++)
00179     {
00180         m_Variables[i].m_bAuto = <span class="keyword">false</span>;
00181         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; (<span class="keywordtype">int</span>)acLAST; j++)
00182         {
00183             <span class="keywordflow">if</span> (!strcmp( c_AutoShaderVNames[j], m_Variables[i].m_Name.c_str() ))
00184             {
00185                 ShaderFXAutoVar avar;
00186                 avar.m_Idx = i;
00187                 avar.m_Type = (AutoShaderVariable)j;
00188                 m_Variables[i].m_bAuto = <span class="keyword">true</span>;
00189                 m_AutoVars.push_back( avar );
00190             }
00191         }
00192     }
00193 
00194 } <span class="comment">// ShaderFX::EnumerateVariables</span>
00195 
00196 <span class="keywordtype">bool</span> ShaderFX::IsAutoVar( <span class="keywordtype">int</span> cID )
00197 {
00198     <span class="keywordflow">if</span> (cID &lt; 0 || cID &gt;= m_Variables.size()) <span class="keywordflow">return</span> <span class="keyword">true</span>;
00199     <span class="keywordflow">return</span> m_Variables[cID].m_bAuto;
00200 }
00201 
00202 <span class="keyword">const</span> <span class="keywordtype">char</span>* ShaderFX::GetVariableName( <span class="keywordtype">int</span> cID )<span class="keyword"> const</span>
00203 <span class="keyword"></span>{
00204     <span class="keywordflow">if</span> (!m_pEffect || cID &lt; 0 || cID &gt;= m_Variables.size()) <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00205     <span class="keywordflow">return</span> m_Variables[cID].m_Name.c_str();
00206 } <span class="comment">// ShaderFX::GetVariableName</span>
00207 
00208 <span class="keywordtype">int</span> ShaderFX::GetShaderVarID( <span class="keyword">const</span> <span class="keywordtype">char</span>* cName )
00209 {
00210     <span class="keywordtype">int</span> nC = m_Variables.size();
00211     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nC; i++)
00212     {
00213         <span class="keywordflow">if</span> (!strcmp( cName, m_Variables[i].m_Name.c_str() )) <span class="keywordflow">return</span> i;
00214     }
00215     <span class="keywordflow">return</span> -1;
00216 } <span class="comment">// ShaderFX::GetShaderVarID</span>
00217 
00218 <span class="keywordtype">bool</span> ShaderFX::GetShaderVar( <span class="keywordtype">int</span> cID, <span class="keywordtype">bool</span>&amp; val )
00219 {
00220     <span class="keywordflow">if</span> (!m_pEffect || cID &lt; 0 || cID &gt;= m_Variables.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00221     HRESULT hRes = m_pEffect-&gt;GetBool( m_Variables[cID].m_Handle, (BOOL*)&amp;val );
00222     <span class="keywordflow">return</span> (hRes == S_OK);
00223 } <span class="comment">// ShaderFX::GetShaderVar</span>
00224 
00225 <span class="keywordtype">bool</span> ShaderFX::GetShaderVar( <span class="keywordtype">int</span> cID, <span class="keywordtype">float</span>&amp; val )
00226 {
00227     <span class="keywordflow">if</span> (!m_pEffect || cID &lt; 0 || cID &gt;= m_Variables.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00228     HRESULT hRes = m_pEffect-&gt;GetFloat( m_Variables[cID].m_Handle, &amp;val );
00229     <span class="keywordflow">return</span> (hRes == S_OK);
00230 } <span class="comment">// ShaderFX::GetShaderVar</span>
00231 
00232 <span class="keywordtype">bool</span> ShaderFX::GetShaderVar( <span class="keywordtype">int</span> cID, <span class="keywordtype">int</span>&amp; val )
00233 {
00234     <span class="keywordflow">if</span> (!m_pEffect || cID &lt; 0 || cID &gt;= m_Variables.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00235     HRESULT hRes = m_pEffect-&gt;GetInt( m_Variables[cID].m_Handle, &amp;val );
00236     <span class="keywordflow">return</span> (hRes == S_OK);
00237 } <span class="comment">// ShaderFX::GetShaderVar</span>
00238 
00239 <span class="keywordtype">bool</span> ShaderFX::GetShaderVar( <span class="keywordtype">int</span> cID, Matrix4D&amp; val )
00240 {
00241     <span class="keywordflow">if</span> (!m_pEffect || cID &lt; 0 || cID &gt;= m_Variables.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00242     HRESULT hRes = m_pEffect-&gt;GetMatrix( m_Variables[cID].m_Handle, (D3DXMATRIX*)&amp;val );
00243     <span class="keywordflow">return</span> (hRes == S_OK);
00244 } <span class="comment">// ShaderFX::GetShaderVar</span>
00245 
00246 <span class="keywordtype">bool</span> ShaderFX::GetShaderVar( <span class="keywordtype">int</span> cID, Vector4D&amp; val )
00247 {
00248     <span class="keywordflow">if</span> (!m_pEffect || cID &lt; 0 || cID &gt;= m_Variables.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00249     HRESULT hRes = m_pEffect-&gt;GetVector( m_Variables[cID].m_Handle, (D3DXVECTOR4*)&amp;val );
00250     <span class="keywordflow">return</span> (hRes == S_OK);
00251 } <span class="comment">// ShaderFX::GetShaderVar</span>
00252 
00253 <span class="keywordtype">bool</span> ShaderFX::GetShaderVar( <span class="keywordtype">int</span> cID, Vector3D&amp; val )
00254 {
00255     <span class="keywordflow">if</span> (!m_pEffect || cID &lt; 0 || cID &gt;= m_Variables.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00256     HRESULT hRes = m_pEffect-&gt;GetVector( m_Variables[cID].m_Handle, (D3DXVECTOR4*)&amp;val );
00257     <span class="keywordflow">return</span> (hRes == S_OK);
00258 } <span class="comment">// ShaderFX::GetShaderVar}</span>
00259 
00260 <span class="keywordtype">bool</span> ShaderFX::SetShaderVar( <span class="keywordtype">int</span> cID, <span class="keywordtype">bool</span> val )
00261 {
00262     <span class="keywordflow">if</span> (!m_pEffect || cID &lt; 0 || cID &gt;= m_Variables.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00263     HRESULT hRes = m_pEffect-&gt;SetBool( m_Variables[cID].m_Handle, (BOOL)val );
00264     DX_CHK( m_pEffect-&gt;CommitChanges() );
00265     <span class="keywordflow">return</span> (hRes == S_OK);
00266 } <span class="comment">// ShaderFX::SetShaderVar</span>
00267 
00268 <span class="keywordtype">bool</span> ShaderFX::SetShaderVar( <span class="keywordtype">int</span> cID, <span class="keywordtype">float</span> val )
00269 {
00270     <span class="keywordflow">if</span> (!m_pEffect || cID &lt; 0 || cID &gt;= m_Variables.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00271     HRESULT hRes = m_pEffect-&gt;SetFloat( m_Variables[cID].m_Handle, val );
00272     DX_CHK( m_pEffect-&gt;CommitChanges() );
00273     <span class="keywordflow">return</span> (hRes == S_OK);
00274 } <span class="comment">// ShaderFX::SetShaderVar</span>
00275 
00276 <span class="keywordtype">bool</span> ShaderFX::SetShaderVar( <span class="keywordtype">int</span> cID, <span class="keywordtype">int</span> val )
00277 {
00278     <span class="keywordflow">if</span> (!m_pEffect || cID &lt; 0 || cID &gt;= m_Variables.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00279     HRESULT hRes = m_pEffect-&gt;SetInt( m_Variables[cID].m_Handle, val );
00280     DX_CHK( m_pEffect-&gt;CommitChanges() );
00281     <span class="keywordflow">return</span> (hRes == S_OK);
00282 } <span class="comment">// ShaderFX::SetShaderVar</span>
00283 
00284 <span class="keywordtype">bool</span> ShaderFX::SetShaderVar( <span class="keywordtype">int</span> cID, <span class="keyword">const</span> Matrix4D&amp; val )
00285 {
00286     <span class="keywordflow">if</span> (!m_pEffect || cID &lt; 0 || cID &gt;= m_Variables.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00287     Matrix4D tVal;
00288     tVal.transpose( val );
00289     HRESULT hRes = m_pEffect-&gt;SetMatrix( m_Variables[cID].m_Handle, (<span class="keyword">const</span> D3DXMATRIX*)&amp;tVal );
00290     DX_CHK( m_pEffect-&gt;CommitChanges() );
00291     <span class="keywordflow">return</span> (hRes == S_OK);
00292 } <span class="comment">// ShaderFX::SetShaderVar</span>
00293 
00294 <span class="keywordtype">bool</span> ShaderFX::SetShaderVar( <span class="keywordtype">int</span> cID, <span class="keyword">const</span> Vector4D&amp; val )
00295 {
00296     <span class="keywordflow">if</span> (!m_pEffect || cID &lt; 0 || cID &gt;= m_Variables.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00297     HRESULT hRes = m_pEffect-&gt;SetVector( m_Variables[cID].m_Handle, (<span class="keyword">const</span> D3DXVECTOR4*)&amp;val );
00298     DX_CHK( m_pEffect-&gt;CommitChanges() );
00299     <span class="keywordflow">return</span> (hRes == S_OK);
00300 } <span class="comment">// ShaderFX::SetShaderVar</span>
00301 
00302 <span class="keywordtype">bool</span> ShaderFX::SetShaderVar( <span class="keywordtype">int</span> cID, <span class="keyword">const</span> Vector3D&amp; val )
00303 {
00304     <span class="keywordflow">if</span> (!m_pEffect || cID &lt; 0 || cID &gt;= m_Variables.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00305     HRESULT hRes = m_pEffect-&gt;SetVector( m_Variables[cID].m_Handle, (<span class="keyword">const</span> D3DXVECTOR4*)&amp;val );
00306     DX_CHK( m_pEffect-&gt;CommitChanges() );
00307     <span class="keywordflow">return</span> (hRes == S_OK);
00308 } <span class="comment">// ShaderFX::SetShaderVar</span>
00309 
00310 <span class="keywordtype">void</span> ShaderFX::SetAutoVars()
00311 {
00312     <span class="keywordflow">if</span> (!m_pEffect) <span class="keywordflow">return</span>;
00313     <span class="comment">//  TODO - some funky virtual dispatching?..</span>
00314     <span class="keywordtype">int</span> nV = m_AutoVars.size();
00315     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nV; i++)
00316     {
00317         <span class="keyword">const</span> ShaderFXAutoVar&amp; av = m_AutoVars[i];
00318         D3DXHANDLE h = m_Variables[av.m_Idx].m_Handle;
00319         <span class="keywordflow">switch</span> (av.m_Type)
00320         {
00321             <span class="keywordflow">case</span> acWorldTM: 
00322                 {
00323                     Matrix4D wTM = IRS-&gt;GetWorldTM();
00324                     wTM.transpose();
00325                     DX_CHK( m_pEffect-&gt;SetMatrix( h, (<span class="keyword">const</span> D3DXMATRIX*)&amp;wTM ) ); 
00326                 }<span class="keywordflow">break</span>;         
00327             <span class="keywordflow">case</span> acViewTM: 
00328                 {
00329                     Matrix4D vTM = IRS-&gt;GetViewTM();
00330                     vTM.transpose();
00331                     DX_CHK( m_pEffect-&gt;SetMatrix( h, (<span class="keyword">const</span> D3DXMATRIX*)&amp;vTM ) );
00332                 }<span class="keywordflow">break</span>;             
00333             <span class="keywordflow">case</span> acProjTM: 
00334                 {
00335                     Matrix4D pTM = IRS-&gt;GetProjTM();
00336                     pTM.transpose();
00337                     DX_CHK( m_pEffect-&gt;SetMatrix( h, (<span class="keyword">const</span> D3DXMATRIX*)&amp;pTM ) );
00338                 }<span class="keywordflow">break</span>;             
00339             <span class="keywordflow">case</span> acViewProjTM: 
00340                 {
00341                     Matrix4D vpTM;
00342                     vpTM.mul( IRS-&gt;GetViewTM(), IRS-&gt;GetProjTM() );
00343                     vpTM.transpose();
00344                     DX_CHK( m_pEffect-&gt;SetMatrix( h, (<span class="keyword">const</span> D3DXMATRIX*)&amp;vpTM ) );
00345                 }<span class="keywordflow">break</span>;         
00346             <span class="keywordflow">case</span> acWorldViewProjTM: 
00347                 {
00348                     Matrix4D wvpTM( IRS-&gt;GetWorldTM() );
00349                     wvpTM *= IRS-&gt;GetViewTM();
00350                     wvpTM *= IRS-&gt;GetProjTM();
00351                     wvpTM.transpose();
00352                     <span class="comment">//DX_CHK( m_pEffect-&gt;SetMatrix( h, (const D3DXMATRIX*)&amp;IRS-&gt;GetWorldViewProjTM() ) );</span>
00353                     DX_CHK( m_pEffect-&gt;SetMatrix( h, (<span class="keyword">const</span> D3DXMATRIX*)&amp;wvpTM) );
00354                 }<span class="keywordflow">break</span>; 
00355             <span class="keywordflow">case</span> acWorldViewTM: 
00356                 {
00357                     Matrix4D wvTM;
00358                     wvTM.mul( IRS-&gt;GetWorldTM(), IRS-&gt;GetViewTM() );
00359                     wvTM.transpose();
00360                     DX_CHK( m_pEffect-&gt;SetMatrix( h, (<span class="keyword">const</span> D3DXMATRIX*)&amp;wvTM ) );
00361                 }<span class="keywordflow">break</span>; 
00362             <span class="keywordflow">case</span> acViewPos:     
00363                 {
00364                     <span class="keyword">const</span> Matrix4D&amp; vTM = IRS-&gt;GetViewTM();
00365                     Vector4D pos;
00366                     pos.x = -(vTM.e00*vTM.e30 + vTM.e01*vTM.e31 + vTM.e02*vTM.e32);
00367                     pos.y = -(vTM.e10*vTM.e30 + vTM.e11*vTM.e31 + vTM.e12*vTM.e32);
00368                     pos.z = -(vTM.e20*vTM.e30 + vTM.e21*vTM.e31 + vTM.e22*vTM.e32);
00369                     Matrix4D ctm;
00370                     ctm.inverse( vTM );
00371                     pos.x = ctm.e30;
00372                     pos.y = ctm.e31;
00373                     pos.z = ctm.e32;
00374                     pos.w = 1.0f;
00375                     DX_CHK( m_pEffect-&gt;SetVector( h, (<span class="keyword">const</span> D3DXVECTOR4*)&amp;pos ) );
00376                 }<span class="keywordflow">break</span>;
00377             <span class="keywordflow">case</span> acLightPos:            <span class="keywordflow">break</span>;              
00378             <span class="keywordflow">case</span> acLightDir:            <span class="keywordflow">break</span>;              
00379             <span class="keywordflow">case</span> acLightPosObjSpace:    <span class="keywordflow">break</span>;      
00380             <span class="keywordflow">case</span> acLightDirObjSpace:    <span class="keywordflow">break</span>;      
00381             <span class="keywordflow">case</span> acLightDiffuse:
00382                 {
00383                     <span class="keyword">static</span> <span class="keywordtype">int</span> LightID=IMM-&gt;GetNodeID( <span class="stringliteral">"GameLight"</span> );
00384                     ILight* IL=IMM-&gt;GetLight(LightID);                    
00385                     ColorValue cv( IL-&gt;GetDiffuse() );
00386                     DX_CHK( m_pEffect-&gt;SetVector( h, &amp;D3DXVECTOR4( cv.r, cv.g, cv.b, cv.a ) ) );
00387                 }
00388                 <span class="keywordflow">break</span>;
00389             <span class="keywordflow">case</span> acLightSpecular:
00390                 {
00391                     <span class="keyword">static</span> <span class="keywordtype">int</span> LightID=IMM-&gt;GetNodeID( <span class="stringliteral">"GameLight"</span> );
00392                     ILight* IL=IMM-&gt;GetLight(LightID);                    
00393                     ColorValue cv( IL-&gt;GetSpecular() );
00394                     DX_CHK( m_pEffect-&gt;SetVector( h, &amp;D3DXVECTOR4( cv.r, cv.g, cv.b, cv.a ) ) );
00395                 }
00396                 <span class="keywordflow">break</span>;
00397             <span class="keywordflow">case</span> acLightAmbient:
00398                 {
00399                     <span class="keyword">static</span> <span class="keywordtype">int</span> LightID=IMM-&gt;GetNodeID( <span class="stringliteral">"GameLight"</span> );
00400                     ILight* IL=IMM-&gt;GetLight(LightID);                    
00401                     ColorValue cv( IL-&gt;GetAmbient() );
00402                     DX_CHK( m_pEffect-&gt;SetVector( h, &amp;D3DXVECTOR4( cv.r, cv.g, cv.b, cv.a ) ) );
00403                 }
00404                 <span class="keywordflow">break</span>;
00405             <span class="keywordflow">case</span> acFogDensity:
00406                 DX_CHK( m_pEffect-&gt;SetFloat( h, IRS-&gt;GetFogDensity() ) );
00407                 <span class="keywordflow">break</span>;
00408             <span class="keywordflow">case</span> acMaterialDiffuse:
00409                 {
00410                     <span class="keyword">static</span> <span class="keywordtype">int</span> LightID=IMM-&gt;GetNodeID( <span class="stringliteral">"GameLight"</span> );
00411                     ILight* IL=IMM-&gt;GetLight(LightID);                    
00412                     ColorValue cv( IL-&gt;GetDiffuse() );
00413                     DX_CHK( m_pEffect-&gt;SetVector( h, &amp;D3DXVECTOR4( cv.r, cv.g, cv.b, cv.a ) ) );
00414                 }
00415                 <span class="keywordflow">break</span>;
00416             <span class="keywordflow">case</span> acMaterialSpecular:
00417                 {
00418                     <span class="keyword">static</span> <span class="keywordtype">int</span> LightID=IMM-&gt;GetNodeID( <span class="stringliteral">"GameLight"</span> );
00419                     ILight* IL=IMM-&gt;GetLight(LightID);                    
00420                     ColorValue cv( IL-&gt;GetSpecular() );
00421                     DX_CHK( m_pEffect-&gt;SetVector( h, &amp;D3DXVECTOR4( cv.r, cv.g, cv.b, cv.a ) ) );
00422                 }
00423                 <span class="keywordflow">break</span>;
00424             <span class="keywordflow">case</span> acMaterialAmbient:
00425                 {
00426                     <span class="keyword">static</span> <span class="keywordtype">int</span> LightID=IMM-&gt;GetNodeID( <span class="stringliteral">"GameLight"</span> );
00427                     ILight* IL=IMM-&gt;GetLight(LightID);                    
00428                     ColorValue cv( IL-&gt;GetAmbient() );
00429                     DX_CHK( m_pEffect-&gt;SetVector( h, &amp;D3DXVECTOR4( cv.r, cv.g, cv.b, cv.a ) ) );
00430                 }
00431                 <span class="keywordflow">break</span>;
00432 
00433             <span class="keywordflow">case</span> acTime:   
00434                 {
00435                     FLOAT t;
00436                     <span class="keywordflow">if</span>(!IRS-&gt;TimeOverrideIsEnabled(&amp;t)) {
00437                         t = s_Timer.seconds();
00438                     }
00439                     DX_CHK( m_pEffect-&gt;SetFloat( h, t ) );
00440                 }<span class="keywordflow">break</span>; 
00441 
00442             <span class="keywordflow">case</span> acTextureTM0:   
00443                 {
00444                     Matrix4D tm = IRS-&gt;GetTextureTM( 0 );
00445                     tm.transpose();
00446                     DX_CHK( m_pEffect-&gt;SetMatrix( h, (<span class="keyword">const</span> D3DXMATRIX*)&amp;tm ) );
00447                 }<span class="keywordflow">break</span>;
00448 
00449             <span class="keywordflow">case</span> acTextureTM1:   
00450                 {
00451                     Matrix4D tm = IRS-&gt;GetTextureTM( 1 );
00452                     tm.transpose();
00453                     DX_CHK( m_pEffect-&gt;SetMatrix( h, (<span class="keyword">const</span> D3DXMATRIX*)&amp;tm ) );
00454                 }<span class="keywordflow">break</span>;
00455             <span class="keywordflow">case</span> acTextureTM2:   
00456                 {
00457                     Matrix4D tm = IRS-&gt;GetTextureTM( 2 );
00458                     tm.transpose();
00459                     DX_CHK( m_pEffect-&gt;SetMatrix( h, (<span class="keyword">const</span> D3DXMATRIX*)&amp;tm ) );
00460                 }<span class="keywordflow">break</span>;
00461             <span class="keywordflow">case</span> acTextureTM3:   
00462                 {
00463                     Matrix4D tm = IRS-&gt;GetTextureTM( 3 );
00464                     tm.transpose();
00465                     DX_CHK( m_pEffect-&gt;SetMatrix( h, (<span class="keyword">const</span> D3DXMATRIX*)&amp;tm ) );
00466                 }<span class="keywordflow">break</span>;
00467             <span class="keywordflow">case</span> acTFactor:
00468                 {
00469                     ColorValue cv( IRS-&gt;GetTextureFactor() );
00470                     DX_CHK( m_pEffect-&gt;SetVector( h, &amp;D3DXVECTOR4( cv.r, cv.g, cv.b, cv.a ) ) );
00471                 }<span class="keywordflow">break</span>;
00472             <span class="keywordflow">case</span> acColorConst:
00473                 {
00474                     ColorValue cv( IRS-&gt;GetColorConst() );
00475                     DX_CHK( m_pEffect-&gt;SetVector( h, &amp;D3DXVECTOR4( cv.r, cv.g, cv.b, cv.a ) ) );
00476                 }<span class="keywordflow">break</span>;
00477             <span class="keywordflow">case</span> acFarPlane:
00478                 {
00479                     <span class="keyword">const</span> Matrix4D&amp; pTM = IRS-&gt;GetProjTM();
00480                     DX_CHK( m_pEffect-&gt;SetFloat( h, pTM.e32/(1.0f - pTM.e22) ) );
00481                 }<span class="keywordflow">break</span>;
00482             <span class="keywordflow">case</span> acNearPlane:
00483                 {
00484                     <span class="keyword">const</span> Matrix4D&amp; pTM = IRS-&gt;GetProjTM();
00485                     DX_CHK( m_pEffect-&gt;SetFloat( h, -pTM.e32/pTM.e22 ) );
00486                 }<span class="keywordflow">break</span>;
00487         }
00488     }
00489 
00490     DX_CHK( m_pEffect-&gt;CommitChanges() );
00491 } <span class="comment">// ShaderFX::SetAutoVars</span>
00492 
00493 <span class="keywordtype">bool</span> ShaderFX::Load( <span class="keyword">const</span> <span class="keywordtype">char</span>* fName )
00494 {
00495     m_FileName = fName;
00496     <span class="keywordtype">int</span> size = 0;
00497     <span class="keywordtype">int</span> resID = IRM-&gt;FindResource( fName );
00498     <span class="keywordflow">if</span> (resID == -1) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00499     IRM-&gt;BindResource( resID, <span class="keyword">this</span> );
00500 
00501 <span class="preprocessor">#ifdef DEBUG_VS</span>
00502 <span class="preprocessor"></span>    FilePath path( IRM-&gt;GetFullPath( resID ) );
00503     path.SetFileName( fName );
00504     <span class="keywordflow">return</span> LoadFromFile( path.GetFullPath() );
00505 <span class="preprocessor">#endif </span>
00506 <span class="preprocessor"></span>
00507     BYTE* pData = IRM-&gt;LockData( resID, size );
00508     <span class="keywordtype">bool</span> res = LoadFromMemory( pData, size );
00509     IRM-&gt;UnlockData( resID );
00510     
00511     <span class="keywordflow">return</span> res;
00512 } <span class="comment">// ShaderFX::Load</span>
00513 
00514 IDirect3DDevice9* GetDirect3DDevice();
00515 <span class="keywordtype">bool</span> ShaderFX::LoadFromFile( <span class="keyword">const</span> <span class="keywordtype">char</span>* fName )
00516 {
00517     HRESULT hr = S_OK;
00518 
00519     DWORD dwShaderFlags = 0;
00520 <span class="preprocessor">#ifdef DEBUG_VS</span>
00521 <span class="preprocessor"></span>    dwShaderFlags |= D3DXSHADER_FORCE_VS_SOFTWARE_NOOPT;
00522 <span class="preprocessor">#endif</span>
00523 <span class="preprocessor"></span><span class="preprocessor">#ifdef DEBUG_PS</span>
00524 <span class="preprocessor"></span>    dwShaderFlags |= D3DXSHADER_FORCE_PS_SOFTWARE_NOOPT;
00525 <span class="preprocessor">#endif</span>
00526 <span class="preprocessor"></span>    ID3DXBuffer* pErrBuffer = NULL;
00527     IDirect3DDevice9* pDevice = GetDirect3DDevice();
00528     s_FXIncluder.SetCurShader( <span class="keyword">this</span> );
00529     hr = D3DXCreateEffectFromFile( pDevice, fName, NULL, NULL<span class="comment">/*&amp;s_FXIncluder*/</span>, dwShaderFlags, NULL, &amp;m_pEffect, &amp;pErrBuffer );
00530     <span class="keywordflow">if</span> (hr != S_OK &amp;&amp; pErrBuffer)
00531     {
00532         <span class="keyword">const</span> <span class="keywordtype">char</span>* pErrText = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)pErrBuffer-&gt;GetBufferPointer();
00533         Log.Error( <span class="stringliteral">"Error in shader %s: %s"</span>, fName, pErrText );
00534     }
00535     EnumerateVariables();
00536     EnumerateTechniques();
00537     <span class="keywordflow">return</span> (hr == S_OK);
00538 } <span class="comment">// ShaderFX::LoadFromFile</span>
00539 
00540 <span class="keywordtype">bool</span> ShaderFX::LoadFromMemory( <span class="keyword">const</span> BYTE* pBuf, <span class="keywordtype">int</span> bufSize )
00541 {
00542     <span class="keywordflow">if</span> (!pBuf || bufSize == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00543     HRESULT hr = S_OK;
00544     DWORD dwShaderFlags = 0;
00545 <span class="preprocessor">#ifdef DEBUG_VS</span>
00546 <span class="preprocessor"></span>    dwShaderFlags |= D3DXSHADER_FORCE_VS_SOFTWARE_NOOPT;
00547 <span class="preprocessor">#endif</span>
00548 <span class="preprocessor"></span><span class="preprocessor">#ifdef DEBUG_PS</span>
00549 <span class="preprocessor"></span>    dwShaderFlags |= D3DXSHADER_FORCE_PS_SOFTWARE_NOOPT;
00550 <span class="preprocessor">#endif</span>
00551 <span class="preprocessor"></span>    ID3DXBuffer* pErrBuffer = NULL;
00552     IDirect3DDevice9* pDevice = GetDirect3DDevice();
00553     s_FXIncluder.SetCurShader( <span class="keyword">this</span> );
00554     hr = D3DXCreateEffect( pDevice, pBuf, bufSize, NULL, &amp;s_FXIncluder, dwShaderFlags, NULL, &amp;m_pEffect, &amp;pErrBuffer );
00555     
00556     <span class="keywordflow">if</span> (hr != S_OK)
00557     {
00558         DWORD err = GetLastError();
00559         <span class="keywordflow">if</span> (pErrBuffer)
00560         {
00561             <span class="keyword">const</span> <span class="keywordtype">char</span>* pErrText = (<span class="keyword">const</span> <span class="keywordtype">char</span>*)pErrBuffer-&gt;GetBufferPointer();
00562             Log.Warning( <span class="stringliteral">"Error in shader %s: %s"</span>, m_FileName.c_str(), pErrText );
00563         }
00564         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hr == E_OUTOFMEMORY)
00565         {
00566             Log.Warning( <span class="stringliteral">"Not enough memory to compile shader %s"</span>, m_FileName.c_str() );
00567         }
00568         <span class="keywordflow">else</span> 
00569         {
00570             Log.Warning( <span class="stringliteral">"Could not compile shader %s:  %s"</span>, m_FileName.c_str(), GetD3DErrorDesc( hr ) );
00571         }
00572     }
00573     
00574     EnumerateVariables();
00575     EnumerateTechniques();
00576     <span class="keywordflow">return</span> (hr == S_OK);
00577 } <span class="comment">// ShaderFX::LoadFromMemory</span>
00578 <span class="keywordtype">bool</span> ShaderFX::Begin()
00579 {
00580     <span class="keywordflow">if</span> (!m_pEffect) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00581     UINT nPasses = 0;
00582     m_pEffect-&gt;Begin( &amp;nPasses, 0 );
00583     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00584 } <span class="comment">// ShaderFX::Begin</span>
00585 
00586 <span class="keywordtype">bool</span> ShaderFX::BeginPass( <span class="keywordtype">int</span> passID )
00587 {
00588     <span class="keywordflow">if</span> (!m_pEffect) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00589     m_pEffect-&gt;BeginPass( passID );
00590     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00591 } <span class="comment">// ShaderFX::BeginPass</span>
00592 
00593 <span class="keywordtype">bool</span> ShaderFX::EndPass()
00594 {
00595     <span class="keywordflow">if</span> (!m_pEffect) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00596     m_pEffect-&gt;EndPass();
00597     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00598 } <span class="comment">// ShaderFX::EndPass</span>
00599 
00600 <span class="keywordtype">bool</span> ShaderFX::End()
00601 {
00602     <span class="keywordflow">if</span> (!m_pEffect) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00603     m_pEffect-&gt;End();
00604     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00605 } <span class="comment">// ShaderFX::End</span>
00606 
00607 <span class="keywordtype">bool</span> ShaderFX::Reload() 
00608 {
00609     DeleteDeviceObjects();
00610     <span class="keywordflow">return</span> Load( m_FileName.c_str() );
00611 } <span class="comment">// ShaderFX::Reload</span>
00612 
00613 <span class="keywordtype">void</span> ShaderFX::DeleteDeviceObjects()
00614 {
00615     SAFE_RELEASE( m_pEffect );
00616 } <span class="comment">// ShaderFX::DeleteDeviceObjects</span>
00617 
00618 <span class="keywordtype">void</span> ShaderFX::InvalidateDeviceObjects()
00619 {
00620     <span class="keywordflow">if</span> (m_pEffect) m_pEffect-&gt;OnLostDevice();
00621 } <span class="comment">// ShaderFX::InvalidateDeviceObjects</span>
00622 
00623 <span class="keywordtype">void</span> ShaderFX::RestoreDeviceObjects() 
00624 {
00625     <span class="keywordflow">if</span> (m_pEffect) m_pEffect-&gt;OnResetDevice();
00626 } <span class="comment">// ShaderFX::RestoreDeviceObjects</span>
00627 
</pre></div><hr><address style="align: right;"><small>
Generated on Tue Jun 13 11:14:33 2006 for gRenderDX9 by <a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 width=110 height=53>
</a> 1.3.1 using KingsTools</small></address>
</body>
</html>
