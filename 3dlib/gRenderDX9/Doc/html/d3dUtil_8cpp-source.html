<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gRenderDX9: d3dUtil.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.1 -->
<h1>d3dUtil.cpp</h1><div class="fragment"><pre>00001 <span class="comment">//-----------------------------------------------------------------------------</span>
00002 <span class="comment">// File: D3DUtil.cpp</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// Desc: Shortcut macros and functions for using DX objects</span>
00005 <span class="comment">//</span>
00006 <span class="comment">// Copyright (c) Microsoft Corporation. All rights reserved</span>
00007 <span class="comment">//-----------------------------------------------------------------------------</span>
00008 <span class="preprocessor">#include "gRenderPch.h"</span>
00009 <span class="preprocessor">#include "windef.h"</span>
00010 <span class="preprocessor">#ifndef WM_MOUSEWHEEL  </span>
00011 <span class="preprocessor"></span><span class="preprocessor">#define WM_MOUSEWHEEL                   0x020A</span>
00012 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00013 <span class="preprocessor"></span>
00014 D3DCOLORVALUE ToD3DCOLORVALUE( DWORD col )
00015 {
00016     D3DCOLORVALUE res;
00017     res.a = float( (col &amp; 0xFF000000)&gt;&gt;24 ) / 255.0f;
00018     res.r = float( (col &amp; 0x00FF0000)&gt;&gt;16 ) / 255.0f;
00019     res.g = float( (col &amp; 0x0000FF00)&gt;&gt;8  ) / 255.0f;
00020     res.b = float( (col &amp; 0x000000FF)     ) / 255.0f;
00021     <span class="keywordflow">return</span> res;
00022 }
00023 
00024 <span class="keyword">const</span> <span class="keywordtype">char</span>* GetD3DErrorDesc( HRESULT hresult )
00025 {
00026     <span class="keywordflow">switch</span> (hresult)
00027     {
00028     <span class="keywordflow">case</span> D3DERR_CONFLICTINGRENDERSTATE: 
00029         <span class="keywordflow">return</span> <span class="stringliteral">"The currently set render states cannot be used together."</span>; 
00030     <span class="keywordflow">case</span> D3DERR_CONFLICTINGTEXTUREFILTER: 
00031         <span class="keywordflow">return</span> <span class="stringliteral">"The current texture filters cannot be used together."</span>;
00032     <span class="keywordflow">case</span> D3DERR_CONFLICTINGTEXTUREPALETTE: 
00033         <span class="keywordflow">return</span> <span class="stringliteral">"The current textures cannot be used simultaneously."</span>;
00034     <span class="keywordflow">case</span> D3DERR_DEVICELOST: 
00035         <span class="keywordflow">return</span> <span class="stringliteral">"The device is lost and cannot be restored at the current time."</span>
00036             <span class="stringliteral">"Rendering is not possible."</span>; 
00037     <span class="keywordflow">case</span> D3DERR_DEVICENOTRESET: 
00038         <span class="keywordflow">return</span> <span class="stringliteral">"The device cannot be reset."</span>; 
00039     <span class="keywordflow">case</span> D3DERR_DRIVERINTERNALERROR: 
00040         <span class="keywordflow">return</span> <span class="stringliteral">"Internal driver error."</span>; 
00041     <span class="keywordflow">case</span> D3DERR_INVALIDCALL: 
00042         <span class="keywordflow">return</span> <span class="stringliteral">"The method call is invalid. "</span> 
00043             <span class="stringliteral">"Method's parameter may have an invalid value."</span>; 
00044     <span class="keywordflow">case</span> D3DERR_INVALIDDEVICE: 
00045         <span class="keywordflow">return</span> <span class="stringliteral">"The requested device type is not valid."</span>; 
00046     <span class="keywordflow">case</span> D3DERR_MOREDATA: 
00047         <span class="keywordflow">return</span> <span class="stringliteral">"There is more data available than the specified buffer size can hold."</span>; 
00048     <span class="keywordflow">case</span> D3DERR_NOTAVAILABLE: 
00049         <span class="keywordflow">return</span> <span class="stringliteral">"This device does not support the queried technique."</span>; 
00050     <span class="keywordflow">case</span> D3DERR_NOTFOUND: 
00051         <span class="keywordflow">return</span> <span class="stringliteral">"The requested item was not found."</span>;
00052     <span class="keywordflow">case</span> D3DERR_OUTOFVIDEOMEMORY: 
00053         <span class="keywordflow">return</span> <span class="stringliteral">"Direct3D does not have enough display memory to perform the operation."</span>; 
00054     <span class="keywordflow">case</span> D3DERR_TOOMANYOPERATIONS: 
00055         <span class="keywordflow">return</span> <span class="stringliteral">"The application is requesting more texture-filtering operations "</span>
00056             <span class="stringliteral">"than the device supports."</span>; 
00057     <span class="keywordflow">case</span> D3DERR_UNSUPPORTEDALPHAARG: 
00058         <span class="keywordflow">return</span> <span class="stringliteral">"The device does not support a specified texture-blending argument "</span>
00059             <span class="stringliteral">"for the alpha channel."</span>;
00060     <span class="keywordflow">case</span> D3DERR_UNSUPPORTEDALPHAOPERATION: 
00061         <span class="keywordflow">return</span> <span class="stringliteral">"The device does not support a specified texture-blending operation "</span> 
00062             <span class="stringliteral">"for the alpha channel."</span>; 
00063     <span class="keywordflow">case</span> D3DERR_UNSUPPORTEDCOLORARG: 
00064         <span class="keywordflow">return</span> <span class="stringliteral">"The device does not support a specified texture-blending argument "</span>
00065             <span class="stringliteral">"for color values."</span>; 
00066     <span class="keywordflow">case</span> D3DERR_UNSUPPORTEDCOLOROPERATION: 
00067         <span class="keywordflow">return</span> <span class="stringliteral">"The device does not support a specified texture-blending operation "</span>
00068             <span class="stringliteral">"for color values."</span>; 
00069     <span class="keywordflow">case</span> D3DERR_UNSUPPORTEDFACTORVALUE: 
00070         <span class="keywordflow">return</span> <span class="stringliteral">"The device does not support the specified texture factor value."</span>; 
00071     <span class="keywordflow">case</span> D3DERR_UNSUPPORTEDTEXTUREFILTER: 
00072         <span class="keywordflow">return</span> <span class="stringliteral">"The device does not support the specified texture filter."</span>; 
00073     <span class="keywordflow">case</span> D3DERR_WRONGTEXTUREFORMAT: 
00074         <span class="keywordflow">return</span> <span class="stringliteral">"The pixel format of the texture surface is not valid."</span>; 
00075     <span class="keywordflow">case</span> E_FAIL: 
00076         <span class="keywordflow">return</span> <span class="stringliteral">"An undetermined error occurred inside the Direct3D subsystem."</span>; 
00077     <span class="keywordflow">case</span> E_INVALIDARG: 
00078         <span class="keywordflow">return</span> <span class="stringliteral">"An invalid parameter was passed to the returning function."</span>; 
00079     <span class="keywordflow">case</span> E_OUTOFMEMORY: 
00080         <span class="keywordflow">return</span> <span class="stringliteral">"Direct3D could not allocate sufficient memory to complete the call."</span>;
00081     <span class="keywordflow">default</span>: <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00082     }
00083     <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00084 } <span class="comment">// GetD3DErrorDesc</span>
00085 
00086 <span class="keyword">const</span> <span class="keywordtype">char</span>* GetDispChangeErrorDesc( LONG result )
00087 {
00088     <span class="keywordflow">switch</span> (result)
00089     {
00090     <span class="keywordflow">case</span> DISP_CHANGE_SUCCESSFUL:
00091         <span class="keywordflow">return</span> <span class="stringliteral">"The display settings change was successful."</span>;
00092     <span class="keywordflow">case</span> DISP_CHANGE_RESTART:
00093         <span class="keywordflow">return</span> <span class="stringliteral">"The computer must be restarted in order for the graphics mode to work."</span>; 
00094     <span class="keywordflow">case</span> DISP_CHANGE_BADFLAGS:
00095         <span class="keywordflow">return</span> <span class="stringliteral">"An invalid set of flags was passed in ChangeDisplayMode."</span>; 
00096     <span class="keywordflow">case</span> DISP_CHANGE_BADPARAM:
00097         <span class="keywordflow">return</span> <span class="stringliteral">"An invalid flag, combination of flags, or parameter passed in ChangeDisplayMode."</span>; 
00098     <span class="keywordflow">case</span> DISP_CHANGE_FAILED:
00099         <span class="keywordflow">return</span> <span class="stringliteral">"The display driver failed the specified graphics mode."</span>; 
00100     <span class="keywordflow">case</span> DISP_CHANGE_BADMODE:
00101         <span class="keywordflow">return</span> <span class="stringliteral">"The graphics mode is not supported."</span>; 
00102     <span class="keywordflow">case</span> DISP_CHANGE_NOTUPDATED:
00103         <span class="keywordflow">return</span> <span class="stringliteral">"Unable to write settings to the registry."</span>; 
00104     <span class="keywordflow">default</span>: <span class="keywordflow">return</span> <span class="stringliteral">"Unexpected error while ChangeDisplaySettings."</span>;
00105     } 
00106 } <span class="comment">// GetDispChangeErrorDesc</span>
00107 
00108 <span class="comment">//-----------------------------------------------------------------------------</span>
00109 <span class="comment">// Name: D3DUtil_GetCubeMapViewMatrix()</span>
00110 <span class="comment">// Desc: Returns a view matrix for rendering to a face of a cubemap.</span>
00111 <span class="comment">//-----------------------------------------------------------------------------</span>
00112 D3DXMATRIX D3DUtil_GetCubeMapViewMatrix( DWORD dwFace )
00113 {
00114     D3DXVECTOR3 vEyePt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
00115     D3DXVECTOR3 vLookDir;
00116     D3DXVECTOR3 vUpDir;
00117 
00118     <span class="keywordflow">switch</span>( dwFace )
00119     {
00120         <span class="keywordflow">case</span> D3DCUBEMAP_FACE_POSITIVE_X:
00121             vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
00122             vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
00123             <span class="keywordflow">break</span>;
00124         <span class="keywordflow">case</span> D3DCUBEMAP_FACE_NEGATIVE_X:
00125             vLookDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f );
00126             vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
00127             <span class="keywordflow">break</span>;
00128         <span class="keywordflow">case</span> D3DCUBEMAP_FACE_POSITIVE_Y:
00129             vLookDir = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
00130             vUpDir   = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
00131             <span class="keywordflow">break</span>;
00132         <span class="keywordflow">case</span> D3DCUBEMAP_FACE_NEGATIVE_Y:
00133             vLookDir = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
00134             vUpDir   = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
00135             <span class="keywordflow">break</span>;
00136         <span class="keywordflow">case</span> D3DCUBEMAP_FACE_POSITIVE_Z:
00137             vLookDir = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
00138             vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
00139             <span class="keywordflow">break</span>;
00140         <span class="keywordflow">case</span> D3DCUBEMAP_FACE_NEGATIVE_Z:
00141             vLookDir = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
00142             vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
00143             <span class="keywordflow">break</span>;
00144     }
00145 
00146     <span class="comment">// Set the view transform for this cubemap surface</span>
00147     D3DXMATRIXA16 mView;
00148     D3DXMatrixLookAtLH( &amp;mView, &amp;vEyePt, &amp;vLookDir, &amp;vUpDir );
00149     <span class="keywordflow">return</span> mView;
00150 }
00151 
00152 
00153 
00154 
00155 <span class="comment">//-----------------------------------------------------------------------------</span>
00156 <span class="comment">// Name: D3DUtil_GetRotationFromCursor()</span>
00157 <span class="comment">// Desc: Returns a quaternion for the rotation implied by the window's cursor</span>
00158 <span class="comment">//       position.</span>
00159 <span class="comment">//-----------------------------------------------------------------------------</span>
00160 D3DXQUATERNION D3DUtil_GetRotationFromCursor( HWND hWnd,
00161                                               FLOAT fTrackBallRadius )
00162 {
00163     POINT pt;
00164     RECT  rc;
00165     GetCursorPos( &amp;pt );
00166     GetClientRect( hWnd, &amp;rc );
00167     ScreenToClient( hWnd, &amp;pt );
00168     FLOAT sx = ( ( ( 2.0f * pt.x ) / (rc.right-rc.left) ) - 1 );
00169     FLOAT sy = ( ( ( 2.0f * pt.y ) / (rc.bottom-rc.top) ) - 1 );
00170     FLOAT sz;
00171 
00172     <span class="keywordflow">if</span>( sx == 0.0f &amp;&amp; sy == 0.0f )
00173         <span class="keywordflow">return</span> D3DXQUATERNION( 0.0f, 0.0f, 0.0f, 1.0f );
00174 
00175     FLOAT d2 = sqrtf( sx*sx + sy*sy );
00176 
00177     <span class="keywordflow">if</span>( d2 &lt; fTrackBallRadius * 0.70710678118654752440 ) <span class="comment">// Inside sphere</span>
00178         sz = sqrtf( fTrackBallRadius*fTrackBallRadius - d2*d2 );
00179     <span class="keywordflow">else</span>                                                 <span class="comment">// On hyperbola</span>
00180         sz = (fTrackBallRadius*fTrackBallRadius) / (2.0f*d2);
00181 
00182     <span class="comment">// Get two points on trackball's sphere</span>
00183     D3DXVECTOR3 p1( sx, sy, sz );
00184     D3DXVECTOR3 p2( 0.0f, 0.0f, fTrackBallRadius );
00185 
00186     <span class="comment">// Get axis of rotation, which is cross product of p1 and p2</span>
00187     D3DXVECTOR3 vAxis;
00188     D3DXVec3Cross( &amp;vAxis, &amp;p1, &amp;p2);
00189 
00190     <span class="comment">// Calculate angle for the rotation about that axis</span>
00191     D3DXVECTOR3 vecDiff = p2-p1;
00192     FLOAT t = D3DXVec3Length( &amp;vecDiff ) / ( 2.0f*fTrackBallRadius );
00193     <span class="keywordflow">if</span>( t &gt; +1.0f) t = +1.0f;
00194     <span class="keywordflow">if</span>( t &lt; -1.0f) t = -1.0f;
00195     FLOAT fAngle = 2.0f * asinf( t );
00196 
00197     <span class="comment">// Convert axis to quaternion</span>
00198     D3DXQUATERNION quat;
00199     D3DXQuaternionRotationAxis( &amp;quat, &amp;vAxis, fAngle );
00200     <span class="keywordflow">return</span> quat;
00201 }
00202 
00203 
00204 
00205 
00206 <span class="comment">//-----------------------------------------------------------------------------</span>
00207 <span class="comment">// Name: D3DUtil_SetDeviceCursor</span>
00208 <span class="comment">// Desc: Gives the D3D device a cursor with image and hotspot from hCursor.</span>
00209 <span class="comment">//-----------------------------------------------------------------------------</span>
00210 HRESULT D3DUtil_SetDeviceCursor( LPDIRECT3DDEVICE9 pd3dDevice, HCURSOR hCursor,
00211                                  BOOL bAddWatermark )
00212 {
00213     HRESULT hr = E_FAIL;
00214     ICONINFO iconinfo;
00215     BOOL bBWCursor;
00216     LPDIRECT3DSURFACE9 pCursorSurface = NULL;
00217     HDC hdcColor = NULL;
00218     HDC hdcMask = NULL;
00219     HDC hdcScreen = NULL;
00220     BITMAP bm;
00221     DWORD dwWidth;
00222     DWORD dwHeightSrc;
00223     DWORD dwHeightDest;
00224     COLORREF crColor;
00225     COLORREF crMask;
00226     UINT x;
00227     UINT y;
00228     BITMAPINFO bmi;
00229     COLORREF* pcrArrayColor = NULL;
00230     COLORREF* pcrArrayMask = NULL;
00231     DWORD* pBitmap;
00232     HGDIOBJ hgdiobjOld;
00233 
00234     ZeroMemory( &amp;iconinfo, <span class="keyword">sizeof</span>(iconinfo) );
00235     <span class="keywordflow">if</span>( !GetIconInfo( hCursor, &amp;iconinfo ) )
00236         <span class="keywordflow">goto</span> End;
00237 
00238     <span class="keywordflow">if</span> (0 == GetObject((HGDIOBJ)iconinfo.hbmMask, <span class="keyword">sizeof</span>(BITMAP), (LPVOID)&amp;bm))
00239         <span class="keywordflow">goto</span> End;
00240     dwWidth = bm.bmWidth;
00241     dwHeightSrc = bm.bmHeight;
00242 
00243     <span class="keywordflow">if</span>( iconinfo.hbmColor == NULL )
00244     {
00245         bBWCursor = TRUE;
00246         dwHeightDest = dwHeightSrc / 2;
00247     }
00248     <span class="keywordflow">else</span> 
00249     {
00250         bBWCursor = FALSE;
00251         dwHeightDest = dwHeightSrc;
00252     }
00253 
00254     <span class="comment">// Create a surface for the fullscreen cursor</span>
00255     <span class="keywordflow">if</span>( FAILED( hr = pd3dDevice-&gt;CreateOffscreenPlainSurface( dwWidth, dwHeightDest, 
00256         D3DFMT_A8R8G8B8, D3DPOOL_SCRATCH, &amp;pCursorSurface, NULL ) ) )
00257     {
00258         <span class="keywordflow">goto</span> End;
00259     }
00260 
00261     pcrArrayMask = <span class="keyword">new</span> DWORD[dwWidth * dwHeightSrc];
00262 
00263     ZeroMemory(&amp;bmi, <span class="keyword">sizeof</span>(bmi));
00264     bmi.bmiHeader.biSize = <span class="keyword">sizeof</span>(bmi.bmiHeader);
00265     bmi.bmiHeader.biWidth = dwWidth;
00266     bmi.bmiHeader.biHeight = dwHeightSrc;
00267     bmi.bmiHeader.biPlanes = 1;
00268     bmi.bmiHeader.biBitCount = 32;
00269     bmi.bmiHeader.biCompression = BI_RGB;
00270 
00271     hdcScreen = GetDC( NULL );
00272     hdcMask = CreateCompatibleDC( hdcScreen );
00273     <span class="keywordflow">if</span>( hdcMask == NULL )
00274     {
00275         hr = E_FAIL;
00276         <span class="keywordflow">goto</span> End;
00277     }
00278     hgdiobjOld = SelectObject(hdcMask, iconinfo.hbmMask);
00279     GetDIBits(hdcMask, iconinfo.hbmMask, 0, dwHeightSrc, 
00280         pcrArrayMask, &amp;bmi, DIB_RGB_COLORS);
00281     SelectObject(hdcMask, hgdiobjOld);
00282 
00283     <span class="keywordflow">if</span> (!bBWCursor)
00284     {
00285         pcrArrayColor = <span class="keyword">new</span> DWORD[dwWidth * dwHeightDest];
00286         hdcColor = CreateCompatibleDC( hdcScreen );
00287         <span class="keywordflow">if</span>( hdcColor == NULL )
00288         {
00289             hr = E_FAIL;
00290             <span class="keywordflow">goto</span> End;
00291         }
00292         SelectObject(hdcColor, iconinfo.hbmColor);
00293         GetDIBits(hdcColor, iconinfo.hbmColor, 0, dwHeightDest, 
00294             pcrArrayColor, &amp;bmi, DIB_RGB_COLORS);
00295     }
00296 
00297     <span class="comment">// Transfer cursor image into the surface</span>
00298     D3DLOCKED_RECT lr;
00299     pCursorSurface-&gt;LockRect( &amp;lr, NULL, 0 );
00300     pBitmap = (DWORD*)lr.pBits;
00301     <span class="keywordflow">for</span>( y = 0; y &lt; dwHeightDest; y++ )
00302     {
00303         <span class="keywordflow">for</span>( x = 0; x &lt; dwWidth; x++ )
00304         {
00305             <span class="keywordflow">if</span> (bBWCursor)
00306             {
00307                 crColor = pcrArrayMask[dwWidth*(dwHeightDest-1-y) + x];
00308                 crMask = pcrArrayMask[dwWidth*(dwHeightSrc-1-y) + x];
00309             }
00310             <span class="keywordflow">else</span>
00311             {
00312                 crColor = pcrArrayColor[dwWidth*(dwHeightDest-1-y) + x];
00313                 crMask = pcrArrayMask[dwWidth*(dwHeightDest-1-y) + x];
00314             }
00315             <span class="keywordflow">if</span> (crMask == 0)
00316                 pBitmap[dwWidth*y + x] = 0xff000000 | crColor;
00317             <span class="keywordflow">else</span>
00318                 pBitmap[dwWidth*y + x] = 0x00000000;
00319 
00320             <span class="comment">// It may be helpful to make the D3D cursor look slightly </span>
00321             <span class="comment">// different from the Windows cursor so you can distinguish </span>
00322             <span class="comment">// between the two when developing/testing code.  When</span>
00323             <span class="comment">// bAddWatermark is TRUE, the following code adds some</span>
00324             <span class="comment">// small grey "D3D" characters to the upper-left corner of</span>
00325             <span class="comment">// the D3D cursor image.</span>
00326             <span class="keywordflow">if</span>( bAddWatermark &amp;&amp; x &lt; 12 &amp;&amp; y &lt; 5 )
00327             {
00328                 <span class="comment">// 11.. 11.. 11.. .... CCC0</span>
00329                 <span class="comment">// 1.1. ..1. 1.1. .... A2A0</span>
00330                 <span class="comment">// 1.1. .1.. 1.1. .... A4A0</span>
00331                 <span class="comment">// 1.1. ..1. 1.1. .... A2A0</span>
00332                 <span class="comment">// 11.. 11.. 11.. .... CCC0</span>
00333 
00334                 <span class="keyword">const</span> WORD wMask[5] = { 0xccc0, 0xa2a0, 0xa4a0, 0xa2a0, 0xccc0 };
00335                 <span class="keywordflow">if</span>( wMask[y] &amp; (1 &lt;&lt; (15 - x)) )
00336                 {
00337                     pBitmap[dwWidth*y + x] |= 0xff808080;
00338                 }
00339             }
00340         }
00341     }
00342     pCursorSurface-&gt;UnlockRect();
00343 
00344     <span class="comment">// Set the device cursor</span>
00345     <span class="keywordflow">if</span>( FAILED( hr = pd3dDevice-&gt;SetCursorProperties( iconinfo.xHotspot, 
00346         iconinfo.yHotspot, pCursorSurface ) ) )
00347     {
00348         <span class="keywordflow">goto</span> End;
00349     }
00350 
00351     hr = S_OK;
00352 
00353 End:
00354     <span class="keywordflow">if</span>( iconinfo.hbmMask != NULL )
00355         DeleteObject( iconinfo.hbmMask );
00356     <span class="keywordflow">if</span>( iconinfo.hbmColor != NULL )
00357         DeleteObject( iconinfo.hbmColor );
00358     <span class="keywordflow">if</span>( hdcScreen != NULL )
00359         ReleaseDC( NULL, hdcScreen );
00360     <span class="keywordflow">if</span>( hdcColor != NULL )
00361         DeleteDC( hdcColor );
00362     <span class="keywordflow">if</span>( hdcMask != NULL )
00363         DeleteDC( hdcMask );
00364     SAFE_DELETE_ARRAY( pcrArrayColor );
00365     SAFE_DELETE_ARRAY( pcrArrayMask );
00366     SAFE_RELEASE( pCursorSurface );
00367     <span class="keywordflow">return</span> hr;
00368 }
00369 
00370 
00371 
00372 <span class="comment">//-----------------------------------------------------------------------------</span>
00373 <span class="comment">// Name: D3DFormatToString</span>
00374 <span class="comment">// Desc: Returns the string for the given D3DFORMAT.</span>
00375 <span class="comment">//-----------------------------------------------------------------------------</span>
00376 LPCTSTR D3DUtil_D3DFormatToString( D3DFORMAT format, <span class="keywordtype">bool</span> bWithPrefix )
00377 {
00378     TCHAR* pstr = NULL;
00379     <span class="keywordflow">switch</span>( format )
00380     {
00381     <span class="keywordflow">case</span> D3DFMT_UNKNOWN:         pstr = TEXT(<span class="stringliteral">"D3DFMT_UNKNOWN"</span>); <span class="keywordflow">break</span>;
00382     <span class="keywordflow">case</span> D3DFMT_R8G8B8:          pstr = TEXT(<span class="stringliteral">"D3DFMT_R8G8B8"</span>); <span class="keywordflow">break</span>;
00383     <span class="keywordflow">case</span> D3DFMT_A8R8G8B8:        pstr = TEXT(<span class="stringliteral">"D3DFMT_A8R8G8B8"</span>); <span class="keywordflow">break</span>;
00384     <span class="keywordflow">case</span> D3DFMT_X8R8G8B8:        pstr = TEXT(<span class="stringliteral">"D3DFMT_X8R8G8B8"</span>); <span class="keywordflow">break</span>;
00385     <span class="keywordflow">case</span> D3DFMT_R5G6B5:          pstr = TEXT(<span class="stringliteral">"D3DFMT_R5G6B5"</span>); <span class="keywordflow">break</span>;
00386     <span class="keywordflow">case</span> D3DFMT_X1R5G5B5:        pstr = TEXT(<span class="stringliteral">"D3DFMT_X1R5G5B5"</span>); <span class="keywordflow">break</span>;
00387     <span class="keywordflow">case</span> D3DFMT_A1R5G5B5:        pstr = TEXT(<span class="stringliteral">"D3DFMT_A1R5G5B5"</span>); <span class="keywordflow">break</span>;
00388     <span class="keywordflow">case</span> D3DFMT_A4R4G4B4:        pstr = TEXT(<span class="stringliteral">"D3DFMT_A4R4G4B4"</span>); <span class="keywordflow">break</span>;
00389     <span class="keywordflow">case</span> D3DFMT_R3G3B2:          pstr = TEXT(<span class="stringliteral">"D3DFMT_R3G3B2"</span>); <span class="keywordflow">break</span>;
00390     <span class="keywordflow">case</span> D3DFMT_A8:              pstr = TEXT(<span class="stringliteral">"D3DFMT_A8"</span>); <span class="keywordflow">break</span>;
00391     <span class="keywordflow">case</span> D3DFMT_A8R3G3B2:        pstr = TEXT(<span class="stringliteral">"D3DFMT_A8R3G3B2"</span>); <span class="keywordflow">break</span>;
00392     <span class="keywordflow">case</span> D3DFMT_X4R4G4B4:        pstr = TEXT(<span class="stringliteral">"D3DFMT_X4R4G4B4"</span>); <span class="keywordflow">break</span>;
00393     <span class="keywordflow">case</span> D3DFMT_A2B10G10R10:     pstr = TEXT(<span class="stringliteral">"D3DFMT_A2B10G10R10"</span>); <span class="keywordflow">break</span>;
00394     <span class="keywordflow">case</span> D3DFMT_A8B8G8R8:        pstr = TEXT(<span class="stringliteral">"D3DFMT_A8B8G8R8"</span>); <span class="keywordflow">break</span>;
00395     <span class="keywordflow">case</span> D3DFMT_X8B8G8R8:        pstr = TEXT(<span class="stringliteral">"D3DFMT_X8B8G8R8"</span>); <span class="keywordflow">break</span>;
00396     <span class="keywordflow">case</span> D3DFMT_G16R16:          pstr = TEXT(<span class="stringliteral">"D3DFMT_G16R16"</span>); <span class="keywordflow">break</span>;
00397     <span class="keywordflow">case</span> D3DFMT_A2R10G10B10:     pstr = TEXT(<span class="stringliteral">"D3DFMT_A2R10G10B10"</span>); <span class="keywordflow">break</span>;
00398     <span class="keywordflow">case</span> D3DFMT_A16B16G16R16:    pstr = TEXT(<span class="stringliteral">"D3DFMT_A16B16G16R16"</span>); <span class="keywordflow">break</span>;
00399     <span class="keywordflow">case</span> D3DFMT_A8P8:            pstr = TEXT(<span class="stringliteral">"D3DFMT_A8P8"</span>); <span class="keywordflow">break</span>;
00400     <span class="keywordflow">case</span> D3DFMT_P8:              pstr = TEXT(<span class="stringliteral">"D3DFMT_P8"</span>); <span class="keywordflow">break</span>;
00401     <span class="keywordflow">case</span> D3DFMT_L8:              pstr = TEXT(<span class="stringliteral">"D3DFMT_L8"</span>); <span class="keywordflow">break</span>;
00402     <span class="keywordflow">case</span> D3DFMT_A8L8:            pstr = TEXT(<span class="stringliteral">"D3DFMT_A8L8"</span>); <span class="keywordflow">break</span>;
00403     <span class="keywordflow">case</span> D3DFMT_A4L4:            pstr = TEXT(<span class="stringliteral">"D3DFMT_A4L4"</span>); <span class="keywordflow">break</span>;
00404     <span class="keywordflow">case</span> D3DFMT_V8U8:            pstr = TEXT(<span class="stringliteral">"D3DFMT_V8U8"</span>); <span class="keywordflow">break</span>;
00405     <span class="keywordflow">case</span> D3DFMT_L6V5U5:          pstr = TEXT(<span class="stringliteral">"D3DFMT_L6V5U5"</span>); <span class="keywordflow">break</span>;
00406     <span class="keywordflow">case</span> D3DFMT_X8L8V8U8:        pstr = TEXT(<span class="stringliteral">"D3DFMT_X8L8V8U8"</span>); <span class="keywordflow">break</span>;
00407     <span class="keywordflow">case</span> D3DFMT_Q8W8V8U8:        pstr = TEXT(<span class="stringliteral">"D3DFMT_Q8W8V8U8"</span>); <span class="keywordflow">break</span>;
00408     <span class="keywordflow">case</span> D3DFMT_V16U16:          pstr = TEXT(<span class="stringliteral">"D3DFMT_V16U16"</span>); <span class="keywordflow">break</span>;
00409     <span class="keywordflow">case</span> D3DFMT_A2W10V10U10:     pstr = TEXT(<span class="stringliteral">"D3DFMT_A2W10V10U10"</span>); <span class="keywordflow">break</span>;
00410     <span class="keywordflow">case</span> D3DFMT_UYVY:            pstr = TEXT(<span class="stringliteral">"D3DFMT_UYVY"</span>); <span class="keywordflow">break</span>;
00411     <span class="keywordflow">case</span> D3DFMT_YUY2:            pstr = TEXT(<span class="stringliteral">"D3DFMT_YUY2"</span>); <span class="keywordflow">break</span>;
00412     <span class="keywordflow">case</span> D3DFMT_DXT1:            pstr = TEXT(<span class="stringliteral">"D3DFMT_DXT1"</span>); <span class="keywordflow">break</span>;
00413     <span class="keywordflow">case</span> D3DFMT_DXT2:            pstr = TEXT(<span class="stringliteral">"D3DFMT_DXT2"</span>); <span class="keywordflow">break</span>;
00414     <span class="keywordflow">case</span> D3DFMT_DXT3:            pstr = TEXT(<span class="stringliteral">"D3DFMT_DXT3"</span>); <span class="keywordflow">break</span>;
00415     <span class="keywordflow">case</span> D3DFMT_DXT4:            pstr = TEXT(<span class="stringliteral">"D3DFMT_DXT4"</span>); <span class="keywordflow">break</span>;
00416     <span class="keywordflow">case</span> D3DFMT_DXT5:            pstr = TEXT(<span class="stringliteral">"D3DFMT_DXT5"</span>); <span class="keywordflow">break</span>;
00417     <span class="keywordflow">case</span> D3DFMT_D16_LOCKABLE:    pstr = TEXT(<span class="stringliteral">"D3DFMT_D16_LOCKABLE"</span>); <span class="keywordflow">break</span>;
00418     <span class="keywordflow">case</span> D3DFMT_D32:             pstr = TEXT(<span class="stringliteral">"D3DFMT_D32"</span>); <span class="keywordflow">break</span>;
00419     <span class="keywordflow">case</span> D3DFMT_D15S1:           pstr = TEXT(<span class="stringliteral">"D3DFMT_D15S1"</span>); <span class="keywordflow">break</span>;
00420     <span class="keywordflow">case</span> D3DFMT_D24S8:           pstr = TEXT(<span class="stringliteral">"D3DFMT_D24S8"</span>); <span class="keywordflow">break</span>;
00421     <span class="keywordflow">case</span> D3DFMT_D24X8:           pstr = TEXT(<span class="stringliteral">"D3DFMT_D24X8"</span>); <span class="keywordflow">break</span>;
00422     <span class="keywordflow">case</span> D3DFMT_D24X4S4:         pstr = TEXT(<span class="stringliteral">"D3DFMT_D24X4S4"</span>); <span class="keywordflow">break</span>;
00423     <span class="keywordflow">case</span> D3DFMT_D16:             pstr = TEXT(<span class="stringliteral">"D3DFMT_D16"</span>); <span class="keywordflow">break</span>;
00424     <span class="keywordflow">case</span> D3DFMT_L16:             pstr = TEXT(<span class="stringliteral">"D3DFMT_L16"</span>); <span class="keywordflow">break</span>;
00425     <span class="keywordflow">case</span> D3DFMT_VERTEXDATA:      pstr = TEXT(<span class="stringliteral">"D3DFMT_VERTEXDATA"</span>); <span class="keywordflow">break</span>;
00426     <span class="keywordflow">case</span> D3DFMT_INDEX16:         pstr = TEXT(<span class="stringliteral">"D3DFMT_INDEX16"</span>); <span class="keywordflow">break</span>;
00427     <span class="keywordflow">case</span> D3DFMT_INDEX32:         pstr = TEXT(<span class="stringliteral">"D3DFMT_INDEX32"</span>); <span class="keywordflow">break</span>;
00428     <span class="keywordflow">case</span> D3DFMT_Q16W16V16U16:    pstr = TEXT(<span class="stringliteral">"D3DFMT_Q16W16V16U16"</span>); <span class="keywordflow">break</span>;
00429     <span class="keywordflow">case</span> D3DFMT_MULTI2_ARGB8:    pstr = TEXT(<span class="stringliteral">"D3DFMT_MULTI2_ARGB8"</span>); <span class="keywordflow">break</span>;
00430     <span class="keywordflow">case</span> D3DFMT_R16F:            pstr = TEXT(<span class="stringliteral">"D3DFMT_R16F"</span>); <span class="keywordflow">break</span>;
00431     <span class="keywordflow">case</span> D3DFMT_G16R16F:         pstr = TEXT(<span class="stringliteral">"D3DFMT_G16R16F"</span>); <span class="keywordflow">break</span>;
00432     <span class="keywordflow">case</span> D3DFMT_A16B16G16R16F:   pstr = TEXT(<span class="stringliteral">"D3DFMT_A16B16G16R16F"</span>); <span class="keywordflow">break</span>;
00433     <span class="keywordflow">case</span> D3DFMT_R32F:            pstr = TEXT(<span class="stringliteral">"D3DFMT_R32F"</span>); <span class="keywordflow">break</span>;
00434     <span class="keywordflow">case</span> D3DFMT_G32R32F:         pstr = TEXT(<span class="stringliteral">"D3DFMT_G32R32F"</span>); <span class="keywordflow">break</span>;
00435     <span class="keywordflow">case</span> D3DFMT_A32B32G32R32F:   pstr = TEXT(<span class="stringliteral">"D3DFMT_A32B32G32R32F"</span>); <span class="keywordflow">break</span>;
00436     <span class="keywordflow">case</span> D3DFMT_CxV8U8:          pstr = TEXT(<span class="stringliteral">"D3DFMT_CxV8U8"</span>); <span class="keywordflow">break</span>;
00437     <span class="keywordflow">default</span>:                     pstr = TEXT(<span class="stringliteral">"Unknown format"</span>); <span class="keywordflow">break</span>;
00438     }
00439     <span class="keywordflow">if</span>( bWithPrefix || _tcsstr( pstr, TEXT(<span class="stringliteral">"D3DFMT_"</span>) )== NULL )
00440         <span class="keywordflow">return</span> pstr;
00441     <span class="keywordflow">else</span>
00442         <span class="keywordflow">return</span> pstr + lstrlen( TEXT(<span class="stringliteral">"D3DFMT_"</span>) );
00443 }
00444 
00445 
00446 <span class="comment">//-----------------------------------------------------------------------------</span>
00447 <span class="comment">// Name: D3DUtil_QuaternionUnitAxisToUnitAxis2</span>
00448 <span class="comment">// Desc: Axis to axis quaternion double angle (no normalization)</span>
00449 <span class="comment">//       Takes two points on unit sphere an angle THETA apart, returns</span>
00450 <span class="comment">//       quaternion that represents a rotation around cross product by 2*THETA.</span>
00451 <span class="comment">//-----------------------------------------------------------------------------</span>
00452 <span class="keyword">inline</span> D3DXQUATERNION* WINAPI D3DUtil_QuaternionUnitAxisToUnitAxis2( D3DXQUATERNION *pOut, 
00453                                                                      <span class="keyword">const</span> D3DXVECTOR3 *pvFrom, 
00454                                                                      <span class="keyword">const</span> D3DXVECTOR3 *pvTo )
00455 {
00456     D3DXVECTOR3 vAxis;
00457     D3DXVec3Cross(&amp;vAxis, pvFrom, pvTo);    <span class="comment">// proportional to sin(theta)</span>
00458     pOut-&gt;x = vAxis.x;
00459     pOut-&gt;y = vAxis.y;
00460     pOut-&gt;z = vAxis.z;
00461     pOut-&gt;w = D3DXVec3Dot( pvFrom, pvTo );
00462     <span class="keywordflow">return</span> pOut;
00463 }
00464 
00465 
00466 
00467 
00468 <span class="comment">//-----------------------------------------------------------------------------</span>
00469 <span class="comment">// Name: D3DUtil_QuaternionAxisToAxis</span>
00470 <span class="comment">// Desc: Axis to axis quaternion </span>
00471 <span class="comment">//       Takes two points on unit sphere an angle THETA apart, returns</span>
00472 <span class="comment">//       quaternion that represents a rotation around cross product by theta.</span>
00473 <span class="comment">//-----------------------------------------------------------------------------</span>
00474 <span class="keyword">inline</span> D3DXQUATERNION* WINAPI D3DUtil_QuaternionAxisToAxis( D3DXQUATERNION *pOut, 
00475                                                             <span class="keyword">const</span> D3DXVECTOR3 *pvFrom, 
00476                                                             <span class="keyword">const</span> D3DXVECTOR3 *pvTo)
00477 {
00478     D3DXVECTOR3 vA, vB;
00479     D3DXVec3Normalize(&amp;vA, pvFrom);
00480     D3DXVec3Normalize(&amp;vB, pvTo);
00481     D3DXVECTOR3 vHalf(vA + vB);
00482     D3DXVec3Normalize(&amp;vHalf, &amp;vHalf);
00483     <span class="keywordflow">return</span> D3DUtil_QuaternionUnitAxisToUnitAxis2(pOut, &amp;vA, &amp;vHalf);
00484 }
00485 
00486 
00487 
00488 
00489 <span class="comment">//-----------------------------------------------------------------------------</span>
00490 <span class="comment">// Name:</span>
00491 <span class="comment">// Desc:</span>
00492 <span class="comment">//-----------------------------------------------------------------------------</span>
00493 CD3DArcBall::CD3DArcBall()
00494 {
00495     Reset();
00496     m_vDownPt = D3DXVECTOR3(0,0,0);
00497     m_vCurrentPt = D3DXVECTOR3(0,0,0);
00498 
00499     RECT rc;
00500     GetClientRect( GetForegroundWindow(), &amp;rc );
00501     SetWindow( rc.right, rc.bottom );
00502 }
00503 
00504 
00505 
00506 
00507 
00508 <span class="comment">//-----------------------------------------------------------------------------</span>
00509 <span class="comment">// Name:</span>
00510 <span class="comment">// Desc:</span>
00511 <span class="comment">//-----------------------------------------------------------------------------</span>
00512 <span class="keywordtype">void</span> CD3DArcBall::Reset()
00513 {
00514     D3DXQuaternionIdentity( &amp;m_qDown );
00515     D3DXQuaternionIdentity( &amp;m_qNow );
00516     D3DXMatrixIdentity( &amp;m_mRotation );
00517     D3DXMatrixIdentity( &amp;m_mTranslation );
00518     D3DXMatrixIdentity( &amp;m_mTranslationDelta );
00519     m_bDrag = FALSE;
00520     m_fRadiusTranslation = 1.0f;
00521     m_fRadius = 1.0f;
00522 }
00523 
00524 
00525 
00526 
00527 <span class="comment">//-----------------------------------------------------------------------------</span>
00528 <span class="comment">// Name:</span>
00529 <span class="comment">// Desc:</span>
00530 <span class="comment">//-----------------------------------------------------------------------------</span>
00531 D3DXVECTOR3 CD3DArcBall::ScreenToVector( <span class="keywordtype">float</span> fScreenPtX, <span class="keywordtype">float</span> fScreenPtY )
00532 {
00533     <span class="comment">// Scale to screen</span>
00534     FLOAT x   = -(fScreenPtX - m_nWidth/2)  / (m_fRadius*m_nWidth/2);
00535     FLOAT y   =  (fScreenPtY - m_nHeight/2) / (m_fRadius*m_nHeight/2);
00536 
00537     FLOAT z   = 0.0f;
00538     FLOAT mag = x*x + y*y;
00539 
00540     <span class="keywordflow">if</span>( mag &gt; 1.0f )
00541     {
00542         FLOAT scale = 1.0f/sqrtf(mag);
00543         x *= scale;
00544         y *= scale;
00545     }
00546     <span class="keywordflow">else</span>
00547         z = sqrtf( 1.0f - mag );
00548 
00549     <span class="comment">// Return vector</span>
00550     <span class="keywordflow">return</span> D3DXVECTOR3( x, y, z );
00551 }
00552 
00553 
00554 
00555 
00556 <span class="comment">//-----------------------------------------------------------------------------</span>
00557 <span class="comment">// Name:</span>
00558 <span class="comment">// Desc:</span>
00559 <span class="comment">//-----------------------------------------------------------------------------</span>
00560 D3DXQUATERNION CD3DArcBall::QuatFromBallPoints(<span class="keyword">const</span> D3DXVECTOR3 &amp;vFrom, <span class="keyword">const</span> D3DXVECTOR3 &amp;vTo)
00561 {
00562     D3DXVECTOR3 vPart;
00563     <span class="keywordtype">float</span> fDot = D3DXVec3Dot(&amp;vFrom, &amp;vTo);
00564     D3DXVec3Cross(&amp;vPart, &amp;vFrom, &amp;vTo);
00565 
00566     <span class="keywordflow">return</span> D3DXQUATERNION(vPart.x, vPart.y, vPart.z, fDot);
00567 }
00568 
00569 
00570 
00571 
00572 <span class="comment">//-----------------------------------------------------------------------------</span>
00573 <span class="comment">// Name:</span>
00574 <span class="comment">// Desc:</span>
00575 <span class="comment">//-----------------------------------------------------------------------------</span>
00576 <span class="keywordtype">void</span> CD3DArcBall::OnBegin( <span class="keywordtype">int</span> nX, <span class="keywordtype">int</span> nY )
00577 {
00578     m_bDrag = <span class="keyword">true</span>;
00579     m_vDownPt = ScreenToVector( (<span class="keywordtype">float</span>)nX, (<span class="keywordtype">float</span>)nY );
00580 }
00581 
00582 
00583 
00584 
00585 <span class="comment">//-----------------------------------------------------------------------------</span>
00586 <span class="comment">// Name:</span>
00587 <span class="comment">// Desc:</span>
00588 <span class="comment">//-----------------------------------------------------------------------------</span>
00589 <span class="keywordtype">void</span> CD3DArcBall::OnMove( <span class="keywordtype">int</span> nX, <span class="keywordtype">int</span> nY )
00590 {
00591     <span class="keywordflow">if</span> (m_bDrag) 
00592     { 
00593         m_vCurrentPt = ScreenToVector( (<span class="keywordtype">float</span>)nX, (<span class="keywordtype">float</span>)nY );
00594         m_qNow = m_qDown * QuatFromBallPoints( m_vDownPt, m_vCurrentPt );
00595     }
00596 }
00597 
00598 
00599 
00600 
00601 <span class="comment">//-----------------------------------------------------------------------------</span>
00602 <span class="comment">// Name:</span>
00603 <span class="comment">// Desc:</span>
00604 <span class="comment">//-----------------------------------------------------------------------------</span>
00605 <span class="keywordtype">void</span> CD3DArcBall::OnEnd()
00606 {
00607     m_bDrag = <span class="keyword">false</span>;
00608     m_qDown = m_qNow;
00609 }
00610 
00611 
00612 
00613 
00614 <span class="comment">//-----------------------------------------------------------------------------</span>
00615 <span class="comment">// Name: HandleMessages</span>
00616 <span class="comment">// Desc:</span>
00617 <span class="comment">//-----------------------------------------------------------------------------</span>
00618 LRESULT CD3DArcBall::HandleMessages( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
00619 {
00620     UNREFERENCED_PARAMETER( hWnd );
00621 
00622     <span class="comment">// Current mouse position</span>
00623     <span class="keywordtype">int</span> iMouseX = GET_X_LPARAM(lParam);
00624     <span class="keywordtype">int</span> iMouseY = GET_Y_LPARAM(lParam);
00625 
00626     <span class="keywordflow">switch</span>( uMsg )
00627     {
00628         <span class="keywordflow">case</span> WM_LBUTTONDOWN:
00629             OnBegin( iMouseX, iMouseY );
00630             <span class="keywordflow">return</span> TRUE;
00631 
00632         <span class="keywordflow">case</span> WM_LBUTTONUP:
00633             OnEnd();
00634             <span class="keywordflow">return</span> TRUE;
00635 
00636         <span class="keywordflow">case</span> WM_RBUTTONDOWN:
00637         <span class="keywordflow">case</span> WM_MBUTTONDOWN:
00638             <span class="comment">// Store off the position of the cursor when the button is pressed</span>
00639             m_ptLastMouse.x = iMouseX;
00640             m_ptLastMouse.y = iMouseY;
00641             <span class="keywordflow">return</span> TRUE;
00642 
00643         <span class="keywordflow">case</span> WM_MOUSEMOVE:
00644             <span class="keywordflow">if</span>( MK_LBUTTON&amp;wParam )
00645             {
00646                 OnMove( iMouseX, iMouseY );
00647             }
00648             <span class="keywordflow">else</span> <span class="keywordflow">if</span>( (MK_RBUTTON&amp;wParam) || (MK_MBUTTON&amp;wParam) )
00649             {
00650                 <span class="comment">// Normalize based on size of window and bounding sphere radius</span>
00651                 FLOAT fDeltaX = ( m_ptLastMouse.x-iMouseX ) * m_fRadiusTranslation / m_nWidth;
00652                 FLOAT fDeltaY = ( m_ptLastMouse.y-iMouseY ) * m_fRadiusTranslation / m_nHeight;
00653 
00654                 <span class="keywordflow">if</span>( wParam &amp; MK_RBUTTON )
00655                 {
00656                     D3DXMatrixTranslation( &amp;m_mTranslationDelta, -2*fDeltaX, 2*fDeltaY, 0.0f );
00657                     D3DXMatrixMultiply( &amp;m_mTranslation, &amp;m_mTranslation, &amp;m_mTranslationDelta );
00658                 }
00659                 <span class="keywordflow">else</span>  <span class="comment">// wParam &amp; MK_MBUTTON</span>
00660                 {
00661                     D3DXMatrixTranslation( &amp;m_mTranslationDelta, 0.0f, 0.0f, 5*fDeltaY );
00662                     D3DXMatrixMultiply( &amp;m_mTranslation, &amp;m_mTranslation, &amp;m_mTranslationDelta );
00663                 }
00664 
00665                 <span class="comment">// Store mouse coordinate</span>
00666                 m_ptLastMouse.x = iMouseX;
00667                 m_ptLastMouse.y = iMouseY;
00668             }
00669             <span class="keywordflow">return</span> TRUE;
00670     }
00671 
00672     <span class="keywordflow">return</span> FALSE;
00673 }
00674 
00675 
00676 
00677 
00678 <span class="comment">//-----------------------------------------------------------------------------</span>
00679 <span class="comment">// Name: CBaseCamera</span>
00680 <span class="comment">// Desc: Constructor</span>
00681 <span class="comment">//-----------------------------------------------------------------------------</span>
00682 CBaseCamera::CBaseCamera()
00683 {
00684     ZeroMemory( m_aKeys, <span class="keyword">sizeof</span>(BYTE)*CAM_MAX_KEYS );
00685 
00686     <span class="comment">// Set attributes for the view matrix</span>
00687     D3DXVECTOR3 vEyePt    = D3DXVECTOR3(0.0f,0.0f,0.0f);
00688     D3DXVECTOR3 vLookatPt = D3DXVECTOR3(0.0f,0.0f,1.0f);
00689 
00690     <span class="comment">// Setup the view matrix</span>
00691     SetViewParams( &amp;vEyePt, &amp;vLookatPt );
00692 
00693     <span class="comment">// Setup the projection matrix</span>
00694     SetProjParams( D3DX_PI/4, 1.0f, 1.0f, 1000.0f );
00695 
00696     GetCursorPos( &amp;m_ptLastMousePosition );
00697     m_bMouseLButtonDown = <span class="keyword">false</span>;
00698     m_bMouseMButtonDown = <span class="keyword">false</span>;
00699     m_bMouseRButtonDown = <span class="keyword">false</span>;
00700     m_nCurrentButtonMask = 0;
00701     m_nMouseWheelDelta = 0;
00702 
00703     m_fCameraYawAngle = 0.0f;
00704     m_fCameraPitchAngle = 0.0f;
00705 
00706     m_vVelocity     = D3DXVECTOR3(0,0,0);
00707     m_bMovementDrag = <span class="keyword">false</span>;
00708     m_vVelocityDrag = D3DXVECTOR3(0,0,0);
00709     m_fDragTimer    = 0.0f;
00710     m_fTotalDragTimeToZero = 0.25;
00711     m_vRotVelocity = D3DXVECTOR2(0,0);
00712 
00713     m_fRotationScaler = 0.01f;           
00714     m_fMoveScaler = 5.0f;           
00715 
00716     m_bInvertPitch = <span class="keyword">false</span>;
00717     m_bEnableYAxisMovement = <span class="keyword">true</span>;
00718     m_bEnablePositionMovement = <span class="keyword">true</span>;
00719 
00720     m_vMouseDelta   = D3DXVECTOR2(0,0);
00721     m_fFramesToSmoothMouseData = 2.0f;
00722 
00723     m_bClipToBoundary = <span class="keyword">false</span>;
00724     m_vMinBoundary = D3DXVECTOR3(-1,-1,-1);
00725     m_vMaxBoundary = D3DXVECTOR3(1,1,1);
00726 
00727     m_bResetCursorAfterMove = <span class="keyword">false</span>;
00728 }
00729 
00730 
00731 <span class="comment">//-----------------------------------------------------------------------------</span>
00732 <span class="comment">// Name: SetViewParams</span>
00733 <span class="comment">// Desc: Client can call this to change the position and direction of camrea</span>
00734 <span class="comment">//-----------------------------------------------------------------------------</span>
00735 VOID CBaseCamera::SetViewParams( D3DXVECTOR3* pvEyePt, D3DXVECTOR3* pvLookatPt )
00736 {
00737     <span class="keywordflow">if</span>( NULL == pvEyePt || NULL == pvLookatPt )
00738         <span class="keywordflow">return</span>;
00739 
00740     m_vDefaultEye = m_vEye = *pvEyePt;
00741     m_vDefaultLookAt = m_vLookAt = *pvLookatPt;
00742 
00743     <span class="comment">// Calc the view matrix</span>
00744     D3DXVECTOR3 vUp(0,1,0);
00745     D3DXMatrixLookAtLH( &amp;m_mView, pvEyePt, pvLookatPt, &amp;vUp );
00746 
00747     D3DXMATRIX mInvView;
00748     D3DXMatrixInverse( &amp;mInvView, NULL, &amp;m_mView );
00749 
00750     <span class="comment">// The axis basis vectors and camera position are stored inside the </span>
00751     <span class="comment">// position matrix in the 4 rows of the camera's world matrix.</span>
00752     <span class="comment">// To figuire out the yaw/pitch of the camera, we just need the Z basis vector</span>
00753     D3DXVECTOR3* pZBasis = (D3DXVECTOR3*) &amp;mInvView._31;
00754 
00755     m_fCameraYawAngle   = atan2f( pZBasis-&gt;x, pZBasis-&gt;z );
00756     <span class="keywordtype">float</span> fLen = sqrtf(pZBasis-&gt;z*pZBasis-&gt;z + pZBasis-&gt;x*pZBasis-&gt;x);
00757     m_fCameraPitchAngle = -atan2f( pZBasis-&gt;y, fLen );
00758 }
00759 
00760 
00761 
00762 
00763 <span class="comment">//-----------------------------------------------------------------------------</span>
00764 <span class="comment">// Name: SetProjParams</span>
00765 <span class="comment">// Desc: Calculates the projection matrix based on input params</span>
00766 <span class="comment">//-----------------------------------------------------------------------------</span>
00767 VOID CBaseCamera::SetProjParams( FLOAT fFOV, FLOAT fAspect, FLOAT fNearPlane,
00768                                    FLOAT fFarPlane )
00769 {
00770     <span class="comment">// Set attributes for the projection matrix</span>
00771     m_fFOV        = fFOV;
00772     m_fAspect     = fAspect;
00773     m_fNearPlane  = fNearPlane;
00774     m_fFarPlane   = fFarPlane;
00775 
00776     D3DXMatrixPerspectiveFovLH( &amp;m_mProj, fFOV, fAspect, fNearPlane, fFarPlane );
00777 }
00778 
00779 
00780 
00781 
00782 <span class="comment">//-----------------------------------------------------------------------------</span>
00783 <span class="comment">// Name: HandleMessages</span>
00784 <span class="comment">// Desc: Call this from your message proc so this class can handle window messages</span>
00785 <span class="comment">//-----------------------------------------------------------------------------</span>
00786 LRESULT CBaseCamera::HandleMessages( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
00787 {
00788     UNREFERENCED_PARAMETER( hWnd );
00789     UNREFERENCED_PARAMETER( lParam );
00790 
00791     <span class="keywordflow">switch</span>( uMsg )
00792     {
00793         <span class="keywordflow">case</span> WM_KEYDOWN:
00794         {
00795             <span class="comment">// Map this key to a D3DUtil_CameraKeys enum and update the</span>
00796             <span class="comment">// state of m_aKeys[] by adding the KEY_WAS_DOWN_MASK|KEY_IS_DOWN_MASK mask</span>
00797             <span class="comment">// only if the key is not down</span>
00798             D3DUtil_CameraKeys mappedKey = MapKey( (UINT)wParam );
00799             <span class="keywordflow">if</span>( mappedKey != CAM_UNKNOWN )
00800             {
00801                 <span class="keywordflow">if</span>( FALSE == IsKeyDown(m_aKeys[mappedKey]) )
00802                     m_aKeys[ mappedKey ] = KEY_WAS_DOWN_MASK | KEY_IS_DOWN_MASK;
00803             }
00804             <span class="keywordflow">break</span>;
00805         }
00806 
00807         <span class="keywordflow">case</span> WM_KEYUP:
00808         {
00809             <span class="comment">// Map this key to a D3DUtil_CameraKeys enum and update the</span>
00810             <span class="comment">// state of m_aKeys[] by removing the KEY_IS_DOWN_MASK mask.</span>
00811             D3DUtil_CameraKeys mappedKey = MapKey( (UINT)wParam );
00812             <span class="keywordflow">if</span>( mappedKey != CAM_UNKNOWN )
00813                 m_aKeys[ mappedKey ] &amp;= ~KEY_IS_DOWN_MASK;
00814             <span class="keywordflow">break</span>;
00815         }
00816 
00817         <span class="keywordflow">case</span> WM_RBUTTONDOWN: 
00818         <span class="keywordflow">case</span> WM_MBUTTONDOWN: 
00819         <span class="keywordflow">case</span> WM_LBUTTONDOWN: 
00820         {
00821             <span class="comment">// Update member var state</span>
00822             <span class="keywordflow">if</span>( uMsg == WM_LBUTTONDOWN ) { m_bMouseLButtonDown = <span class="keyword">true</span>; m_nCurrentButtonMask |= MOUSE_LEFT_BUTTON; }
00823             <span class="keywordflow">if</span>( uMsg == WM_MBUTTONDOWN ) { m_bMouseMButtonDown = <span class="keyword">true</span>; m_nCurrentButtonMask |= MOUSE_MIDDLE_BUTTON; }
00824             <span class="keywordflow">if</span>( uMsg == WM_RBUTTONDOWN ) { m_bMouseRButtonDown = <span class="keyword">true</span>; m_nCurrentButtonMask |= MOUSE_RIGHT_BUTTON; }
00825 
00826             <span class="comment">// Capture the mouse, so if the mouse button is </span>
00827             <span class="comment">// released outside the window, we'll get the WM_LBUTTONUP message</span>
00828             SetCapture(hWnd);
00829             GetCursorPos( &amp;m_ptLastMousePosition ); 
00830             <span class="keywordflow">return</span> TRUE;
00831         }
00832 
00833         <span class="keywordflow">case</span> WM_RBUTTONUP: 
00834         <span class="keywordflow">case</span> WM_MBUTTONUP: 
00835         <span class="keywordflow">case</span> WM_LBUTTONUP:   
00836         {
00837             <span class="comment">// Update member var state</span>
00838             <span class="keywordflow">if</span>( uMsg == WM_LBUTTONUP ) { m_bMouseLButtonDown = <span class="keyword">false</span>; m_nCurrentButtonMask &amp;= ~MOUSE_LEFT_BUTTON; }
00839             <span class="keywordflow">if</span>( uMsg == WM_MBUTTONUP ) { m_bMouseMButtonDown = <span class="keyword">false</span>; m_nCurrentButtonMask &amp;= ~MOUSE_MIDDLE_BUTTON; }
00840             <span class="keywordflow">if</span>( uMsg == WM_RBUTTONUP ) { m_bMouseRButtonDown = <span class="keyword">false</span>; m_nCurrentButtonMask &amp;= ~MOUSE_RIGHT_BUTTON; }
00841 
00842             <span class="comment">// Release the capture if no mouse buttons down</span>
00843             <span class="keywordflow">if</span>( !m_bMouseLButtonDown  &amp;&amp; 
00844                 !m_bMouseRButtonDown &amp;&amp;
00845                 !m_bMouseMButtonDown )
00846             {
00847                 ReleaseCapture();
00848             }
00849             <span class="keywordflow">break</span>;
00850         }
00851 
00852         <span class="keywordflow">case</span> WM_MOUSEWHEEL:
00853             <span class="comment">// Update member var state</span>
00854             m_nMouseWheelDelta = (<span class="keywordtype">short</span>)HIWORD(wParam) / 120;
00855             <span class="keywordflow">break</span>;
00856     }
00857 
00858     <span class="keywordflow">return</span> FALSE;
00859 }
00860 
00861 
00862 
00863 
00864 <span class="comment">//-----------------------------------------------------------------------------</span>
00865 <span class="comment">// Name: UpdateMouseDelta</span>
00866 <span class="comment">// Desc: Figure out the mouse delta based on mouse movement</span>
00867 <span class="comment">//-----------------------------------------------------------------------------</span>
00868 <span class="keywordtype">void</span> CBaseCamera::UpdateMouseDelta( <span class="keywordtype">float</span> fElapsedTime )
00869 {
00870     UNREFERENCED_PARAMETER( fElapsedTime );
00871 
00872     POINT ptCurMouseDelta;
00873     POINT ptCurMousePos;
00874     
00875     <span class="comment">// Get current position of mouse</span>
00876     GetCursorPos( &amp;ptCurMousePos );
00877 
00878     <span class="comment">// Calc how far it's moved since last frame</span>
00879     ptCurMouseDelta.x = ptCurMousePos.x - m_ptLastMousePosition.x;
00880     ptCurMouseDelta.y = ptCurMousePos.y - m_ptLastMousePosition.y;
00881 
00882     <span class="comment">// Record current position for next time</span>
00883     m_ptLastMousePosition = ptCurMousePos;
00884 
00885     <span class="keywordflow">if</span>( m_bResetCursorAfterMove )
00886     {
00887         <span class="comment">// Set position of camera to center of desktop, </span>
00888         <span class="comment">// so it always has room to move.  This is very useful</span>
00889         <span class="comment">// if the cursor is hidden.  If this isn't done and cursor is hidden, </span>
00890         <span class="comment">// then invisible cursor will hit the edge of the screen </span>
00891         <span class="comment">// and the user can't tell what happened</span>
00892         POINT ptCenter;
00893         RECT rcDesktop;
00894         GetWindowRect( GetDesktopWindow(), &amp;rcDesktop );
00895         ptCenter.x = (rcDesktop.right - rcDesktop.left) / 2;
00896         ptCenter.y = (rcDesktop.bottom - rcDesktop.top) / 2;   
00897         SetCursorPos( ptCenter.x, ptCenter.y );
00898         m_ptLastMousePosition = ptCenter;
00899     }
00900 
00901     <span class="comment">// Smooth the relative mouse data over a few frames so it isn't </span>
00902     <span class="comment">// jerky when moving slowly at low frame rates.</span>
00903     <span class="keywordtype">float</span> fPercentOfNew =  1.0f / m_fFramesToSmoothMouseData;
00904     <span class="keywordtype">float</span> fPercentOfOld =  1.0f - fPercentOfNew;
00905     m_vMouseDelta.x = m_vMouseDelta.x*fPercentOfOld + ptCurMouseDelta.x*fPercentOfNew;
00906     m_vMouseDelta.y = m_vMouseDelta.y*fPercentOfOld + ptCurMouseDelta.y*fPercentOfNew;
00907 
00908     m_vRotVelocity = m_vMouseDelta * m_fRotationScaler;
00909 }
00910 
00911 
00912 
00913 
00914 <span class="comment">//-----------------------------------------------------------------------------</span>
00915 <span class="comment">// Name: UpdateVelocity</span>
00916 <span class="comment">// Desc: Figure out the velocity based on keyboard input &amp; drag if any</span>
00917 <span class="comment">//-----------------------------------------------------------------------------</span>
00918 <span class="keywordtype">void</span> CBaseCamera::UpdateVelocity( <span class="keywordtype">float</span> fElapsedTime )
00919 {
00920     D3DXMATRIX mRotDelta;
00921     D3DXVECTOR3 vAccel = D3DXVECTOR3(0,0,0);
00922 
00923     <span class="keywordflow">if</span>( m_bEnablePositionMovement )
00924     {
00925         <span class="comment">// Update acceleration vector based on keyboard state</span>
00926         <span class="keywordflow">if</span>( IsKeyDown(m_aKeys[CAM_MOVE_FORWARD]) )
00927             vAccel.z += 1.0f;
00928         <span class="keywordflow">if</span>( IsKeyDown(m_aKeys[CAM_MOVE_BACKWARD]) )
00929             vAccel.z -= 1.0f;
00930         <span class="keywordflow">if</span>( m_bEnableYAxisMovement )
00931         {
00932             <span class="keywordflow">if</span>( IsKeyDown(m_aKeys[CAM_MOVE_UP]) )
00933                 vAccel.y += 1.0f;
00934             <span class="keywordflow">if</span>( IsKeyDown(m_aKeys[CAM_MOVE_DOWN]) )
00935                 vAccel.y -= 1.0f;
00936         }
00937         <span class="keywordflow">if</span>( IsKeyDown(m_aKeys[CAM_STRAFE_RIGHT]) )
00938             vAccel.x += 1.0f;
00939         <span class="keywordflow">if</span>( IsKeyDown(m_aKeys[CAM_STRAFE_LEFT]) )
00940             vAccel.x -= 1.0f;
00941     }
00942 
00943     <span class="comment">// Normalize vector so if moving 2 dirs (left &amp; forward), </span>
00944     <span class="comment">// the camera doesn't move faster than if moving in 1 dir</span>
00945     D3DXVec3Normalize( &amp;vAccel, &amp;vAccel );
00946 
00947     <span class="comment">// Scale the acceleration vector</span>
00948     vAccel *= m_fMoveScaler;
00949 
00950     <span class="keywordflow">if</span>( m_bMovementDrag )
00951     {
00952         <span class="comment">// Is there any acceleration this frame?</span>
00953         <span class="keywordflow">if</span>( D3DXVec3LengthSq( &amp;vAccel ) &gt; 0 )
00954         {
00955             <span class="comment">// If so, then this means the user has pressed a movement key\</span>
00956             <span class="comment">// so change the velocity immediately to acceleration </span>
00957             <span class="comment">// upon keyboard input.  This isn't normal physics</span>
00958             <span class="comment">// but it will give a quick response to keyboard input</span>
00959             m_vVelocity = vAccel;
00960             m_fDragTimer = m_fTotalDragTimeToZero;
00961             m_vVelocityDrag = vAccel / m_fDragTimer;
00962         }
00963         <span class="keywordflow">else</span> 
00964         {
00965             <span class="comment">// If no key being pressed, then slowly decrease velocity to 0</span>
00966             <span class="keywordflow">if</span>( m_fDragTimer &gt; 0 )
00967             {
00968                 <span class="comment">// Drag until timer is &lt;= 0</span>
00969                 m_vVelocity -= m_vVelocityDrag * fElapsedTime;
00970                 m_fDragTimer -= fElapsedTime;
00971             }
00972             <span class="keywordflow">else</span>
00973             {
00974                 <span class="comment">// Zero velocity</span>
00975                 m_vVelocity = D3DXVECTOR3(0,0,0);
00976             }
00977         }
00978     }
00979     <span class="keywordflow">else</span>
00980     {
00981         <span class="comment">// No drag, so immediatly change the velocity</span>
00982         m_vVelocity = vAccel;
00983     }
00984 }
00985 
00986 
00987 
00988 
00989 <span class="comment">//-----------------------------------------------------------------------------</span>
00990 <span class="comment">// Name: ConstrainToBoundary</span>
00991 <span class="comment">// Desc: Clamps pV to lie inside m_vMinBoundary &amp; m_vMaxBoundary</span>
00992 <span class="comment">//-----------------------------------------------------------------------------</span>
00993 <span class="keywordtype">void</span> CBaseCamera::ConstrainToBoundary( D3DXVECTOR3* pV )
00994 {
00995     assert( <span class="keyword">false</span> );
00996     <span class="comment">// Constrain vector to a bounding box </span>
00997    <span class="comment">/* pV-&gt;x = max(pV-&gt;x, m_vMinBoundary.x);</span>
00998 <span class="comment">    pV-&gt;y = max(pV-&gt;y, m_vMinBoundary.y);</span>
00999 <span class="comment">    pV-&gt;z = max(pV-&gt;z, m_vMinBoundary.z);</span>
01000 <span class="comment"></span>
01001 <span class="comment">    pV-&gt;x = min(pV-&gt;x, m_vMaxBoundary.x);</span>
01002 <span class="comment">    pV-&gt;y = min(pV-&gt;y, m_vMaxBoundary.y);</span>
01003 <span class="comment">    pV-&gt;z = min(pV-&gt;z, m_vMaxBoundary.z);*/</span>
01004 }
01005 
01006 
01007 
01008 
01009 <span class="comment">//-----------------------------------------------------------------------------</span>
01010 <span class="comment">// Name: MapKey</span>
01011 <span class="comment">// Desc: Maps a windows virtual key to an enum</span>
01012 <span class="comment">//-----------------------------------------------------------------------------</span>
01013 D3DUtil_CameraKeys CBaseCamera::MapKey( UINT nKey )
01014 {
01015     <span class="comment">// This could be upgraded to a method that's user-definable but for </span>
01016     <span class="comment">// simplisity, we'll use a hardcoded mapping.</span>
01017     <span class="keywordflow">switch</span>( nKey )
01018     {
01019         <span class="keywordflow">case</span> VK_LEFT:  <span class="keywordflow">return</span> CAM_STRAFE_LEFT;
01020         <span class="keywordflow">case</span> VK_RIGHT: <span class="keywordflow">return</span> CAM_STRAFE_RIGHT;
01021         <span class="keywordflow">case</span> VK_UP:    <span class="keywordflow">return</span> CAM_MOVE_FORWARD;
01022         <span class="keywordflow">case</span> VK_DOWN:  <span class="keywordflow">return</span> CAM_MOVE_BACKWARD;
01023         <span class="keywordflow">case</span> VK_PRIOR: <span class="keywordflow">return</span> CAM_MOVE_UP;        <span class="comment">// pgup</span>
01024         <span class="keywordflow">case</span> VK_NEXT:  <span class="keywordflow">return</span> CAM_MOVE_DOWN;      <span class="comment">// pgdn</span>
01025 
01026         <span class="keywordflow">case</span> <span class="charliteral">'A'</span>:      <span class="keywordflow">return</span> CAM_STRAFE_LEFT;
01027         <span class="keywordflow">case</span> <span class="charliteral">'D'</span>:      <span class="keywordflow">return</span> CAM_STRAFE_RIGHT;
01028         <span class="keywordflow">case</span> <span class="charliteral">'W'</span>:      <span class="keywordflow">return</span> CAM_MOVE_FORWARD;
01029         <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:      <span class="keywordflow">return</span> CAM_MOVE_BACKWARD;
01030         <span class="keywordflow">case</span> <span class="charliteral">'Q'</span>:      <span class="keywordflow">return</span> CAM_MOVE_DOWN;
01031         <span class="keywordflow">case</span> <span class="charliteral">'E'</span>:      <span class="keywordflow">return</span> CAM_MOVE_UP;
01032 
01033         <span class="keywordflow">case</span> VK_NUMPAD4: <span class="keywordflow">return</span> CAM_STRAFE_LEFT;
01034         <span class="keywordflow">case</span> VK_NUMPAD6: <span class="keywordflow">return</span> CAM_STRAFE_RIGHT;
01035         <span class="keywordflow">case</span> VK_NUMPAD8: <span class="keywordflow">return</span> CAM_MOVE_FORWARD;
01036         <span class="keywordflow">case</span> VK_NUMPAD2: <span class="keywordflow">return</span> CAM_MOVE_BACKWARD;
01037         <span class="keywordflow">case</span> VK_NUMPAD9: <span class="keywordflow">return</span> CAM_MOVE_UP;        
01038         <span class="keywordflow">case</span> VK_NUMPAD3: <span class="keywordflow">return</span> CAM_MOVE_DOWN;      
01039 
01040         <span class="keywordflow">case</span> VK_HOME:   <span class="keywordflow">return</span> CAM_RESET;
01041     }
01042 
01043     <span class="keywordflow">return</span> CAM_UNKNOWN;
01044 }
01045 
01046 
01047 
01048 
01049 <span class="comment">//-----------------------------------------------------------------------------</span>
01050 <span class="comment">// Name: Reset</span>
01051 <span class="comment">// Desc: Reset the camera's position back to the default</span>
01052 <span class="comment">//-----------------------------------------------------------------------------</span>
01053 VOID CBaseCamera::Reset()
01054 {
01055     SetViewParams( &amp;m_vDefaultEye, &amp;m_vDefaultLookAt );
01056 }
01057 
01058 
01059 
01060 
01061 <span class="comment">//-----------------------------------------------------------------------------</span>
01062 <span class="comment">// Name: CFirstPersonCamera</span>
01063 <span class="comment">// Desc: Constructor</span>
01064 <span class="comment">//-----------------------------------------------------------------------------</span>
01065 CFirstPersonCamera::CFirstPersonCamera()
01066 {
01067 }
01068 
01069 
01070 
01071 
01072 <span class="comment">//-----------------------------------------------------------------------------</span>
01073 <span class="comment">// Name: FrameMove</span>
01074 <span class="comment">// Desc: Update the view matrix based on user input &amp; elapsed time</span>
01075 <span class="comment">//-----------------------------------------------------------------------------</span>
01076 VOID CFirstPersonCamera::FrameMove( FLOAT fElapsedTime )
01077 {
01078     <span class="keywordflow">if</span>( IsKeyDown(m_aKeys[CAM_RESET]) )
01079         Reset();
01080 
01081     <span class="comment">// Get the mouse movement (if any) if the mouse button are down</span>
01082     <span class="keywordflow">if</span>( m_bMouseLButtonDown || m_bMouseMButtonDown || m_bMouseRButtonDown ) 
01083         UpdateMouseDelta( fElapsedTime );
01084 
01085     <span class="comment">// Get amount of velocity based on the keyboard input and drag (if any)</span>
01086     UpdateVelocity( fElapsedTime );
01087 
01088     <span class="comment">// Simple euler method to calculate position delta</span>
01089     D3DXVECTOR3 vPosDelta = m_vVelocity * fElapsedTime;
01090 
01091     <span class="comment">// If rotating the camera </span>
01092     <span class="keywordflow">if</span>( m_bMouseLButtonDown ||  m_bMouseMButtonDown || m_bMouseRButtonDown )
01093     {
01094         <span class="comment">// Update the pitch &amp; yaw angle based on mouse movement</span>
01095         <span class="keywordtype">float</span> fYawDelta   = m_vRotVelocity.x;
01096         <span class="keywordtype">float</span> fPitchDelta = m_vRotVelocity.y;
01097 
01098         <span class="comment">// Invert pitch if requested</span>
01099         <span class="keywordflow">if</span>( m_bInvertPitch )
01100             fPitchDelta = -fPitchDelta;
01101 
01102         m_fCameraPitchAngle += fPitchDelta;
01103         m_fCameraYawAngle   += fYawDelta;
01104 
01105         <span class="comment">// Limit pitch to straight up or straight down</span>
01106         <span class="comment">/*m_fCameraPitchAngle = max( -D3DX_PI/2.0f,  m_fCameraPitchAngle );</span>
01107 <span class="comment">        m_fCameraPitchAngle = min( +D3DX_PI/2.0f,  m_fCameraPitchAngle );*/</span>
01108     }
01109 
01110     <span class="comment">// Make a rotation matrix based on the camera's yaw &amp; pitch</span>
01111     D3DXMATRIX mCameraRot;
01112     D3DXMatrixRotationYawPitchRoll( &amp;mCameraRot, m_fCameraYawAngle, m_fCameraPitchAngle, 0 );
01113 
01114     <span class="comment">// Transform vectors based on camera's rotation matrix</span>
01115     D3DXVECTOR3 vWorldUp, vWorldAhead;
01116     D3DXVECTOR3 vLocalUp    = D3DXVECTOR3(0,1,0);
01117     D3DXVECTOR3 vLocalAhead = D3DXVECTOR3(0,0,1);
01118     D3DXVec3TransformCoord( &amp;vWorldUp, &amp;vLocalUp, &amp;mCameraRot );
01119     D3DXVec3TransformCoord( &amp;vWorldAhead, &amp;vLocalAhead, &amp;mCameraRot );
01120 
01121     <span class="comment">// Transform the position delta by the camera's rotation </span>
01122     D3DXVECTOR3 vPosDeltaWorld;
01123     D3DXVec3TransformCoord( &amp;vPosDeltaWorld, &amp;vPosDelta, &amp;mCameraRot );
01124     <span class="keywordflow">if</span>( !m_bEnableYAxisMovement )
01125         vPosDeltaWorld.y = 0.0f;
01126 
01127     <span class="comment">// Move the eye position </span>
01128     m_vEye += vPosDeltaWorld;
01129     <span class="keywordflow">if</span>( m_bClipToBoundary )
01130         ConstrainToBoundary( &amp;m_vEye );
01131 
01132     <span class="comment">// Update the lookAt position based on the eye position </span>
01133     m_vLookAt = m_vEye + vWorldAhead;
01134 
01135     <span class="comment">// Update the view matrix</span>
01136     D3DXMatrixLookAtLH( &amp;m_mView, &amp;m_vEye, &amp;m_vLookAt, &amp;vWorldUp );
01137 
01138     D3DXMatrixInverse( &amp;m_mCameraWorld, NULL, &amp;m_mView );
01139 }
01140 
01141 
01142 
01143 
01144 <span class="comment">//-----------------------------------------------------------------------------</span>
01145 <span class="comment">// Name: CModelViewerCamera</span>
01146 <span class="comment">// Desc: Constructor </span>
01147 <span class="comment">//-----------------------------------------------------------------------------</span>
01148 CModelViewerCamera::CModelViewerCamera()
01149 {
01150     D3DXMatrixIdentity( &amp;m_mWorld );
01151     D3DXMatrixIdentity( &amp;m_mModelRot );
01152     D3DXMatrixIdentity( &amp;m_mModelLastRot );    
01153     m_vModelCenter = D3DXVECTOR3(0,0,0);
01154     m_fRadius    = 5.0f;
01155     m_fDefaultRadius = 5.0f;
01156     m_fMinRadius = 1.0f;
01157     m_fMaxRadius = FLT_MAX;
01158     m_bLimitPitch = <span class="keyword">false</span>;
01159     m_bEnablePositionMovement = <span class="keyword">false</span>;
01160 
01161     m_nRotateModelButtonMask  = MOUSE_LEFT_BUTTON;
01162     m_nZoomButtonMask         = MOUSE_WHEEL;
01163     m_nRotateCameraButtonMask = MOUSE_RIGHT_BUTTON;
01164 }
01165 
01166 
01167 
01168 
01169 <span class="comment">//-----------------------------------------------------------------------------</span>
01170 <span class="comment">// Name: FrameMove</span>
01171 <span class="comment">// Desc: Update the view matrix &amp; the model's world matrix based </span>
01172 <span class="comment">//       on user input &amp; elapsed time</span>
01173 <span class="comment">//-----------------------------------------------------------------------------</span>
01174 VOID CModelViewerCamera::FrameMove( FLOAT fElapsedTime )
01175 {
01176     <span class="keywordflow">if</span>( IsKeyDown(m_aKeys[CAM_RESET]) )
01177         Reset();
01178 
01179     <span class="comment">// Get the mouse movement (if any) if the mouse button are down</span>
01180     <span class="keywordflow">if</span>( m_nCurrentButtonMask != 0 ) 
01181         UpdateMouseDelta( fElapsedTime );
01182 
01183     <span class="comment">// Get amount of velocity based on the keyboard input and drag (if any)</span>
01184     UpdateVelocity( fElapsedTime );
01185 
01186     <span class="comment">// Simple euler method to calculate position delta</span>
01187     D3DXVECTOR3 vPosDelta = m_vVelocity * fElapsedTime;
01188 
01189     <span class="comment">// Change the radius from the camera to the model based on wheel scrolling</span>
01190     <span class="keywordflow">if</span>( m_nMouseWheelDelta &amp;&amp; m_nZoomButtonMask == MOUSE_WHEEL )
01191         m_fRadius -= m_nMouseWheelDelta * m_fRadius * 0.1f;
01192     <span class="keywordflow">if</span> (m_fRadius &lt; m_fMaxRadius) m_fRadius = m_fMaxRadius;
01193     <span class="keywordflow">if</span> (m_fRadius &gt; m_fMinRadius) m_fRadius = m_fMinRadius;
01194     m_nMouseWheelDelta = 0;
01195 
01196     <span class="comment">// Get the inverse of the arcball's rotation matrix</span>
01197     D3DXMATRIX mCameraRot;
01198     D3DXMatrixInverse( &amp;mCameraRot, NULL, m_ViewArcBall.GetRotationMatrix() );
01199 
01200     <span class="comment">// Transform vectors based on camera's rotation matrix</span>
01201     D3DXVECTOR3 vWorldUp, vWorldAhead;
01202     D3DXVECTOR3 vLocalUp    = D3DXVECTOR3(0,1,0);
01203     D3DXVECTOR3 vLocalAhead = D3DXVECTOR3(0,0,1);
01204     D3DXVec3TransformCoord( &amp;vWorldUp, &amp;vLocalUp, &amp;mCameraRot );
01205     D3DXVec3TransformCoord( &amp;vWorldAhead, &amp;vLocalAhead, &amp;mCameraRot );
01206 
01207     <span class="comment">// Transform the position delta by the camera's rotation </span>
01208     D3DXVECTOR3 vPosDeltaWorld;
01209     D3DXVec3TransformCoord( &amp;vPosDeltaWorld, &amp;vPosDelta, &amp;mCameraRot );
01210 
01211     <span class="comment">// Move the lookAt position </span>
01212     m_vLookAt += vPosDeltaWorld;
01213     <span class="keywordflow">if</span>( m_bClipToBoundary )
01214         ConstrainToBoundary( &amp;m_vLookAt );
01215 
01216     <span class="comment">// Update the eye point based on a radius away from the lookAt position</span>
01217     m_vEye = m_vLookAt - vWorldAhead * m_fRadius;
01218 
01219     <span class="comment">// Update the view matrix</span>
01220     D3DXMatrixLookAtLH( &amp;m_mView, &amp;m_vEye, &amp;m_vLookAt, &amp;vWorldUp );
01221 
01222     D3DXMATRIX mInvView;
01223     D3DXMatrixInverse( &amp;mInvView, NULL, &amp;m_mView );
01224     mInvView._41 = mInvView._42 = mInvView._43 = 0;
01225 
01226     D3DXMATRIX mModelLastRotInv;
01227     D3DXMatrixInverse(&amp;mModelLastRotInv, NULL, &amp;m_mModelLastRot);
01228 
01229     <span class="comment">// Accumulate the delta of the arcball's rotation in view space.</span>
01230     <span class="comment">// Note that per-frame delta rotations could be problematic over long periods of time.</span>
01231     D3DXMATRIX mModelRot;
01232     mModelRot = *m_WorldArcBall.GetRotationMatrix();
01233     m_mModelRot *= m_mView * mModelLastRotInv * mModelRot * mInvView;
01234     m_mModelLastRot = mModelRot;
01235 
01236     <span class="comment">// Since we're accumulating delta rotations, we need to orthonormalize </span>
01237     <span class="comment">// the matrix to prevent eventual matrix skew</span>
01238     D3DXVECTOR3* pXBasis = (D3DXVECTOR3*) &amp;m_mWorld._11;
01239     D3DXVECTOR3* pYBasis = (D3DXVECTOR3*) &amp;m_mWorld._21;
01240     D3DXVECTOR3* pZBasis = (D3DXVECTOR3*) &amp;m_mWorld._31;
01241     D3DXVec3Normalize( pXBasis, pXBasis );
01242     D3DXVec3Cross( pYBasis, pZBasis, pXBasis );
01243     D3DXVec3Normalize( pYBasis, pYBasis );
01244     D3DXVec3Cross( pZBasis, pXBasis, pYBasis );
01245 
01246     <span class="comment">// Translate the rotation matrix to the same position as the lookAt position</span>
01247     m_mModelRot._41 = m_vLookAt.x;
01248     m_mModelRot._42 = m_vLookAt.y;
01249     m_mModelRot._43 = m_vLookAt.z;
01250 
01251     <span class="comment">// Translate world matrix so its at the center of the model</span>
01252     D3DXMATRIX mTrans;
01253     D3DXMatrixTranslation( &amp;mTrans, -m_vModelCenter.x, -m_vModelCenter.y, -m_vModelCenter.z );
01254     m_mWorld = mTrans * m_mModelRot;
01255 }
01256 
01257 
01258 
01259 
01260 <span class="comment">//-----------------------------------------------------------------------------</span>
01261 <span class="comment">// Name: Reset</span>
01262 <span class="comment">// Desc: Reset the camera's position back to the default</span>
01263 <span class="comment">//-----------------------------------------------------------------------------</span>
01264 VOID CModelViewerCamera::Reset()
01265 {
01266     CBaseCamera::Reset();
01267 
01268     D3DXMatrixIdentity( &amp;m_mWorld );
01269     m_fRadius = m_fDefaultRadius;
01270     m_WorldArcBall.Reset();
01271     m_ViewArcBall.Reset();
01272 }
01273 
01274 
01275 
01276 <span class="comment">//-----------------------------------------------------------------------------</span>
01277 <span class="comment">// Name: HandleMessages</span>
01278 <span class="comment">// Desc: Call this from your message proc so this class can handle window messages</span>
01279 <span class="comment">//-----------------------------------------------------------------------------</span>
01280 LRESULT CModelViewerCamera::HandleMessages( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
01281 {
01282     CBaseCamera::HandleMessages( hWnd, uMsg, wParam, lParam );
01283 
01284     <span class="keywordflow">if</span>( (uMsg == WM_LBUTTONDOWN &amp;&amp; m_nRotateModelButtonMask == MOUSE_LEFT_BUTTON) ||
01285         (uMsg == WM_MBUTTONDOWN &amp;&amp; m_nRotateModelButtonMask == MOUSE_MIDDLE_BUTTON) ||
01286         (uMsg == WM_RBUTTONDOWN &amp;&amp; m_nRotateModelButtonMask == MOUSE_RIGHT_BUTTON) )
01287     {
01288         <span class="keywordtype">int</span> iMouseX = GET_X_LPARAM(lParam);
01289         <span class="keywordtype">int</span> iMouseY = GET_Y_LPARAM(lParam);
01290         m_WorldArcBall.OnBegin( iMouseX, iMouseY );            
01291     }
01292 
01293     <span class="keywordflow">if</span>( (uMsg == WM_LBUTTONDOWN &amp;&amp; m_nRotateCameraButtonMask == MOUSE_LEFT_BUTTON) ||
01294         (uMsg == WM_MBUTTONDOWN &amp;&amp; m_nRotateCameraButtonMask == MOUSE_MIDDLE_BUTTON) ||
01295         (uMsg == WM_RBUTTONDOWN &amp;&amp; m_nRotateCameraButtonMask == MOUSE_RIGHT_BUTTON) )
01296     {
01297         <span class="keywordtype">int</span> iMouseX = GET_X_LPARAM(lParam);
01298         <span class="keywordtype">int</span> iMouseY = GET_Y_LPARAM(lParam);
01299         m_ViewArcBall.OnBegin( iMouseX, iMouseY );            
01300     }
01301 
01302     <span class="keywordflow">if</span>( uMsg == WM_MOUSEMOVE )
01303     {
01304         <span class="keywordtype">int</span> iMouseX = GET_X_LPARAM(lParam);
01305         <span class="keywordtype">int</span> iMouseY = GET_Y_LPARAM(lParam);
01306         m_WorldArcBall.OnMove( iMouseX, iMouseY );
01307         m_ViewArcBall.OnMove( iMouseX, iMouseY );
01308     }
01309 
01310     <span class="keywordflow">if</span>( (uMsg == WM_LBUTTONUP &amp;&amp; m_nRotateModelButtonMask == MOUSE_LEFT_BUTTON) ||
01311         (uMsg == WM_MBUTTONUP &amp;&amp; m_nRotateModelButtonMask == MOUSE_MIDDLE_BUTTON) ||
01312         (uMsg == WM_RBUTTONUP &amp;&amp; m_nRotateModelButtonMask == MOUSE_RIGHT_BUTTON) )
01313     {
01314         m_WorldArcBall.OnEnd();
01315     }
01316 
01317     <span class="keywordflow">if</span>( (uMsg == WM_LBUTTONUP &amp;&amp; m_nRotateCameraButtonMask == MOUSE_LEFT_BUTTON) ||
01318         (uMsg == WM_MBUTTONUP &amp;&amp; m_nRotateCameraButtonMask == MOUSE_MIDDLE_BUTTON) ||
01319         (uMsg == WM_RBUTTONUP &amp;&amp; m_nRotateCameraButtonMask == MOUSE_RIGHT_BUTTON) )
01320     {
01321         m_ViewArcBall.OnEnd();
01322     }
01323 
01324     <span class="keywordflow">return</span> FALSE;
01325 }
01326 
01327 
01328 
</pre></div><hr><address style="align: right;"><small>
Generated on Tue Jun 13 11:14:34 2006 for gRenderDX9 by <a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 width=110 height=53>
</a> 1.3.1 using KingsTools</small></address>
</body>
</html>
