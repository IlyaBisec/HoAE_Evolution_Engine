<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gRenderDX9: d3dPicture.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.1 -->
<h1>d3dPicture.cpp</h1><div class="fragment"><pre>00001 <span class="comment">/*****************************************************************</span>
00002 <span class="comment">/*  File:   rsPictureManagerDX.cpp                                   </span>
00003 <span class="comment">/*  Desc:   PictureInstance manager implementation</span>
00004 <span class="comment">/*  Author: Silver, Copyright (C) GSC Game World                  </span>
00005 <span class="comment">/*  Date:   Feb 2002                                             </span>
00006 <span class="comment">/*****************************************************************/</span>
00007 <span class="preprocessor">#include "gRenderPch.h"</span>
00008 
00009 <span class="preprocessor">#include "ITexture.h"</span>
00010 <span class="preprocessor">#include "IPictureManager.h"</span>
00011 <span class="preprocessor">#include "IResourceManager.h"</span>
00012 <span class="preprocessor">#include "vMesh.h"</span>
00013 <span class="preprocessor">#include "d3dAdapt.h"</span>
00014 <span class="preprocessor">#include "kStaticArray.hpp"</span>
00015 
00016 IDirect3DDevice9* GetDirect3DDevice();
00017 IDirect3DSurface9* GetDirect3DSurface( <span class="keywordtype">int</span> texID );
00018 
00019 <span class="comment">/*****************************************************************/</span>
00020 <span class="comment">/*  Class:  PictureInstance</span>
00021 <span class="comment">/*  Desc:   Single picture file instance</span>
00022 <span class="comment">/*****************************************************************/</span>
00023 <span class="keyword">class </span>PictureInstance
00024 {
00025 <span class="keyword">public</span>:
00026     <span class="keyword">struct </span>Chunk
00027     {
00028         <span class="keywordtype">int</span>             m_TexID;
00029         Rct             m_Extents;
00030         Rct             m_UV;
00031     }; <span class="comment">// struct Chunk</span>
00032 
00033 <span class="keyword">protected</span>:
00034     IDirect3DSurface9*      m_pSurface;     
00035     std::vector&lt;Chunk&gt;      m_Chunks;
00036 
00037     <span class="keywordtype">int</span>                     m_Width;
00038     <span class="keywordtype">int</span>                     m_Height;
00039     <span class="keywordtype">int</span>                     m_NMipLevels;
00040     <span class="keywordtype">char</span>                    m_FileName[_MAX_PATH];
00041     ColorFormat             m_ColorFormat;
00042     PictureFileFormat       m_FileFormat;
00043     <span class="keywordtype">int</span>                     m_Stride;
00044     <span class="keywordtype">bool</span>                    m_bValid;
00045     <span class="keywordtype">bool</span>                    m_bLoaded;
00046     
00047     <span class="keyword">friend</span> <span class="keyword">class        </span>PictureManager;
00048 
00049 <span class="keyword">public</span>:
00050                 PictureInstance ();
00051                 ~PictureInstance();
00052 
00053     <span class="keywordtype">bool</span>        HasFileName     ( <span class="keyword">const</span> <span class="keywordtype">char</span>* name ) { <span class="keywordflow">return</span> (stricmp( m_FileName, name ) == 0); }
00054     <span class="keywordtype">bool</span>        IsLoaded        ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_bLoaded; }
00055     <span class="keywordtype">bool</span>        IsValid         ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_bValid; }
00056 
00057     <span class="keywordtype">void</span>        Load            ();
00058     <span class="keywordtype">void</span>        Unload          ();
00059     <span class="keywordtype">int</span>         GetNChunks      ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_Chunks.size(); }
00060     Chunk&amp;      GetChunk        ( <span class="keywordtype">int</span> idx ) { <span class="keywordflow">return</span> m_Chunks[idx]; }
00061 
00062 
00063     <span class="keywordtype">void</span>        ClearChunks     ();
00064     <span class="keywordtype">void</span>        CreateChunks    ();
00065 
00066 }; <span class="comment">// class PictureInstance</span>
00067 
00068 <span class="keyword">const</span> <span class="keywordtype">int</span>           c_ChunkSide         = 256;
00069 <span class="keyword">const</span> ColorFormat   c_DrawFormat        = cfARGB8888;
00070 <span class="keyword">const</span> <span class="keywordtype">int</span>           c_MaxPictures       = 128;
00071 <span class="comment">/*****************************************************************/</span>
00072 <span class="comment">/*  Class:  PictureManager</span>
00073 <span class="comment">/*  Desc:   Implementation of the picture manager using D3DX</span>
00074 <span class="comment">/*****************************************************************/</span>
00075 <span class="keyword">class </span>PictureManager : <span class="keyword">public</span> IPictureManager, <span class="keyword">public</span> IDeviceClient
00076 {
00077     static_array&lt;PictureInstance, 
00078                  c_MaxPictures&gt;         m_Pic;
00079     BaseMesh                            m_Primitive;
00080     DWORD                               m_Diffuse;
00081     <span class="keywordtype">bool</span>                                m_bFiltering;
00082     Matrix4D                            m_TM;
00083     <span class="keywordtype">bool</span>                                m_bTMEnabled;
00084 
00085 <span class="keyword">public</span>:
00086                                 PictureManager  ();
00087     <span class="keyword">virtual</span> <span class="keywordtype">int</span>                 GetImageID      ( <span class="keyword">const</span> <span class="keywordtype">char</span>* fileName );
00088     <span class="keyword">virtual</span> <span class="keywordtype">bool</span>                LoadImage       ( <span class="keywordtype">int</span> imgID );
00089     <span class="keyword">virtual</span> <span class="keywordtype">bool</span>                UnloadImage     ( <span class="keywordtype">int</span> imgID );
00090     <span class="keyword">virtual</span> <span class="keywordtype">void</span>                Purge           ();
00091     <span class="keyword">virtual</span> BYTE*               GetPixels       ( <span class="keywordtype">int</span> imgID );
00092     <span class="keyword">virtual</span> <span class="keywordtype">int</span>                 GetWidth        ( <span class="keywordtype">int</span> imgID );
00093     <span class="keyword">virtual</span> <span class="keywordtype">int</span>                 GetHeight       ( <span class="keywordtype">int</span> imgID );
00094     <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>*         GetFileName     ( <span class="keywordtype">int</span> imgID );
00095     <span class="keyword">virtual</span> <span class="keywordtype">bool</span>                DrawImage       ( <span class="keywordtype">int</span> imgID, <span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y, <span class="keywordtype">float</span> z = 0.0f );
00096     <span class="keyword">virtual</span> <span class="keywordtype">bool</span>                DrawImage       ( <span class="keywordtype">int</span> imgID, <span class="keyword">const</span> Rct&amp; ext, <span class="keywordtype">float</span> z = 0.0f );
00097     <span class="keyword">virtual</span> <span class="keywordtype">bool</span>                IsValid         ( <span class="keywordtype">int</span> imgID );
00098     <span class="keyword">virtual</span> <span class="keywordtype">bool</span>                IsLoaded        ( <span class="keywordtype">int</span> imgID );
00099     <span class="keyword">virtual</span> <span class="keywordtype">void</span>                SetDiffuse      ( DWORD color ) { m_Diffuse = color; }
00100     <span class="keyword">virtual</span> <span class="keywordtype">void</span>                SetFiltering    ( <span class="keywordtype">bool</span> bFilter = <span class="keyword">true</span> );
00101 
00102     <span class="keyword">virtual</span> PictureFileFormat   GetFileFormat   ( <span class="keywordtype">int</span> imgID );
00103     <span class="keyword">virtual</span> ColorFormat         GetColorFormat  ( <span class="keywordtype">int</span> imgID );
00104 
00105     <span class="keyword">virtual</span> <span class="keywordtype">void</span>                OnDestroyRS     ();
00106     <span class="keyword">virtual</span> <span class="keywordtype">void</span>                OnCreateRS      ();
00107 
00108     <span class="keyword">virtual</span> <span class="keywordtype">void</span>                SetTransform    ( <span class="keyword">const</span> Matrix4D&amp; tm ) { m_TM = tm; }
00109     <span class="keyword">virtual</span> <span class="keyword">const</span> Matrix4D&amp;     GetTransform    ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_TM; }
00110     <span class="keyword">virtual</span> <span class="keywordtype">void</span>                EnableTransform ( <span class="keywordtype">bool</span> bEnable = <span class="keyword">true</span> ) { m_bTMEnabled = bEnable; }
00111     <span class="keyword">virtual</span> <span class="keywordtype">bool</span>                TransformEnabled()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_bTMEnabled; }
00112 
00113 }; <span class="comment">// class PictureManager</span>
00114 
00115 IPictureManager* GetPictureManager()
00116 {
00117     <span class="keyword">static</span> PictureManager s_PictureManager;
00118     <span class="keywordflow">return</span> &amp;s_PictureManager;
00119 }
00120 
00121 DIALOGS_API IPictureManager* IPM = NULL;
00122 
00123 <span class="keywordtype">void</span> InitPictureManager()
00124 {
00125     IPM = GetPictureManager();
00126 }
00127 
00128 <span class="comment">/*****************************************************************/</span>
00129 <span class="comment">/*  PictureInstance implementation</span>
00130 <span class="comment">/*****************************************************************/</span>
00131 PictureInstance::PictureInstance()
00132 {
00133     m_Width         = 0;
00134     m_Height        = 0;
00135     m_NMipLevels    = 0;
00136     m_FileName[0]   = 0;
00137     m_ColorFormat   = cfUnknown;
00138     m_FileFormat    = pfUnknown;
00139     m_Stride        = 0;
00140     m_bValid        = <span class="keyword">false</span>;
00141     m_pSurface      = NULL;
00142     m_bLoaded       = <span class="keyword">false</span>;
00143 } <span class="comment">// PictureInstance::PictureInstance</span>
00144 
00145 PictureInstance::~PictureInstance()
00146 {
00147     Unload();
00148 }
00149 
00150 <span class="keywordtype">void</span> PictureInstance::Load()
00151 {
00152     <span class="keywordflow">if</span> (IsLoaded()) <span class="keywordflow">return</span>;
00153     <span class="keywordtype">int</span> resID = IRM-&gt;FindResource( m_FileName );
00154     <span class="keywordflow">if</span> (resID == -1) 
00155     {
00156         Log.Error( <span class="stringliteral">"Could not find picture resource: %s"</span>, m_FileName );
00157         <span class="keywordflow">return</span>;
00158     }
00159 
00160     Unload();
00161     <span class="keywordtype">int</span> size = 0;
00162     BYTE* buf = IRM-&gt;LockData( resID, size );
00163     <span class="keywordflow">if</span> (!buf) <span class="keywordflow">return</span>;    
00164     IDirect3DDevice9* pDevice = GetDirect3DDevice();
00165     DX_CHK( pDevice-&gt;CreateOffscreenPlainSurface( m_Width, m_Height, 
00166                                                     ConvertColorFormat( m_ColorFormat ), 
00167                                                     D3DPOOL_SCRATCH, 
00168                                                     &amp;m_pSurface, NULL ) );
00169     D3DXIMAGE_INFO info; 
00170     HRESULT hRes = D3DXLoadSurfaceFromFileInMemory( m_pSurface, NULL, NULL, buf, size, NULL, D3DX_FILTER_NONE, 0, &amp;info );
00171     <span class="keywordflow">if</span> (hRes != S_OK)
00172     {
00173         Log.Error( <span class="stringliteral">"Could not load image from file %s"</span>, m_FileName );
00174     }
00175 
00176     IRM-&gt;UnlockData( resID );
00177    
00178     CreateChunks();
00179     m_bLoaded = <span class="keyword">true</span>;
00180 
00181 } <span class="comment">// PictureInstance::Load</span>
00182 
00183 <span class="keywordtype">void</span> PictureInstance::Unload()
00184 {
00185     m_pSurface = NULL;
00186     m_bLoaded  = <span class="keyword">false</span>;
00187     ClearChunks();
00188 } <span class="comment">// PictureInstance::Unload</span>
00189 
00190 <span class="keywordtype">void</span> PictureInstance::ClearChunks()
00191 {
00192     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_Chunks.size(); i++)
00193     {
00194         IRS-&gt;DeleteTexture( m_Chunks[i].m_TexID );
00195     }
00196     m_Chunks.clear();
00197 } <span class="comment">// PictureInstance::ClearChunks</span>
00198 
00199 <span class="keyword">const</span> <span class="keywordtype">float</span> c_TexelBias = 0.375f;
00200 <span class="keywordtype">void</span> PictureInstance::CreateChunks()
00201 {
00202     <span class="keywordflow">if</span> (m_Width == 0 || m_Height == 0) <span class="keywordflow">return</span>;
00203     ClearChunks();
00204     
00205     <span class="keywordtype">int</span> cx = 0; 
00206     <span class="keywordtype">int</span> cy = 0;
00207     <span class="keywordflow">while</span> (cy &lt; m_Height)
00208     {
00209         cx = 0;
00210         <span class="keywordflow">while</span> (cx &lt; m_Width)
00211         {
00212             m_Chunks.push_back( Chunk() );
00213             Chunk&amp; chunk = m_Chunks.back();
00214             <span class="keywordtype">char</span> texName[_MAX_PATH];
00215             sprintf( texName, <span class="stringliteral">"%s_%d%d"</span>, m_FileName, cx/c_ChunkSide, cy/c_ChunkSide );
00216             chunk.m_TexID       = IRS-&gt;CreateTexture( texName, c_ChunkSide, c_ChunkSide, c_DrawFormat, 1, tmpManaged );
00217             chunk.m_Extents.x   = cx + c_TexelBias;
00218             chunk.m_Extents.y   = cy + c_TexelBias;
00219             
00220             <span class="keywordtype">float</span> right         = tmin( m_Width,  cx + c_ChunkSide );
00221             <span class="keywordtype">float</span> bottom        = tmin( m_Height, cy + c_ChunkSide );
00222             
00223             chunk.m_Extents.w   = right - cx;
00224             chunk.m_Extents.h   = bottom - cy;
00225 
00226             chunk.m_UV.x        = 0.0f;
00227             chunk.m_UV.y        = 0.0f;
00228             chunk.m_UV.w        = (right  - cx)/c_ChunkSide;
00229             chunk.m_UV.h        = (bottom - cy)/c_ChunkSide;
00230 
00231             IDirect3DSurface9* pChunkSurface = GetDirect3DSurface( chunk.m_TexID );
00232             RECT srcRect;
00233             srcRect.left        = cx;
00234             srcRect.top         = cy;
00235             srcRect.right       = right;
00236             srcRect.bottom      = bottom;
00237 
00238             RECT dstRect;
00239             dstRect.left        = 0;
00240             dstRect.top         = 0;
00241             dstRect.right       = right - cx;
00242             dstRect.bottom      = bottom - cy;
00243 
00244             DX_CHK( D3DXLoadSurfaceFromSurface( pChunkSurface, NULL, &amp;dstRect, m_pSurface, NULL, &amp;srcRect, D3DX_DEFAULT, 0 ) );
00245             pChunkSurface-&gt;Release();
00246 
00247             <span class="comment">/*char path[_MAX_PATH];</span>
00248 <span class="comment">            sprintf( path, "c:\\dumps\\p%d_%d.dds", cx/c_ChunkSide, cy/c_ChunkSide );</span>
00249 <span class="comment">            IRS-&gt;SaveTexture( chunk.m_TexID, path );*/</span>
00250             
00251             cx += c_ChunkSide;
00252         }
00253         cy += c_ChunkSide;
00254     }
00255     SAFE_RELEASE( m_pSurface );
00256 
00257 } <span class="comment">// PictureInstance::CreateChunks</span>
00258 
00259 <span class="comment">/*****************************************************************/</span>
00260 <span class="comment">/*  PictureManager implementation</span>
00261 <span class="comment">/*****************************************************************/</span>
00262 PictureManager::PictureManager()
00263 {
00264     m_Primitive.create  ( 4, 6, vfVertexTnL, ptTriangleList );
00265     m_Primitive.setNVert( 4 );
00266     m_Primitive.setNPri ( 2 );
00267     m_Primitive.setNInd ( 6 );
00268 
00269     WORD* pIdx = m_Primitive.getIndices();
00270     pIdx[0] = 0; pIdx[1] = 1; pIdx[2] = 2;
00271     pIdx[3] = 2; pIdx[4] = 1; pIdx[5] = 3;
00272 
00273     m_Diffuse       = 0xFFFFFFFF;
00274     m_bFiltering    = <span class="keyword">false</span>;
00275     m_TM            = Matrix4D::identity;
00276     m_bTMEnabled    = <span class="keyword">false</span>;
00277 } <span class="comment">// PictureManager::PictureManager</span>
00278 
00279 <span class="keywordtype">int</span> PictureManager::GetImageID( <span class="keyword">const</span> <span class="keywordtype">char</span>* fileName )
00280 {
00281     <span class="keywordflow">if</span> (fileName[0] == 0) <span class="keywordflow">return</span> -1;
00282 
00283     <span class="keywordtype">int</span> resID = IRM-&gt;FindResource( fileName );
00284     <span class="keywordflow">if</span> (resID == -1) 
00285     {
00286         Log.Error( <span class="stringliteral">"Could not find picture resource: %s"</span>, fileName );
00287         <span class="keywordflow">return</span> -1;
00288     }
00289     
00290     <span class="keywordtype">int</span> size  = 0;
00291     BYTE* buf = IRM-&gt;LockData( resID, size );
00292     <span class="keywordflow">if</span> (!buf) <span class="keywordflow">return</span> -1;
00293 
00294     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_Pic.size(); i++)
00295     {
00296         <span class="keywordflow">if</span> (m_Pic[i].HasFileName( fileName )) { LoadImage( i ); <span class="keywordflow">return</span> i; }
00297     }
00298     
00299     D3DXIMAGE_INFO info; 
00300     HRESULT hRes = D3DXGetImageInfoFromFileInMemory( buf, size, &amp;info );
00301     <span class="keywordflow">if</span> (hRes != S_OK)
00302     {
00303         Log.Error( <span class="stringliteral">"Could not load picture file %s."</span>, fileName );
00304         <span class="keywordflow">return</span> -1;
00305     }
00306     IRM-&gt;UnlockData( resID );
00307     
00308     <span class="keywordflow">if</span> (m_Pic.size() == c_MaxPictures)
00309     {
00310         Log.Error( <span class="stringliteral">"PictureManager: max picture number reached."</span> );
00311         <span class="keywordflow">return</span> -1;
00312     }
00313 
00314     PictureInstance&amp; pic = m_Pic.expand();
00315     strcpy( pic.m_FileName, fileName );
00316     pic.m_Width         = info.Width;
00317     pic.m_Height        = info.Height;
00318     pic.m_FileFormat    = (PictureFileFormat)info.ImageFileFormat;
00319     pic.m_NMipLevels    = info.MipLevels;
00320     pic.m_bValid        = <span class="keyword">true</span>;
00321     pic.m_ColorFormat   = ConvertColorFormat( info.Format );
00322     <span class="keywordflow">return</span> m_Pic.size() - 1;
00323 } <span class="comment">// PictureManager::GetImageID</span>
00324 
00325 <span class="keywordtype">bool</span> PictureManager::LoadImage( <span class="keywordtype">int</span> imgID )
00326 {
00327     <span class="keywordflow">if</span> (imgID &lt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00328     m_Pic[imgID].Load();
00329     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00330 }
00331 
00332 <span class="keywordtype">bool</span> PictureManager::UnloadImage( <span class="keywordtype">int</span> imgID )
00333 {
00334     <span class="keywordflow">if</span> (imgID &lt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00335     m_Pic[imgID].Unload();
00336     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00337 }
00338 
00339 <span class="keywordtype">void</span> PictureManager::Purge()
00340 {
00341     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_Pic.size(); i++)
00342     {
00343         m_Pic[i].Unload();
00344     }
00345 } <span class="comment">// PictureManager::Purge</span>
00346 
00347 BYTE* PictureManager::GetPixels( <span class="keywordtype">int</span> imgID )
00348 {
00349     <span class="keywordflow">return</span> 0;
00350 }
00351 
00352 <span class="keywordtype">int</span> PictureManager::GetWidth( <span class="keywordtype">int</span> imgID )
00353 {
00354     <span class="keywordflow">if</span> (imgID &lt; 0) <span class="keywordflow">return</span> 0;
00355     <span class="keywordflow">return</span> m_Pic[imgID].m_Width;
00356 }
00357 
00358 <span class="keywordtype">int</span> PictureManager::GetHeight( <span class="keywordtype">int</span> imgID )
00359 {
00360     <span class="keywordflow">if</span> (imgID &lt; 0) <span class="keywordflow">return</span> 0;
00361     <span class="keywordflow">return</span> m_Pic[imgID].m_Height;
00362 }
00363 
00364 <span class="keyword">const</span> <span class="keywordtype">char</span>* PictureManager::GetFileName( <span class="keywordtype">int</span> imgID )
00365 {
00366     <span class="keywordflow">if</span> (imgID &lt; 0) <span class="keywordflow">return</span> 0;
00367     <span class="keywordflow">return</span> m_Pic[imgID].m_FileName;
00368 }
00369 
00370 <span class="keywordtype">bool</span> PictureManager::DrawImage( <span class="keywordtype">int</span> imgID, <span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y, <span class="keywordtype">float</span> z )
00371 {
00372     <span class="keywordflow">if</span> (imgID &lt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00373     PictureInstance&amp; pic = m_Pic[imgID];
00374     <span class="keywordflow">return</span> DrawImage( imgID, Rct( x, y, pic.m_Width, pic.m_Height ), z );
00375 } <span class="comment">// PictureManager::DrawImage</span>
00376 
00377 <span class="keywordtype">bool</span> PictureManager::DrawImage( <span class="keywordtype">int</span> imgID, <span class="keyword">const</span> Rct&amp; ext, <span class="keywordtype">float</span> z )
00378 {
00379     <span class="keywordflow">if</span> (imgID &lt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00380     PictureInstance&amp; pic = m_Pic[imgID];
00381     <span class="keywordflow">if</span> (!pic.IsLoaded()) pic.Load();
00382     <span class="keywordtype">float</span> wScale = ext.w / float( pic.m_Width  );
00383     <span class="keywordtype">float</span> hScale = ext.h / float( pic.m_Height );
00384     
00385  
00386     <span class="keyword">static</span> <span class="keywordtype">int</span> shID = IRS-&gt;GetShaderID( <span class="stringliteral">"hud"</span> );
00387     <span class="keyword">static</span> <span class="keywordtype">int</span> shID_L = IRS-&gt;GetShaderID( <span class="stringliteral">"hud_L"</span> );
00388 
00389     <span class="keywordflow">if</span> (m_bFiltering) m_Primitive.setShader( shID_L );
00390     <span class="keywordflow">else</span> m_Primitive.setShader( shID );
00391 
00392     <span class="keywordtype">int</span> nChunks = pic.GetNChunks();
00393     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nChunks; i++)
00394     {
00395         PictureInstance::Chunk&amp; chunk = pic.GetChunk( i );
00396         VertexTnL* v = (VertexTnL*)m_Primitive.getVertexData();
00397         v[0].x          = chunk.m_Extents.x*wScale + ext.x;
00398         v[0].y          = chunk.m_Extents.y*hScale + ext.y;
00399         v[0].u          = chunk.m_UV.x;
00400         v[0].v          = chunk.m_UV.y;
00401         v[0].z          = z;
00402         v[0].w          = 1.0f;
00403         v[0].diffuse    = m_Diffuse;
00404 
00405         v[1].x          = chunk.m_Extents.GetRight()*wScale + ext.x;
00406         v[1].y          = chunk.m_Extents.y*hScale + ext.y;
00407         v[1].u          = chunk.m_UV.GetRight();
00408         v[1].v          = chunk.m_UV.y;
00409         v[1].z          = z;
00410         v[1].w          = 1.0f;
00411         v[1].diffuse    = m_Diffuse;
00412 
00413         v[2].x          = chunk.m_Extents.x*wScale + ext.x;
00414         v[2].y          = chunk.m_Extents.GetBottom()*hScale + ext.y;
00415         v[2].u          = chunk.m_UV.x;
00416         v[2].v          = chunk.m_UV.GetBottom();
00417         v[2].z          = z;
00418         v[2].w          = 1.0f;
00419         v[2].diffuse    = m_Diffuse;
00420 
00421         v[3].x          = chunk.m_Extents.GetRight()*wScale + ext.x;
00422         v[3].y          = chunk.m_Extents.GetBottom()*hScale + ext.y;
00423         v[3].u          = chunk.m_UV.GetRight();
00424         v[3].v          = chunk.m_UV.GetBottom();
00425         v[3].z          = z;
00426         v[3].w          = 1.0f;
00427         v[3].diffuse    = m_Diffuse;
00428         
00429         <span class="keywordflow">if</span> (m_bTMEnabled)
00430         {
00431             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 4; j++)
00432             {
00433                 Vector3D cv( v[j].x, v[j].y, v[j].z );
00434                 m_TM.transformPt( cv );
00435                 v[j].x = cv.x;
00436                 v[j].y = cv.y;
00437                 v[j].z = cv.z;
00438             }
00439         }
00440 
00441         m_Primitive.setTexture( chunk.m_TexID );
00442         DrawBM( m_Primitive );
00443     }
00444     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00445 } <span class="comment">// PictureManager::DrawImage</span>
00446 
00447 <span class="keywordtype">bool</span> PictureManager::IsValid( <span class="keywordtype">int</span> imgID )
00448 {
00449     <span class="keywordflow">if</span> (imgID &lt; 0) <span class="keywordflow">return</span> 0;
00450     <span class="keywordflow">return</span> m_Pic[imgID].IsValid();
00451 }
00452 
00453 PictureFileFormat PictureManager::GetFileFormat( <span class="keywordtype">int</span> imgID )
00454 {
00455     <span class="keywordflow">if</span> (imgID &lt; 0) <span class="keywordflow">return</span> pfUnknown;
00456     <span class="keywordflow">return</span> m_Pic[imgID].m_FileFormat;
00457 }
00458 
00459 ColorFormat PictureManager::GetColorFormat( <span class="keywordtype">int</span> imgID )
00460 {
00461     <span class="keywordflow">if</span> (imgID &lt; 0) <span class="keywordflow">return</span> cfUnknown;
00462     <span class="keywordflow">return</span> m_Pic[imgID].m_ColorFormat;
00463 }
00464 
00465 <span class="keywordtype">bool</span> PictureManager::IsLoaded( <span class="keywordtype">int</span> imgID )
00466 {
00467     <span class="keywordflow">if</span> (imgID &lt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00468     <span class="keywordflow">return</span> m_Pic[imgID].IsLoaded(); 
00469 }
00470 
00471 <span class="keywordtype">void</span> PictureManager::SetFiltering( <span class="keywordtype">bool</span> bFilter )
00472 {
00473     m_bFiltering = bFilter;
00474 }
00475 
00476 <span class="keywordtype">void</span> PictureManager::OnDestroyRS()
00477 {
00478     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_Pic.size(); i++) m_Pic[i].Unload();
00479 }
00480 
00481 <span class="keywordtype">void</span> PictureManager::OnCreateRS()
00482 {
00483 }
00484 
00485 
00486 
</pre></div><hr><address style="align: right;"><small>
Generated on Tue Jun 13 11:14:33 2006 for gRenderDX9 by <a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 width=110 height=53>
</a> 1.3.1 using KingsTools</small></address>
</body>
</html>
