<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gRenderDX9: d3dVertexBuffer.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.1 -->
<h1>d3dVertexBuffer.cpp</h1><div class="fragment"><pre>00001 <span class="comment">/*****************************************************************************/</span>
00002 <span class="comment">/*  File:   d3dVertexBuffer.h</span>
00003 <span class="comment">/*  Desc:   VertexBuffer interface implementation for DirectX9 </span>
00004 <span class="comment">/*  Author: Ruslan Shestopalyuk</span>
00005 <span class="comment">/*  Date:   02.11.2004</span>
00006 <span class="comment">/*****************************************************************************/</span>
00007 <span class="preprocessor">#include "gRenderPch.h"</span>
00008 <span class="preprocessor">#include "d3dVertexBuffer.h"</span>
00009 <span class="preprocessor">#include "d3dAdapt.h"</span>
00010 <span class="preprocessor">#include "kSSEUtils.h"</span>
00011 
00012 <span class="comment">/*****************************************************************************/</span>
00013 <span class="comment">/*  VertexBufferDX9 implementation</span>
00014 <span class="comment">/*****************************************************************************/</span>
00015 VertexBufferDX9::VertexBufferDX9( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, IDirect3DDevice9* pDevice )
00016 {
00017     m_Name              = name;
00018     m_bDynamic          = <span class="keyword">false</span>;       
00019     m_pBuffer           = NULL;        
00020     m_SizeBytes         = 0;           
00021     m_NVert             = 0;           
00022     m_bLocked           = <span class="keyword">false</span>;       
00023     m_NFilledVert       = 0;           
00024     m_FVF               = 0;           
00025     m_VStride           = 0;      
00026     m_VType             = -1;
00027     m_FirstValidStamp   = 1;
00028     m_CurrentStamp      = 1;
00029     m_bManaged          = <span class="keyword">true</span>;
00030 } <span class="comment">// VertexBufferDX9::VertexBufferDX9</span>
00031 <span class="keywordtype">int</span> SetStreamSourceTime=0;
00032 IDirect3DDevice9* GetDirect3DDevice();
00033 <span class="keywordtype">bool</span> VertexBufferDX9::Bind( <span class="keywordtype">int</span> stream, <span class="keywordtype">int</span> frequency )
00034 {
00035     IDirect3DDevice9* pDevice = GetDirect3DDevice();
00036     <span class="keywordflow">if</span> (!pDevice) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00037 
00038     __beginT();
00039 
00040     DX_CHK( pDevice-&gt;SetStreamSource( stream, m_pBuffer, 0, m_VStride ) );
00041     <span class="keywordflow">if</span> (frequency &gt; 1)
00042     {
00043         DX_CHK( pDevice-&gt;SetStreamSourceFreq( stream, frequency | D3DSTREAMSOURCE_INDEXEDDATA ) );
00044     }
00045 
00046     __endT(SetStreamSourceTime);
00047 
00048     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00049 } <span class="comment">// VertexBufferDX9::Bind</span>
00050 
00051 <span class="keywordtype">bool</span> VertexBufferDX9::Create( <span class="keywordtype">int</span> nBytes, <span class="keywordtype">bool</span> bDynamic, <span class="keyword">const</span> VertexDeclaration* pVDecl )
00052 {
00053     IDirect3DDevice9* pDevice = GetDirect3DDevice();
00054     <span class="keywordflow">if</span> (!pDevice) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00055 
00056     DeleteDeviceObjects();
00057     <span class="keywordflow">if</span> (pVDecl)
00058     {
00059         SetVertexDecl( *pVDecl );   
00060         m_NVert = nBytes / m_VStride;
00061         m_VDecl = *pVDecl;
00062     }
00063     <span class="keywordflow">else</span>
00064     {
00065         m_NVert     = 0;
00066         m_VStride   = 0;
00067         m_FVF       = 0;
00068     }
00069     
00070     DWORD usage = D3DUSAGE_WRITEONLY;
00071     <span class="keywordflow">if</span> (bDynamic) 
00072     {
00073         usage |= D3DUSAGE_DYNAMIC;
00074         m_bManaged = <span class="keyword">false</span>;
00075     }
00076 
00077     D3DPOOL pool = D3DPOOL_DEFAULT;
00078     <span class="keywordflow">if</span> (m_bManaged) pool = D3DPOOL_MANAGED;
00079 
00080     HRESULT hr = pDevice-&gt;CreateVertexBuffer( nBytes, usage, m_FVF, pool, &amp;m_pBuffer, NULL );
00081     DX_CHK( hr );
00082     m_bDynamic      = bDynamic;    
00083     m_SizeBytes     = nBytes;   
00084     m_bLocked       = <span class="keyword">false</span>;     
00085     m_NFilledVert   = 0;
00086 
00087     <span class="keywordflow">return</span> (hr == S_OK);
00088 } <span class="comment">// VertexBufferDX9::Create</span>
00089 <span class="keywordtype">int</span> VLockTime=0;
00090 BYTE* VertexBufferDX9::Lock( <span class="keywordtype">int</span> firstV, <span class="keywordtype">int</span> numV, DWORD&amp; stamp, <span class="keywordtype">bool</span> bDiscard )
00091 {
00092     <span class="keywordflow">if</span> (!m_pBuffer || firstV + numV &gt; m_NVert || numV == 0) <span class="keywordflow">return</span> NULL;
00093     <span class="keywordtype">void</span>* ptr;
00094     DWORD flags = D3DLOCK_NOSYSLOCK;
00095     <span class="keywordflow">if</span> (m_bDynamic) 
00096     {
00097         <span class="keywordflow">if</span> (bDiscard) flags |= D3DLOCK_DISCARD; <span class="keywordflow">else</span> flags |= D3DLOCK_NOOVERWRITE;
00098     }
00099     <span class="keywordflow">if</span> (bDiscard) 
00100     {
00101         m_FirstValidStamp = m_CurrentStamp;
00102         m_NFilledVert = 0;
00103     }
00104 
00105     __beginT();
00106 
00107     DX_CHK( m_pBuffer-&gt;Lock( firstV*m_VStride, numV*m_VStride, &amp;ptr, flags ) );
00108 
00109     __endT(VLockTime);
00110 
00111     <span class="comment">//  assume client filled all the buffer area he has locked</span>
00112     m_NFilledVert = firstV + numV;
00113     stamp = m_CurrentStamp++;
00114     m_bLocked = <span class="keyword">true</span>;
00115     <span class="keywordflow">return</span> (BYTE*)ptr;
00116 } <span class="comment">// VertexBufferDX9::Lock</span>
00117 
00118 <span class="keywordtype">void</span> VertexBufferDX9::Purge()
00119 {
00120     m_FirstValidStamp = ++m_CurrentStamp;
00121     m_NFilledVert = 0;
00122 } <span class="comment">// VertexBufferDX9::Purge</span>
00123 
00124 <span class="keywordtype">void</span> VertexBufferDX9::Unlock()
00125 {
00126     m_bLocked = <span class="keyword">false</span>;
00127 
00128     __beginT();
00129     DX_CHK( m_pBuffer-&gt;Unlock() );
00130     __endT(VLockTime);
00131 
00132 } <span class="comment">// VertexBufferDX9::Unlock</span>
00133 
00134 <span class="keywordtype">bool</span> VertexBufferDX9::HasAppendSpace( <span class="keywordtype">int</span> numV ) 
00135 {
00136     <span class="keywordflow">if</span> (numV &gt; m_NVert || numV == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00137     <span class="keywordflow">if</span> (m_NFilledVert + numV &gt; m_NVert) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00138     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00139 }
00140 
00141 BYTE* VertexBufferDX9::LockAppend( <span class="keywordtype">int</span> numV, <span class="keywordtype">int</span>&amp; offset, DWORD&amp; stamp )
00142 {
00143     <span class="keywordflow">if</span> (numV &gt; m_NVert || numV == 0) <span class="keywordflow">return</span> NULL;
00144     BYTE* pBuf = NULL;
00145     <span class="keywordtype">bool</span> bDiscard = <span class="keyword">false</span>;
00146     <span class="keywordflow">if</span> (m_NFilledVert + numV &gt; m_NVert) 
00147     {
00148         bDiscard = <span class="keyword">true</span>;
00149         m_NFilledVert = 0;
00150     }
00151     offset = m_NFilledVert;
00152     pBuf = Lock( m_NFilledVert, numV, stamp, bDiscard );
00153     <span class="keywordflow">return</span> pBuf;
00154 } <span class="comment">// VertexBufferDX9::LockAppend</span>
00155 
00156 <span class="keywordtype">void</span> VertexBufferDX9::SetVertexSize( <span class="keywordtype">int</span> size ) 
00157 { 
00158     <span class="keywordflow">if</span> (m_VStride != size)
00159     {
00160         <span class="keywordtype">int</span> nBytes = m_VStride*m_NFilledVert;
00161         <span class="keywordtype">int</span> rem = nBytes%size;
00162         <span class="keywordflow">if</span> (rem &gt; 0) nBytes += size - rem;
00163         m_NFilledVert   = nBytes/size;
00164         m_NVert         = m_SizeBytes/size;
00165         m_VStride       = size; 
00166     }
00167 } <span class="comment">// VertexBufferDX9::SetVertexSize</span>
00168 
00169 <span class="keywordtype">void</span> VertexBufferDX9::DeleteDeviceObjects()
00170 {
00171     SAFE_RELEASE( m_pBuffer );
00172 } <span class="comment">// VertexBufferDX9::DeleteDeviceObjects</span>
00173 
00174 <span class="keywordtype">void</span> VertexBufferDX9::InvalidateDeviceObjects()
00175 {
00176     <span class="keywordtype">int</span> nRef = GetRefCount( m_pBuffer );
00177     <span class="keywordflow">if</span> (!m_bManaged) SAFE_RELEASE( m_pBuffer );
00178 } <span class="comment">// VertexBufferDX9::InvalidateDeviceObjects</span>
00179 
00180 <span class="keywordtype">void</span> VertexBufferDX9::RestoreDeviceObjects()
00181 {
00182     <span class="keywordflow">if</span> (!m_pBuffer) Create( m_SizeBytes, m_bDynamic, 
00183                                (m_VDecl.m_NElements == 0) ? NULL : &amp;m_VDecl );
00184 } <span class="comment">// VertexBufferDX9::RestoreDeviceObjects</span>
00185 
00186 <span class="keywordtype">void</span> VertexBufferDX9::SetVertexDecl( <span class="keyword">const</span> VertexDeclaration&amp; vdecl )
00187 {
00188     m_VDecl     = vdecl;
00189     m_VStride   = m_VDecl.m_VertexSize;
00190     m_FVF       = CreateFVF( m_VDecl );
00191 } <span class="comment">// VertexBufferDX9::SetVDecl</span>
00192 
</pre></div><hr><address style="align: right;"><small>
Generated on Tue Jun 13 11:14:34 2006 for gRenderDX9 by <a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 width=110 height=53>
</a> 1.3.1 using KingsTools</small></address>
</body>
</html>
