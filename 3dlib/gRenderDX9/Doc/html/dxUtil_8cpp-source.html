<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gRenderDX9: dxUtil.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.1 -->
<h1>dxUtil.cpp</h1><div class="fragment"><pre>00001 <span class="comment">//-----------------------------------------------------------------------------</span>
00002 <span class="comment">// File: DXUtil.cpp</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// Desc: Shortcut macros and functions for using DX objects</span>
00005 <span class="comment">//</span>
00006 <span class="comment">// Copyright (c) Microsoft Corporation. All rights reserved</span>
00007 <span class="comment">//-----------------------------------------------------------------------------</span>
00008 <span class="preprocessor">#include "gRenderPch.h"</span>
00009 
00010 <span class="preprocessor">#ifdef UNICODE</span>
00011 <span class="preprocessor"></span>    <span class="keyword">typedef</span> HINSTANCE (WINAPI* LPShellExecute)(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
00012 <span class="preprocessor">#else</span>
00013 <span class="preprocessor"></span>    <span class="keyword">typedef</span> HINSTANCE (WINAPI* LPShellExecute)(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
00014 <span class="preprocessor">#endif</span>
00015 <span class="preprocessor"></span>
00016 
00017 <span class="preprocessor">#ifndef UNDER_CE</span>
00018 <span class="preprocessor"></span><span class="comment">//-----------------------------------------------------------------------------</span>
00019 <span class="comment">// Name: DXUtil_GetDXSDKMediaPathCch()</span>
00020 <span class="comment">// Desc: Returns the DirectX SDK media path</span>
00021 <span class="comment">//       cchDest is the size in TCHARs of strDest.  Be careful not to </span>
00022 <span class="comment">//       pass in sizeof(strDest) on UNICODE builds.</span>
00023 <span class="comment">//-----------------------------------------------------------------------------</span>
00024 HRESULT DXUtil_GetDXSDKMediaPathCch( TCHAR* strDest, <span class="keywordtype">int</span> cchDest )
00025 {
00026     <span class="keywordflow">if</span>( strDest == NULL || cchDest &lt; 1 )
00027         <span class="keywordflow">return</span> E_INVALIDARG;
00028 
00029     lstrcpy( strDest, TEXT(<span class="stringliteral">""</span>) );
00030 
00031     <span class="comment">// Open the appropriate registry key</span>
00032     HKEY  hKey;
00033     LONG lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
00034                                 _T(<span class="stringliteral">"Software\\Microsoft\\DirectX SDK"</span>),
00035                                 0, KEY_READ, &amp;hKey );
00036     <span class="keywordflow">if</span>( ERROR_SUCCESS != lResult )
00037         <span class="keywordflow">return</span> E_FAIL;
00038 
00039     DWORD dwType;
00040     DWORD dwSize = cchDest * <span class="keyword">sizeof</span>(TCHAR);
00041     lResult = RegQueryValueEx( hKey, _T(<span class="stringliteral">"DX9J3SDK Samples Path"</span>), NULL,
00042                               &amp;dwType, (BYTE*)strDest, &amp;dwSize );
00043     strDest[cchDest-1] = 0; <span class="comment">// RegQueryValueEx doesn't NULL term if buffer too small</span>
00044     RegCloseKey( hKey );
00045 
00046     <span class="keywordflow">if</span>( ERROR_SUCCESS != lResult )
00047         <span class="keywordflow">return</span> E_FAIL;
00048 
00049     <span class="keyword">const</span> TCHAR* strMedia = _T(<span class="stringliteral">"\\Media\\"</span>);
00050     <span class="keywordflow">if</span>( lstrlen(strDest) + lstrlen(strMedia) &lt; cchDest )
00051         _tcscat( strDest, strMedia );
00052     <span class="keywordflow">else</span>
00053         <span class="keywordflow">return</span> E_INVALIDARG;
00054 
00055     <span class="keywordflow">return</span> S_OK;
00056 }
00057 <span class="preprocessor">#endif // !UNDER_CE</span>
00058 <span class="preprocessor"></span>
00059 
00060 
00061 <span class="preprocessor">#ifndef UNDER_CE</span>
00062 <span class="preprocessor"></span><span class="comment">//-----------------------------------------------------------------------------</span>
00063 <span class="comment">// Name: DXUtil_FindMediaFileCch()</span>
00064 <span class="comment">// Desc: Trys to find the location of a SDK media file</span>
00065 <span class="comment">//       cchDest is the size in TCHARs of strDestPath.  Be careful not to </span>
00066 <span class="comment">//       pass in sizeof(strDest) on UNICODE builds.</span>
00067 <span class="comment">//-----------------------------------------------------------------------------</span>
00068 HRESULT DXUtil_FindMediaFileCch( TCHAR* strDestPath, <span class="keywordtype">int</span> cchDest, LPCTSTR strFilename )
00069 {
00070     HRESULT hr;
00071     TCHAR* strLeafNameTmp = NULL;
00072     TCHAR strLeafName[MAX_PATH];
00073     TCHAR strExePath[MAX_PATH];
00074     TCHAR strExeName[MAX_PATH];
00075     TCHAR strMediaDir[MAX_PATH];
00076     TCHAR strSearchPath[MAX_PATH];
00077     TCHAR* strLastSlash = NULL;
00078     <span class="keywordtype">int</span> cchPath;
00079     BOOL bFound = FALSE;
00080 
00081     <span class="keywordflow">if</span>( NULL==strFilename || NULL==strDestPath || cchDest &lt; 10 )
00082         <span class="keywordflow">return</span> E_INVALIDARG;
00083 
00084     lstrcpy( strDestPath, TEXT(<span class="stringliteral">""</span>) );
00085     lstrcpy( strLeafName, TEXT(<span class="stringliteral">""</span>) );
00086 
00087     <span class="comment">// Append current working directory to strFilename and extract the leaf filename </span>
00088     cchPath = GetFullPathName(strFilename, MAX_PATH, strSearchPath, &amp;strLeafNameTmp);
00089     <span class="keywordflow">if</span> ((cchPath == 0) || (MAX_PATH &lt;= cchPath))
00090         <span class="keywordflow">return</span> E_FAIL;
00091     <span class="keywordflow">if</span>( strLeafNameTmp )
00092         lstrcpyn( strLeafName, strLeafNameTmp, MAX_PATH );
00093 
00094     <span class="comment">// Search in .\ </span>
00095     <span class="keywordflow">if</span>( GetFileAttributes( strSearchPath ) != 0xFFFFFFFF )
00096         bFound = <span class="keyword">true</span>;
00097 
00098     <span class="keywordflow">if</span>( !bFound )
00099     {
00100         <span class="comment">// Search in ..\ </span>
00101         _sntprintf( strSearchPath, MAX_PATH, TEXT(<span class="stringliteral">"..\\%s"</span>), strLeafName );
00102         strSearchPath[MAX_PATH-1] = 0;
00103         <span class="keywordflow">if</span>( GetFileAttributes( strSearchPath ) != 0xFFFFFFFF )
00104             bFound = <span class="keyword">true</span>;
00105     }
00106 
00107     <span class="keywordflow">if</span>( !bFound )
00108     {
00109         <span class="comment">// Search in ..\..\  </span>
00110         _sntprintf( strSearchPath, MAX_PATH, TEXT(<span class="stringliteral">"..\\..\\%s"</span>), strLeafName );
00111         strSearchPath[MAX_PATH-1] = 0;
00112         <span class="keywordflow">if</span>( GetFileAttributes( strSearchPath ) != 0xFFFFFFFF )
00113             bFound = <span class="keyword">true</span>;
00114     }
00115     
00116     <span class="keywordflow">if</span>( !bFound )
00117     {
00118         <span class="comment">// Get the exe name, and exe path</span>
00119         GetModuleFileName( NULL, strExePath, MAX_PATH );
00120         strExePath[MAX_PATH-1]=0;
00121         strLastSlash = _tcsrchr( strExePath, TEXT(<span class="charliteral">'\\'</span>) );
00122         <span class="keywordflow">if</span>( strLastSlash )
00123         {
00124             lstrcpyn( strExeName, &amp;strLastSlash[1], MAX_PATH );
00125 
00126             <span class="comment">// Chop the exe name from the exe path</span>
00127             *strLastSlash = 0;
00128 
00129             <span class="comment">// Chop the .exe from the exe name</span>
00130             strLastSlash = _tcsrchr( strExeName, TEXT(<span class="charliteral">'.'</span>) );
00131             <span class="keywordflow">if</span>( strLastSlash )
00132                 *strLastSlash = 0;
00133         }
00134 
00135         <span class="comment">// Search in the executable directory</span>
00136         _sntprintf( strSearchPath, MAX_PATH, _T(<span class="stringliteral">"%s\\%s"</span>), strExePath, strLeafName );
00137         strSearchPath[MAX_PATH-1] = 0;
00138         <span class="keywordflow">if</span>( GetFileAttributes( strSearchPath ) != 0xFFFFFFFF )
00139             bFound = TRUE;
00140 
00141         <span class="keywordflow">if</span>( !bFound )
00142         {
00143             <span class="comment">// Search in "%EXE_DIR%\.."</span>
00144             _sntprintf( strSearchPath, MAX_PATH, _T(<span class="stringliteral">"%s\\..\\%s"</span>), strExePath, strLeafName );
00145             strSearchPath[MAX_PATH-1] = 0;
00146             <span class="keywordflow">if</span>( GetFileAttributes( strSearchPath ) != 0xFFFFFFFF )
00147                 bFound = TRUE;
00148         }
00149 
00150         <span class="keywordflow">if</span>( !bFound )
00151         {
00152             <span class="comment">// Search in "%EXE_DIR%\..\.."</span>
00153             _sntprintf( strSearchPath, MAX_PATH, _T(<span class="stringliteral">"%s\\..\\..\\%s"</span>), strExePath, strLeafName );
00154             strSearchPath[MAX_PATH-1] = 0;
00155             <span class="keywordflow">if</span>( GetFileAttributes( strSearchPath ) != 0xFFFFFFFF )
00156                 bFound = TRUE;
00157         }
00158 
00159         <span class="keywordflow">if</span>( !bFound )
00160         {
00161             <span class="comment">// Search in "%EXE_DIR%\..\%EXE_NAME%\".  This matches the DirectX SDK layout</span>
00162             _sntprintf( strSearchPath, MAX_PATH, TEXT(<span class="stringliteral">"%s\\..\\%s\\%s"</span>), strExePath, strExeName, strLeafName );
00163             strSearchPath[MAX_PATH-1] = 0;
00164             <span class="keywordflow">if</span>( GetFileAttributes( strSearchPath ) != 0xFFFFFFFF )
00165                 bFound = TRUE;
00166         }
00167     }
00168     
00169     <span class="keywordflow">if</span>( !bFound )
00170     {
00171         <span class="comment">// Get the media dir </span>
00172         <span class="keywordflow">if</span>( FAILED( hr = DXUtil_GetDXSDKMediaPathCch( strMediaDir, MAX_PATH ) ) )
00173             <span class="keywordflow">return</span> hr;
00174 
00175         <span class="comment">// Search in SDK's media dir </span>
00176         _sntprintf( strSearchPath, MAX_PATH, TEXT(<span class="stringliteral">"%s%s"</span>), strMediaDir, strLeafName );
00177         strSearchPath[MAX_PATH-1] = 0;
00178         <span class="keywordflow">if</span>( GetFileAttributes( strSearchPath ) != 0xFFFFFFFF )
00179             bFound = TRUE;
00180     }
00181 
00182     <span class="keywordflow">if</span>( bFound )
00183     {
00184         <span class="comment">// Found the file, so copy the search path to the output buffer</span>
00185         <span class="comment">// and return success</span>
00186         lstrcpyn( strDestPath, strSearchPath, cchDest );
00187         <span class="keywordflow">return</span> S_OK;
00188     }
00189     <span class="keywordflow">else</span>
00190     {
00191         <span class="comment">// On failure, return the file as the path but return an error code</span>
00192         lstrcpyn( strDestPath, strFilename, cchDest );
00193         <span class="keywordflow">return</span> HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
00194     }
00195 }
00196 <span class="preprocessor">#endif // !UNDER_CE</span>
00197 <span class="preprocessor"></span>
00198 
00199 
00200 
00201 <span class="comment">//-----------------------------------------------------------------------------</span>
00202 <span class="comment">// Name: DXUtil_ReadStringRegKeyCch()</span>
00203 <span class="comment">// Desc: Helper function to read a registry key string</span>
00204 <span class="comment">//       cchDest is the size in TCHARs of strDest.  Be careful not to </span>
00205 <span class="comment">//       pass in sizeof(strDest) on UNICODE builds.</span>
00206 <span class="comment">//-----------------------------------------------------------------------------</span>
00207 HRESULT DXUtil_ReadStringRegKeyCch( HKEY hKey, LPCTSTR strRegName, TCHAR* strDest, 
00208                                     DWORD cchDest, LPCTSTR strDefault )
00209 {
00210     DWORD dwType;
00211     DWORD cbDest = cchDest * <span class="keyword">sizeof</span>(TCHAR);
00212 
00213     <span class="keywordflow">if</span>( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &amp;dwType, 
00214                                           (BYTE*)strDest, &amp;cbDest ) )
00215     {
00216         _tcsncpy( strDest, strDefault, cchDest );
00217         strDest[cchDest-1] = 0;
00218         <span class="keywordflow">return</span> S_FALSE;
00219     }
00220     <span class="keywordflow">else</span>
00221     {     
00222         <span class="keywordflow">if</span>( dwType != REG_SZ )
00223         {
00224             _tcsncpy( strDest, strDefault, cchDest );
00225             strDest[cchDest-1] = 0;
00226             <span class="keywordflow">return</span> S_FALSE;
00227         }   
00228     }
00229 
00230     <span class="keywordflow">return</span> S_OK;
00231 }
00232 
00233 
00234 
00235 
00236 <span class="comment">//-----------------------------------------------------------------------------</span>
00237 <span class="comment">// Name: DXUtil_WriteStringRegKey()</span>
00238 <span class="comment">// Desc: Helper function to write a registry key string</span>
00239 <span class="comment">//-----------------------------------------------------------------------------</span>
00240 HRESULT DXUtil_WriteStringRegKey( HKEY hKey, LPCTSTR strRegName,
00241                                   LPCTSTR strValue )
00242 {
00243     <span class="keywordflow">if</span>( NULL == strValue )
00244         <span class="keywordflow">return</span> E_INVALIDARG;
00245         
00246     DWORD cbValue = ((DWORD)_tcslen(strValue)+1) * <span class="keyword">sizeof</span>(TCHAR);
00247 
00248     <span class="keywordflow">if</span>( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_SZ, 
00249                                         (BYTE*)strValue, cbValue ) )
00250         <span class="keywordflow">return</span> E_FAIL;
00251 
00252     <span class="keywordflow">return</span> S_OK;
00253 }
00254 
00255 
00256 
00257 
00258 <span class="comment">//-----------------------------------------------------------------------------</span>
00259 <span class="comment">// Name: DXUtil_ReadFloatRegKey()</span>
00260 <span class="comment">// Desc: Helper function to read a registry key string</span>
00261 <span class="comment">//-----------------------------------------------------------------------------</span>
00262 HRESULT DXUtil_ReadFloatRegKey( HKEY hKey, LPCTSTR strRegName, FLOAT* pfDest, FLOAT fDefault )
00263 {
00264     <span class="keywordflow">if</span>( NULL == pfDest )
00265         <span class="keywordflow">return</span> E_INVALIDARG;
00266 
00267     TCHAR sz[256];
00268     <span class="keywordtype">float</span> fResult;
00269 
00270     TCHAR strDefault[256];
00271     _sntprintf( strDefault, 256, TEXT(<span class="stringliteral">"%f"</span>), fDefault );
00272     strDefault[255] = 0;
00273    
00274     <span class="keywordflow">if</span>( SUCCEEDED( DXUtil_ReadStringRegKeyCch( hKey, strRegName, sz, 256, strDefault ) ) )
00275     {
00276         <span class="keywordtype">int</span> nResult = _stscanf( sz, TEXT(<span class="stringliteral">"%f"</span>), &amp;fResult );
00277         <span class="keywordflow">if</span>( nResult == 1 )
00278         {
00279             *pfDest = fResult;
00280             <span class="keywordflow">return</span> S_OK;           
00281         }
00282     }
00283 
00284     *pfDest = fDefault;
00285     <span class="keywordflow">return</span> S_FALSE;
00286 }
00287 
00288 
00289 
00290 
00291 <span class="comment">//-----------------------------------------------------------------------------</span>
00292 <span class="comment">// Name: DXUtil_WriteFloatRegKey()</span>
00293 <span class="comment">// Desc: Helper function to write a registry key string</span>
00294 <span class="comment">//-----------------------------------------------------------------------------</span>
00295 HRESULT DXUtil_WriteFloatRegKey( HKEY hKey, LPCTSTR strRegName, FLOAT fValue )
00296 {
00297     TCHAR strValue[256];
00298     _sntprintf( strValue, 256, TEXT(<span class="stringliteral">"%f"</span>), fValue );
00299     strValue[255] = 0;
00300 
00301     <span class="keywordflow">return</span> DXUtil_WriteStringRegKey( hKey, strRegName, strValue );
00302 }
00303 
00304 
00305 
00306 
00307 <span class="comment">//-----------------------------------------------------------------------------</span>
00308 <span class="comment">// Name: DXUtil_ReadIntRegKey()</span>
00309 <span class="comment">// Desc: Helper function to read a registry key int</span>
00310 <span class="comment">//-----------------------------------------------------------------------------</span>
00311 HRESULT DXUtil_ReadIntRegKey( HKEY hKey, LPCTSTR strRegName, DWORD* pdwDest, 
00312                               DWORD dwDefault )
00313 {
00314     DWORD dwType;
00315     DWORD dwLength = <span class="keyword">sizeof</span>(DWORD);
00316 
00317     <span class="keywordflow">if</span>( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &amp;dwType, 
00318                                           (BYTE*)pdwDest, &amp;dwLength ) )
00319     {
00320         *pdwDest = dwDefault;
00321         <span class="keywordflow">return</span> S_FALSE;
00322     }
00323     <span class="keywordflow">else</span>
00324     {
00325         <span class="keywordflow">if</span>( dwType != REG_DWORD )
00326         {
00327             *pdwDest = dwDefault;
00328             <span class="keywordflow">return</span> S_FALSE;
00329         }
00330     }
00331 
00332     <span class="keywordflow">return</span> S_OK;
00333 }
00334 
00335 
00336 
00337 
00338 <span class="comment">//-----------------------------------------------------------------------------</span>
00339 <span class="comment">// Name: DXUtil_WriteIntRegKey()</span>
00340 <span class="comment">// Desc: Helper function to write a registry key int</span>
00341 <span class="comment">//-----------------------------------------------------------------------------</span>
00342 HRESULT DXUtil_WriteIntRegKey( HKEY hKey, LPCTSTR strRegName, DWORD dwValue )
00343 {
00344     <span class="keywordflow">if</span>( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_DWORD, 
00345                                         (BYTE*)&amp;dwValue, <span class="keyword">sizeof</span>(DWORD) ) )
00346         <span class="keywordflow">return</span> E_FAIL;
00347 
00348     <span class="keywordflow">return</span> S_OK;
00349 }
00350 
00351 
00352 
00353 
00354 <span class="comment">//-----------------------------------------------------------------------------</span>
00355 <span class="comment">// Name: DXUtil_ReadBoolRegKey()</span>
00356 <span class="comment">// Desc: Helper function to read a registry key BOOL</span>
00357 <span class="comment">//-----------------------------------------------------------------------------</span>
00358 HRESULT DXUtil_ReadBoolRegKey( HKEY hKey, LPCTSTR strRegName, BOOL* pbDest, 
00359                               BOOL bDefault )
00360 {
00361     DWORD dwType;
00362     DWORD dwLength = <span class="keyword">sizeof</span>(BOOL);
00363 
00364     <span class="keywordflow">if</span>( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &amp;dwType, 
00365                                           (BYTE*)pbDest, &amp;dwLength ) )
00366     {
00367         *pbDest = bDefault;
00368         <span class="keywordflow">return</span> S_FALSE;
00369     }
00370     <span class="keywordflow">else</span>
00371     {
00372         <span class="keywordflow">if</span>( dwType != REG_DWORD )
00373         {
00374             *pbDest = bDefault;
00375             <span class="keywordflow">return</span> S_FALSE;
00376         }
00377     }
00378 
00379     <span class="keywordflow">return</span> S_OK;
00380 }
00381 
00382 
00383 
00384 
00385 <span class="comment">//-----------------------------------------------------------------------------</span>
00386 <span class="comment">// Name: DXUtil_WriteBoolRegKey()</span>
00387 <span class="comment">// Desc: Helper function to write a registry key BOOL</span>
00388 <span class="comment">//-----------------------------------------------------------------------------</span>
00389 HRESULT DXUtil_WriteBoolRegKey( HKEY hKey, LPCTSTR strRegName, BOOL bValue )
00390 {
00391     <span class="keywordflow">if</span>( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_DWORD, 
00392                                         (BYTE*)&amp;bValue, <span class="keyword">sizeof</span>(BOOL) ) )
00393         <span class="keywordflow">return</span> E_FAIL;
00394 
00395     <span class="keywordflow">return</span> S_OK;
00396 }
00397 
00398 
00399 
00400 
00401 <span class="comment">//-----------------------------------------------------------------------------</span>
00402 <span class="comment">// Name: DXUtil_ReadGuidRegKey()</span>
00403 <span class="comment">// Desc: Helper function to read a registry key guid</span>
00404 <span class="comment">//-----------------------------------------------------------------------------</span>
00405 HRESULT DXUtil_ReadGuidRegKey( HKEY hKey, LPCTSTR strRegName, GUID* pGuidDest, 
00406                                GUID&amp; guidDefault )
00407 {
00408     DWORD dwType;
00409     DWORD dwLength = <span class="keyword">sizeof</span>(GUID);
00410 
00411     <span class="keywordflow">if</span>( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &amp;dwType, 
00412                                           (LPBYTE) pGuidDest, &amp;dwLength ) )
00413     {
00414         *pGuidDest = guidDefault;
00415         <span class="keywordflow">return</span> S_FALSE;
00416     }
00417     <span class="keywordflow">else</span>
00418     {
00419         <span class="keywordflow">if</span>( dwType != REG_BINARY )
00420         {
00421             *pGuidDest = guidDefault;
00422             <span class="keywordflow">return</span> S_FALSE;
00423         }
00424     }
00425 
00426     <span class="keywordflow">return</span> S_OK;
00427 }
00428 
00429 
00430 
00431 
00432 <span class="comment">//-----------------------------------------------------------------------------</span>
00433 <span class="comment">// Name: DXUtil_WriteGuidRegKey()</span>
00434 <span class="comment">// Desc: Helper function to write a registry key guid</span>
00435 <span class="comment">//-----------------------------------------------------------------------------</span>
00436 HRESULT DXUtil_WriteGuidRegKey( HKEY hKey, LPCTSTR strRegName, GUID guidValue )
00437 {
00438     <span class="keywordflow">if</span>( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_BINARY, 
00439                                         (BYTE*)&amp;guidValue, <span class="keyword">sizeof</span>(GUID) ) )
00440         <span class="keywordflow">return</span> E_FAIL;
00441 
00442     <span class="keywordflow">return</span> S_OK;
00443 }
00444 
00445 
00446 
00447 
00448 <span class="comment">//-----------------------------------------------------------------------------</span>
00449 <span class="comment">// Name: DXUtil_Timer()</span>
00450 <span class="comment">// Desc: Performs timer opertations. Use the following commands:</span>
00451 <span class="comment">//          TIMER_RESET           - to reset the timer</span>
00452 <span class="comment">//          TIMER_START           - to start the timer</span>
00453 <span class="comment">//          TIMER_STOP            - to stop (or pause) the timer</span>
00454 <span class="comment">//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds</span>
00455 <span class="comment">//          TIMER_GETABSOLUTETIME - to get the absolute system time</span>
00456 <span class="comment">//          TIMER_GETAPPTIME      - to get the current time</span>
00457 <span class="comment">//          TIMER_GETELAPSEDTIME  - to get the time that elapsed between </span>
00458 <span class="comment">//                                  TIMER_GETELAPSEDTIME calls</span>
00459 <span class="comment">//-----------------------------------------------------------------------------</span>
00460 FLOAT __stdcall DXUtil_Timer( TIMER_COMMAND command )
00461 {
00462     <span class="keyword">static</span> BOOL     m_bTimerInitialized = FALSE;
00463     <span class="keyword">static</span> BOOL     m_bUsingQPF         = FALSE;
00464     <span class="keyword">static</span> BOOL     m_bTimerStopped     = TRUE;
00465     <span class="keyword">static</span> LONGLONG m_llQPFTicksPerSec  = 0;
00466 
00467     <span class="comment">// Initialize the timer</span>
00468     <span class="keywordflow">if</span>( FALSE == m_bTimerInitialized )
00469     {
00470         m_bTimerInitialized = TRUE;
00471 
00472         <span class="comment">// Use QueryPerformanceFrequency() to get frequency of timer.  If QPF is</span>
00473         <span class="comment">// not supported, we will timeGetTime() which returns milliseconds.</span>
00474         LARGE_INTEGER qwTicksPerSec;
00475         m_bUsingQPF = QueryPerformanceFrequency( &amp;qwTicksPerSec );
00476         <span class="keywordflow">if</span>( m_bUsingQPF )
00477             m_llQPFTicksPerSec = qwTicksPerSec.QuadPart;
00478     }
00479 
00480     <span class="keywordflow">if</span>( m_bUsingQPF )
00481     {
00482         <span class="keyword">static</span> LONGLONG m_llStopTime        = 0;
00483         <span class="keyword">static</span> LONGLONG m_llLastElapsedTime = 0;
00484         <span class="keyword">static</span> LONGLONG m_llBaseTime        = 0;
00485         <span class="keywordtype">double</span> fTime;
00486         <span class="keywordtype">double</span> fElapsedTime;
00487         LARGE_INTEGER qwTime;
00488         
00489         <span class="comment">// Get either the current time or the stop time, depending</span>
00490         <span class="comment">// on whether we're stopped and what command was sent</span>
00491         <span class="keywordflow">if</span>( m_llStopTime != 0 &amp;&amp; command != TIMER_START &amp;&amp; command != TIMER_GETABSOLUTETIME)
00492             qwTime.QuadPart = m_llStopTime;
00493         <span class="keywordflow">else</span>
00494             QueryPerformanceCounter( &amp;qwTime );
00495 
00496         <span class="comment">// Return the elapsed time</span>
00497         <span class="keywordflow">if</span>( command == TIMER_GETELAPSEDTIME )
00498         {
00499             fElapsedTime = (<span class="keywordtype">double</span>) ( qwTime.QuadPart - m_llLastElapsedTime ) / (<span class="keywordtype">double</span>) m_llQPFTicksPerSec;
00500             m_llLastElapsedTime = qwTime.QuadPart;
00501             <span class="keywordflow">return</span> (FLOAT) fElapsedTime;
00502         }
00503     
00504         <span class="comment">// Return the current time</span>
00505         <span class="keywordflow">if</span>( command == TIMER_GETAPPTIME )
00506         {
00507             <span class="keywordtype">double</span> fAppTime = (<span class="keywordtype">double</span>) ( qwTime.QuadPart - m_llBaseTime ) / (<span class="keywordtype">double</span>) m_llQPFTicksPerSec;
00508             <span class="keywordflow">return</span> (FLOAT) fAppTime;
00509         }
00510     
00511         <span class="comment">// Reset the timer</span>
00512         <span class="keywordflow">if</span>( command == TIMER_RESET )
00513         {
00514             m_llBaseTime        = qwTime.QuadPart;
00515             m_llLastElapsedTime = qwTime.QuadPart;
00516             m_llStopTime        = 0;
00517             m_bTimerStopped     = FALSE;
00518             <span class="keywordflow">return</span> 0.0f;
00519         }
00520     
00521         <span class="comment">// Start the timer</span>
00522         <span class="keywordflow">if</span>( command == TIMER_START )
00523         {
00524             <span class="keywordflow">if</span>( m_bTimerStopped )
00525                 m_llBaseTime += qwTime.QuadPart - m_llStopTime;
00526             m_llStopTime = 0;
00527             m_llLastElapsedTime = qwTime.QuadPart;
00528             m_bTimerStopped = FALSE;
00529             <span class="keywordflow">return</span> 0.0f;
00530         }
00531     
00532         <span class="comment">// Stop the timer</span>
00533         <span class="keywordflow">if</span>( command == TIMER_STOP )
00534         {
00535             <span class="keywordflow">if</span>( !m_bTimerStopped )
00536             {
00537                 m_llStopTime = qwTime.QuadPart;
00538                 m_llLastElapsedTime = qwTime.QuadPart;
00539                 m_bTimerStopped = TRUE;
00540             }
00541             <span class="keywordflow">return</span> 0.0f;
00542         }
00543     
00544         <span class="comment">// Advance the timer by 1/10th second</span>
00545         <span class="keywordflow">if</span>( command == TIMER_ADVANCE )
00546         {
00547             m_llStopTime += m_llQPFTicksPerSec/10;
00548             <span class="keywordflow">return</span> 0.0f;
00549         }
00550 
00551         <span class="keywordflow">if</span>( command == TIMER_GETABSOLUTETIME )
00552         {
00553             fTime = qwTime.QuadPart / (<span class="keywordtype">double</span>) m_llQPFTicksPerSec;
00554             <span class="keywordflow">return</span> (FLOAT) fTime;
00555         }
00556 
00557         <span class="keywordflow">return</span> -1.0f; <span class="comment">// Invalid command specified</span>
00558     }
00559     <span class="keywordflow">else</span>
00560     {
00561         <span class="comment">// Get the time using timeGetTime()</span>
00562         <span class="keyword">static</span> <span class="keywordtype">double</span> m_fLastElapsedTime  = 0.0;
00563         <span class="keyword">static</span> <span class="keywordtype">double</span> m_fBaseTime         = 0.0;
00564         <span class="keyword">static</span> <span class="keywordtype">double</span> m_fStopTime         = 0.0;
00565         <span class="keywordtype">double</span> fTime;
00566         <span class="keywordtype">double</span> fElapsedTime;
00567         
00568         <span class="comment">// Get either the current time or the stop time, depending</span>
00569         <span class="comment">// on whether we're stopped and what command was sent</span>
00570         <span class="keywordflow">if</span>( m_fStopTime != 0.0 &amp;&amp; command != TIMER_START &amp;&amp; command != TIMER_GETABSOLUTETIME)
00571             fTime = m_fStopTime;
00572         <span class="keywordflow">else</span>
00573             fTime = GETTIMESTAMP() * 0.001;
00574     
00575         <span class="comment">// Return the elapsed time</span>
00576         <span class="keywordflow">if</span>( command == TIMER_GETELAPSEDTIME )
00577         {   
00578             fElapsedTime = (<span class="keywordtype">double</span>) (fTime - m_fLastElapsedTime);
00579             m_fLastElapsedTime = fTime;
00580             <span class="keywordflow">return</span> (FLOAT) fElapsedTime;
00581         }
00582     
00583         <span class="comment">// Return the current time</span>
00584         <span class="keywordflow">if</span>( command == TIMER_GETAPPTIME )
00585         {
00586             <span class="keywordflow">return</span> (FLOAT) (fTime - m_fBaseTime);
00587         }
00588     
00589         <span class="comment">// Reset the timer</span>
00590         <span class="keywordflow">if</span>( command == TIMER_RESET )
00591         {
00592             m_fBaseTime         = fTime;
00593             m_fLastElapsedTime  = fTime;
00594             m_fStopTime         = 0;
00595             m_bTimerStopped     = FALSE;
00596             <span class="keywordflow">return</span> 0.0f;
00597         }
00598     
00599         <span class="comment">// Start the timer</span>
00600         <span class="keywordflow">if</span>( command == TIMER_START )
00601         {
00602             <span class="keywordflow">if</span>( m_bTimerStopped )
00603                 m_fBaseTime += fTime - m_fStopTime;
00604             m_fStopTime = 0.0f;
00605             m_fLastElapsedTime  = fTime;
00606             m_bTimerStopped = FALSE;
00607             <span class="keywordflow">return</span> 0.0f;
00608         }
00609     
00610         <span class="comment">// Stop the timer</span>
00611         <span class="keywordflow">if</span>( command == TIMER_STOP )
00612         {
00613             <span class="keywordflow">if</span>( !m_bTimerStopped )
00614             {
00615                 m_fStopTime = fTime;
00616                 m_fLastElapsedTime  = fTime;
00617                 m_bTimerStopped = TRUE;
00618             }
00619             <span class="keywordflow">return</span> 0.0f;
00620         }
00621     
00622         <span class="comment">// Advance the timer by 1/10th second</span>
00623         <span class="keywordflow">if</span>( command == TIMER_ADVANCE )
00624         {
00625             m_fStopTime += 0.1f;
00626             <span class="keywordflow">return</span> 0.0f;
00627         }
00628 
00629         <span class="keywordflow">if</span>( command == TIMER_GETABSOLUTETIME )
00630         {
00631             <span class="keywordflow">return</span> (FLOAT) fTime;
00632         }
00633 
00634         <span class="keywordflow">return</span> -1.0f; <span class="comment">// Invalid command specified</span>
00635     }
00636 }
00637 
00638 
00639 
00640 
00641 <span class="comment">//-----------------------------------------------------------------------------</span>
00642 <span class="comment">// Name: DXUtil_ConvertAnsiStringToWideCch()</span>
00643 <span class="comment">// Desc: This is a UNICODE conversion utility to convert a CHAR string into a</span>
00644 <span class="comment">//       WCHAR string. </span>
00645 <span class="comment">//       cchDestChar is the size in TCHARs of wstrDestination.  Be careful not to </span>
00646 <span class="comment">//       pass in sizeof(strDest) </span>
00647 <span class="comment">//-----------------------------------------------------------------------------</span>
00648 HRESULT DXUtil_ConvertAnsiStringToWideCch( WCHAR* wstrDestination, <span class="keyword">const</span> CHAR* strSource, 
00649                                      <span class="keywordtype">int</span> cchDestChar )
00650 {
00651     <span class="keywordflow">if</span>( wstrDestination==NULL || strSource==NULL || cchDestChar &lt; 1 )
00652         <span class="keywordflow">return</span> E_INVALIDARG;
00653 
00654     <span class="keywordtype">int</span> nResult = MultiByteToWideChar( CP_ACP, 0, strSource, -1, 
00655                                        wstrDestination, cchDestChar );
00656     wstrDestination[cchDestChar-1] = 0;
00657     
00658     <span class="keywordflow">if</span>( nResult == 0 )
00659         <span class="keywordflow">return</span> E_FAIL;
00660     <span class="keywordflow">return</span> S_OK;
00661 }
00662 
00663 
00664 
00665 
00666 <span class="comment">//-----------------------------------------------------------------------------</span>
00667 <span class="comment">// Name: DXUtil_ConvertWideStringToAnsi()</span>
00668 <span class="comment">// Desc: This is a UNICODE conversion utility to convert a WCHAR string into a</span>
00669 <span class="comment">//       CHAR string. </span>
00670 <span class="comment">//       cchDestChar is the size in TCHARs of strDestination</span>
00671 <span class="comment">//-----------------------------------------------------------------------------</span>
00672 HRESULT DXUtil_ConvertWideStringToAnsiCch( CHAR* strDestination, <span class="keyword">const</span> WCHAR* wstrSource, 
00673                                      <span class="keywordtype">int</span> cchDestChar )
00674 {
00675     <span class="keywordflow">if</span>( strDestination==NULL || wstrSource==NULL || cchDestChar &lt; 1 )
00676         <span class="keywordflow">return</span> E_INVALIDARG;
00677 
00678     <span class="keywordtype">int</span> nResult = WideCharToMultiByte( CP_ACP, 0, wstrSource, -1, strDestination, 
00679                                        cchDestChar*<span class="keyword">sizeof</span>(CHAR), NULL, NULL );
00680     strDestination[cchDestChar-1] = 0;
00681     
00682     <span class="keywordflow">if</span>( nResult == 0 )
00683         <span class="keywordflow">return</span> E_FAIL;
00684     <span class="keywordflow">return</span> S_OK;
00685 }
00686 
00687 
00688 
00689 
00690 <span class="comment">//-----------------------------------------------------------------------------</span>
00691 <span class="comment">// Name: DXUtil_ConvertGenericStringToAnsi()</span>
00692 <span class="comment">// Desc: This is a UNICODE conversion utility to convert a TCHAR string into a</span>
00693 <span class="comment">//       CHAR string. </span>
00694 <span class="comment">//       cchDestChar is the size in TCHARs of strDestination</span>
00695 <span class="comment">//-----------------------------------------------------------------------------</span>
00696 HRESULT DXUtil_ConvertGenericStringToAnsiCch( CHAR* strDestination, <span class="keyword">const</span> TCHAR* tstrSource, 
00697                                            <span class="keywordtype">int</span> cchDestChar )
00698 {
00699     <span class="keywordflow">if</span>( strDestination==NULL || tstrSource==NULL || cchDestChar &lt; 1 )
00700         <span class="keywordflow">return</span> E_INVALIDARG;
00701 
00702 <span class="preprocessor">#ifdef _UNICODE</span>
00703 <span class="preprocessor"></span>    <span class="keywordflow">return</span> DXUtil_ConvertWideStringToAnsiCch( strDestination, tstrSource, cchDestChar );
00704 <span class="preprocessor">#else</span>
00705 <span class="preprocessor"></span>    strncpy( strDestination, tstrSource, cchDestChar );
00706     strDestination[cchDestChar-1] = <span class="charliteral">'\0'</span>;
00707     <span class="keywordflow">return</span> S_OK;
00708 <span class="preprocessor">#endif   </span>
00709 <span class="preprocessor"></span>}
00710 
00711 
00712 
00713 
00714 <span class="comment">//-----------------------------------------------------------------------------</span>
00715 <span class="comment">// Name: DXUtil_ConvertGenericStringToWide()</span>
00716 <span class="comment">// Desc: This is a UNICODE conversion utility to convert a TCHAR string into a</span>
00717 <span class="comment">//       WCHAR string. </span>
00718 <span class="comment">//       cchDestChar is the size in TCHARs of wstrDestination.  Be careful not to </span>
00719 <span class="comment">//       pass in sizeof(strDest) </span>
00720 <span class="comment">//-----------------------------------------------------------------------------</span>
00721 HRESULT DXUtil_ConvertGenericStringToWideCch( WCHAR* wstrDestination, <span class="keyword">const</span> TCHAR* tstrSource, 
00722                                            <span class="keywordtype">int</span> cchDestChar )
00723 {
00724     <span class="keywordflow">if</span>( wstrDestination==NULL || tstrSource==NULL || cchDestChar &lt; 1 )
00725         <span class="keywordflow">return</span> E_INVALIDARG;
00726 
00727 <span class="preprocessor">#ifdef _UNICODE</span>
00728 <span class="preprocessor"></span>    wcsncpy( wstrDestination, tstrSource, cchDestChar );
00729     wstrDestination[cchDestChar-1] = L<span class="charliteral">'\0'</span>;
00730     <span class="keywordflow">return</span> S_OK;
00731 <span class="preprocessor">#else</span>
00732 <span class="preprocessor"></span>    <span class="keywordflow">return</span> DXUtil_ConvertAnsiStringToWideCch( wstrDestination, tstrSource, cchDestChar );
00733 <span class="preprocessor">#endif    </span>
00734 <span class="preprocessor"></span>}
00735 
00736 
00737 
00738 
00739 <span class="comment">//-----------------------------------------------------------------------------</span>
00740 <span class="comment">// Name: DXUtil_ConvertAnsiStringToGeneric()</span>
00741 <span class="comment">// Desc: This is a UNICODE conversion utility to convert a CHAR string into a</span>
00742 <span class="comment">//       TCHAR string. </span>
00743 <span class="comment">//       cchDestChar is the size in TCHARs of tstrDestination.  Be careful not to </span>
00744 <span class="comment">//       pass in sizeof(strDest) on UNICODE builds</span>
00745 <span class="comment">//-----------------------------------------------------------------------------</span>
00746 HRESULT DXUtil_ConvertAnsiStringToGenericCch( TCHAR* tstrDestination, <span class="keyword">const</span> CHAR* strSource, 
00747                                            <span class="keywordtype">int</span> cchDestChar )
00748 {
00749     <span class="keywordflow">if</span>( tstrDestination==NULL || strSource==NULL || cchDestChar &lt; 1 )
00750         <span class="keywordflow">return</span> E_INVALIDARG;
00751         
00752 <span class="preprocessor">#ifdef _UNICODE</span>
00753 <span class="preprocessor"></span>    <span class="keywordflow">return</span> DXUtil_ConvertAnsiStringToWideCch( tstrDestination, strSource, cchDestChar );
00754 <span class="preprocessor">#else</span>
00755 <span class="preprocessor"></span>    strncpy( tstrDestination, strSource, cchDestChar );
00756     tstrDestination[cchDestChar-1] = <span class="charliteral">'\0'</span>;
00757     <span class="keywordflow">return</span> S_OK;
00758 <span class="preprocessor">#endif    </span>
00759 <span class="preprocessor"></span>}
00760 
00761 
00762 
00763 
00764 <span class="comment">//-----------------------------------------------------------------------------</span>
00765 <span class="comment">// Name: DXUtil_ConvertAnsiStringToGeneric()</span>
00766 <span class="comment">// Desc: This is a UNICODE conversion utility to convert a WCHAR string into a</span>
00767 <span class="comment">//       TCHAR string. </span>
00768 <span class="comment">//       cchDestChar is the size in TCHARs of tstrDestination.  Be careful not to </span>
00769 <span class="comment">//       pass in sizeof(strDest) on UNICODE builds</span>
00770 <span class="comment">//-----------------------------------------------------------------------------</span>
00771 HRESULT DXUtil_ConvertWideStringToGenericCch( TCHAR* tstrDestination, <span class="keyword">const</span> WCHAR* wstrSource, 
00772                                            <span class="keywordtype">int</span> cchDestChar )
00773 {
00774     <span class="keywordflow">if</span>( tstrDestination==NULL || wstrSource==NULL || cchDestChar &lt; 1 )
00775         <span class="keywordflow">return</span> E_INVALIDARG;
00776 
00777 <span class="preprocessor">#ifdef _UNICODE</span>
00778 <span class="preprocessor"></span>    wcsncpy( tstrDestination, wstrSource, cchDestChar );
00779     tstrDestination[cchDestChar-1] = L<span class="charliteral">'\0'</span>;    
00780     <span class="keywordflow">return</span> S_OK;
00781 <span class="preprocessor">#else</span>
00782 <span class="preprocessor"></span>    <span class="keywordflow">return</span> DXUtil_ConvertWideStringToAnsiCch( tstrDestination, wstrSource, cchDestChar );
00783 <span class="preprocessor">#endif</span>
00784 <span class="preprocessor"></span>}
00785 
00786 <span class="comment">//-----------------------------------------------------------------------------</span>
00787 <span class="comment">// Name: DXUtil_Trace()</span>
00788 <span class="comment">// Desc: Outputs to the debug stream a formatted string with a variable-</span>
00789 <span class="comment">//       argument list.</span>
00790 <span class="comment">//-----------------------------------------------------------------------------</span>
00791 VOID DXUtil_Trace( LPCTSTR strMsg, ... )
00792 {
00793 <span class="preprocessor">#if defined(DEBUG) | defined(_DEBUG)</span>
00794 <span class="preprocessor"></span>    TCHAR strBuffer[512];
00795     
00796     va_list args;
00797     va_start(args, strMsg);
00798     _vsntprintf( strBuffer, 512, strMsg, args );
00799     va_end(args);
00800 
00801     OutputDebugString( strBuffer );
00802 <span class="preprocessor">#else</span>
00803 <span class="preprocessor"></span>    UNREFERENCED_PARAMETER(strMsg);
00804 <span class="preprocessor">#endif</span>
00805 <span class="preprocessor"></span>}
00806 
00807 
00808 
00809 
00810 <span class="comment">//-----------------------------------------------------------------------------</span>
00811 <span class="comment">// Name: DXUtil_ConvertStringToGUID()</span>
00812 <span class="comment">// Desc: Converts a string to a GUID</span>
00813 <span class="comment">//-----------------------------------------------------------------------------</span>
00814 HRESULT DXUtil_ConvertStringToGUID( <span class="keyword">const</span> TCHAR* strSrc, GUID* pGuidDest )
00815 {
00816     UINT aiTmp[10];
00817 
00818     <span class="keywordflow">if</span>( _stscanf( strSrc, TEXT(<span class="stringliteral">"{%8X-%4X-%4X-%2X%2X-%2X%2X%2X%2X%2X%2X}"</span>),
00819                     &amp;pGuidDest-&gt;Data1, 
00820                     &amp;aiTmp[0], &amp;aiTmp[1], 
00821                     &amp;aiTmp[2], &amp;aiTmp[3],
00822                     &amp;aiTmp[4], &amp;aiTmp[5],
00823                     &amp;aiTmp[6], &amp;aiTmp[7],
00824                     &amp;aiTmp[8], &amp;aiTmp[9] ) != 11 )
00825     {
00826         ZeroMemory( pGuidDest, <span class="keyword">sizeof</span>(GUID) );
00827         <span class="keywordflow">return</span> E_FAIL;
00828     }
00829     <span class="keywordflow">else</span>
00830     {
00831         pGuidDest-&gt;Data2       = (USHORT) aiTmp[0];
00832         pGuidDest-&gt;Data3       = (USHORT) aiTmp[1];
00833         pGuidDest-&gt;Data4[0]    = (BYTE) aiTmp[2];
00834         pGuidDest-&gt;Data4[1]    = (BYTE) aiTmp[3];
00835         pGuidDest-&gt;Data4[2]    = (BYTE) aiTmp[4];
00836         pGuidDest-&gt;Data4[3]    = (BYTE) aiTmp[5];
00837         pGuidDest-&gt;Data4[4]    = (BYTE) aiTmp[6];
00838         pGuidDest-&gt;Data4[5]    = (BYTE) aiTmp[7];
00839         pGuidDest-&gt;Data4[6]    = (BYTE) aiTmp[8];
00840         pGuidDest-&gt;Data4[7]    = (BYTE) aiTmp[9];
00841         <span class="keywordflow">return</span> S_OK;
00842     }
00843 }
00844 
00845 
00846 
00847 
00848 <span class="comment">//-----------------------------------------------------------------------------</span>
00849 <span class="comment">// Name: DXUtil_ConvertGUIDToStringCch()</span>
00850 <span class="comment">// Desc: Converts a GUID to a string </span>
00851 <span class="comment">//       cchDestChar is the size in TCHARs of strDest.  Be careful not to </span>
00852 <span class="comment">//       pass in sizeof(strDest) on UNICODE builds</span>
00853 <span class="comment">//-----------------------------------------------------------------------------</span>
00854 HRESULT DXUtil_ConvertGUIDToStringCch( <span class="keyword">const</span> GUID* pGuidSrc, TCHAR* strDest, <span class="keywordtype">int</span> cchDestChar )
00855 {
00856     <span class="keywordtype">int</span> nResult = _sntprintf( strDest, cchDestChar, TEXT(<span class="stringliteral">"{%0.8X-%0.4X-%0.4X-%0.2X%0.2X-%0.2X%0.2X%0.2X%0.2X%0.2X%0.2X}"</span>),
00857                pGuidSrc-&gt;Data1, pGuidSrc-&gt;Data2, pGuidSrc-&gt;Data3,
00858                pGuidSrc-&gt;Data4[0], pGuidSrc-&gt;Data4[1],
00859                pGuidSrc-&gt;Data4[2], pGuidSrc-&gt;Data4[3],
00860                pGuidSrc-&gt;Data4[4], pGuidSrc-&gt;Data4[5],
00861                pGuidSrc-&gt;Data4[6], pGuidSrc-&gt;Data4[7] );
00862 
00863     <span class="keywordflow">if</span>( nResult &lt; 0 )
00864         <span class="keywordflow">return</span> E_FAIL;
00865     <span class="keywordflow">return</span> S_OK;
00866 }
00867 
00868 
00869 
00870 
00871 <span class="comment">//-----------------------------------------------------------------------------</span>
00872 <span class="comment">// Name: CArrayList constructor</span>
00873 <span class="comment">// Desc: </span>
00874 <span class="comment">//-----------------------------------------------------------------------------</span>
00875 CArrayList::CArrayList( ArrayListType Type, UINT BytesPerEntry )
00876 {
00877     <span class="keywordflow">if</span>( Type == AL_REFERENCE )
00878         BytesPerEntry = <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*);
00879     m_ArrayListType = Type;
00880     m_pData = NULL;
00881     m_BytesPerEntry = BytesPerEntry;
00882     m_NumEntries = 0;
00883     m_NumEntriesAllocated = 0;
00884 }
00885 
00886 
00887 
00888 <span class="comment">//-----------------------------------------------------------------------------</span>
00889 <span class="comment">// Name: CArrayList destructor</span>
00890 <span class="comment">// Desc: </span>
00891 <span class="comment">//-----------------------------------------------------------------------------</span>
00892 CArrayList::~CArrayList( <span class="keywordtype">void</span> )
00893 {
00894     <span class="keywordflow">if</span>( m_pData != NULL )
00895         <span class="keyword">delete</span>[] m_pData;
00896 }
00897 
00898 
00899 
00900 
00901 <span class="comment">//-----------------------------------------------------------------------------</span>
00902 <span class="comment">// Name: CArrayList::Add</span>
00903 <span class="comment">// Desc: Adds pEntry to the list.</span>
00904 <span class="comment">//-----------------------------------------------------------------------------</span>
00905 HRESULT CArrayList::Add( <span class="keywordtype">void</span>* pEntry )
00906 {
00907     <span class="keywordflow">if</span>( m_BytesPerEntry == 0 )
00908         <span class="keywordflow">return</span> E_FAIL;
00909     <span class="keywordflow">if</span>( m_pData == NULL || m_NumEntries + 1 &gt; m_NumEntriesAllocated )
00910     {
00911         <span class="keywordtype">void</span>* pDataNew;
00912         UINT NumEntriesAllocatedNew;
00913         <span class="keywordflow">if</span>( m_NumEntriesAllocated == 0 )
00914             NumEntriesAllocatedNew = 16;
00915         <span class="keywordflow">else</span>
00916             NumEntriesAllocatedNew = m_NumEntriesAllocated * 2;
00917         pDataNew = <span class="keyword">new</span> BYTE[NumEntriesAllocatedNew * m_BytesPerEntry];
00918         <span class="keywordflow">if</span>( pDataNew == NULL )
00919             <span class="keywordflow">return</span> E_OUTOFMEMORY;
00920         <span class="keywordflow">if</span>( m_pData != NULL )
00921         {
00922             CopyMemory( pDataNew, m_pData, m_NumEntries * m_BytesPerEntry );
00923             <span class="keyword">delete</span>[] m_pData;
00924         }
00925         m_pData = pDataNew;
00926         m_NumEntriesAllocated = NumEntriesAllocatedNew;
00927     }
00928 
00929     <span class="keywordflow">if</span>( m_ArrayListType == AL_VALUE )
00930         CopyMemory( (BYTE*)m_pData + (m_NumEntries * m_BytesPerEntry), pEntry, m_BytesPerEntry );
00931     <span class="keywordflow">else</span>
00932         *(((<span class="keywordtype">void</span>**)m_pData) + m_NumEntries) = pEntry;
00933     m_NumEntries++;
00934 
00935     <span class="keywordflow">return</span> S_OK;
00936 }
00937 
00938 
00939 
00940 
00941 <span class="comment">//-----------------------------------------------------------------------------</span>
00942 <span class="comment">// Name: CArrayList::Remove</span>
00943 <span class="comment">// Desc: Remove the item at Entry in the list, and collapse the array. </span>
00944 <span class="comment">//-----------------------------------------------------------------------------</span>
00945 <span class="keywordtype">void</span> CArrayList::Remove( UINT Entry )
00946 {
00947     <span class="comment">// Decrement count</span>
00948     m_NumEntries--;
00949 
00950     <span class="comment">// Find the entry address</span>
00951     BYTE* pData = (BYTE*)m_pData + (Entry * m_BytesPerEntry);
00952 
00953     <span class="comment">// Collapse the array</span>
00954     MoveMemory( pData, pData + m_BytesPerEntry, ( m_NumEntries - Entry ) * m_BytesPerEntry );
00955 }
00956 
00957 
00958 
00959 
00960 <span class="comment">//-----------------------------------------------------------------------------</span>
00961 <span class="comment">// Name: CArrayList::GetPtr</span>
00962 <span class="comment">// Desc: Returns a pointer to the Entry'th entry in the list.</span>
00963 <span class="comment">//-----------------------------------------------------------------------------</span>
00964 <span class="keywordtype">void</span>* CArrayList::GetPtr( UINT Entry )
00965 {
00966     <span class="keywordflow">if</span>( m_ArrayListType == AL_VALUE )
00967         <span class="keywordflow">return</span> (BYTE*)m_pData + (Entry * m_BytesPerEntry);
00968     <span class="keywordflow">else</span>
00969         <span class="keywordflow">return</span> *(((<span class="keywordtype">void</span>**)m_pData) + Entry);
00970 }
00971 
00972 
00973 
00974 
00975 <span class="comment">//-----------------------------------------------------------------------------</span>
00976 <span class="comment">// Name: CArrayList::Contains</span>
00977 <span class="comment">// Desc: Returns whether the list contains an entry identical to the </span>
00978 <span class="comment">//       specified entry data.</span>
00979 <span class="comment">//-----------------------------------------------------------------------------</span>
00980 <span class="keywordtype">bool</span> CArrayList::Contains( <span class="keywordtype">void</span>* pEntryData )
00981 {
00982     <span class="keywordflow">for</span>( UINT iEntry = 0; iEntry &lt; m_NumEntries; iEntry++ )
00983     {
00984         <span class="keywordflow">if</span>( m_ArrayListType == AL_VALUE )
00985         {
00986             <span class="keywordflow">if</span>( memcmp( GetPtr(iEntry), pEntryData, m_BytesPerEntry ) == 0 )
00987                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00988         }
00989         <span class="keywordflow">else</span>
00990         {
00991             <span class="keywordflow">if</span>( GetPtr(iEntry) == pEntryData )
00992                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00993         }
00994     }
00995     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00996 }
00997 
00998 
00999 
01000 
01001 <span class="comment">//-----------------------------------------------------------------------------</span>
01002 <span class="comment">// Name: BYTE helper functions</span>
01003 <span class="comment">// Desc: cchDestChar is the size in BYTEs of strDest.  Be careful not to </span>
01004 <span class="comment">//       pass use sizeof() if the strDest is a string pointer.  </span>
01005 <span class="comment">//       eg.</span>
01006 <span class="comment">//       TCHAR* sz = new TCHAR[100]; // sizeof(sz)  == 4</span>
01007 <span class="comment">//       TCHAR sz2[100];             // sizeof(sz2) == 200</span>
01008 <span class="comment">//-----------------------------------------------------------------------------</span>
01009 HRESULT DXUtil_ConvertAnsiStringToWideCb( WCHAR* wstrDestination, <span class="keyword">const</span> CHAR* strSource, <span class="keywordtype">int</span> cbDestChar )
01010 {
01011     <span class="keywordflow">return</span> DXUtil_ConvertAnsiStringToWideCch( wstrDestination, strSource, cbDestChar / <span class="keyword">sizeof</span>(WCHAR) );
01012 }
01013 
01014 HRESULT DXUtil_ConvertWideStringToAnsiCb( CHAR* strDestination, <span class="keyword">const</span> WCHAR* wstrSource, <span class="keywordtype">int</span> cbDestChar )
01015 {
01016     <span class="keywordflow">return</span> DXUtil_ConvertWideStringToAnsiCch( strDestination, wstrSource, cbDestChar / <span class="keyword">sizeof</span>(CHAR) );
01017 }
01018 
01019 HRESULT DXUtil_ConvertGenericStringToAnsiCb( CHAR* strDestination, <span class="keyword">const</span> TCHAR* tstrSource, <span class="keywordtype">int</span> cbDestChar )
01020 {
01021     <span class="keywordflow">return</span> DXUtil_ConvertGenericStringToAnsiCch( strDestination, tstrSource, cbDestChar / <span class="keyword">sizeof</span>(CHAR) );
01022 }
01023 
01024 HRESULT DXUtil_ConvertGenericStringToWideCb( WCHAR* wstrDestination, <span class="keyword">const</span> TCHAR* tstrSource, <span class="keywordtype">int</span> cbDestChar )
01025 {
01026     <span class="keywordflow">return</span> DXUtil_ConvertGenericStringToWideCch( wstrDestination, tstrSource, cbDestChar / <span class="keyword">sizeof</span>(WCHAR) );
01027 }
01028 
01029 HRESULT DXUtil_ConvertAnsiStringToGenericCb( TCHAR* tstrDestination, <span class="keyword">const</span> CHAR* strSource, <span class="keywordtype">int</span> cbDestChar )
01030 {
01031     <span class="keywordflow">return</span> DXUtil_ConvertAnsiStringToGenericCch( tstrDestination, strSource, cbDestChar / <span class="keyword">sizeof</span>(TCHAR) );
01032 }
01033 
01034 HRESULT DXUtil_ConvertWideStringToGenericCb( TCHAR* tstrDestination, <span class="keyword">const</span> WCHAR* wstrSource, <span class="keywordtype">int</span> cbDestChar )
01035 {
01036     <span class="keywordflow">return</span> DXUtil_ConvertWideStringToGenericCch( tstrDestination, wstrSource, cbDestChar / <span class="keyword">sizeof</span>(TCHAR) );
01037 }
01038 
01039 HRESULT DXUtil_ReadStringRegKeyCb( HKEY hKey, LPCTSTR strRegName, TCHAR* strDest, DWORD cbDest, LPCTSTR strDefault )
01040 {
01041     <span class="keywordflow">return</span> DXUtil_ReadStringRegKeyCch( hKey, strRegName, strDest, cbDest / <span class="keyword">sizeof</span>(TCHAR), strDefault );
01042 }
01043 
01044 HRESULT DXUtil_ConvertGUIDToStringCb( <span class="keyword">const</span> GUID* pGuidSrc, TCHAR* strDest, <span class="keywordtype">int</span> cbDestChar )
01045 {
01046     <span class="keywordflow">return</span> DXUtil_ConvertGUIDToStringCch( pGuidSrc, strDest, cbDestChar / <span class="keyword">sizeof</span>(TCHAR) );
01047 }
01048 
01049 <span class="preprocessor">#ifndef UNDER_CE</span>
01050 <span class="preprocessor"></span>HRESULT DXUtil_GetDXSDKMediaPathCb( TCHAR* szDest, <span class="keywordtype">int</span> cbDest )
01051 {
01052     <span class="keywordflow">return</span> DXUtil_GetDXSDKMediaPathCch( szDest, cbDest / <span class="keyword">sizeof</span>(TCHAR) );
01053 }
01054 
01055 HRESULT DXUtil_FindMediaFileCb( TCHAR* szDestPath, <span class="keywordtype">int</span> cbDest, LPCTSTR strFilename )
01056 {
01057     <span class="keywordflow">return</span> DXUtil_FindMediaFileCch( szDestPath, cbDest / <span class="keyword">sizeof</span>(TCHAR), strFilename );
01058 }
01059 <span class="preprocessor">#endif // !UNDER_CE</span>
</pre></div><hr><address style="align: right;"><small>
Generated on Tue Jun 13 11:14:34 2006 for gRenderDX9 by <a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 width=110 height=53>
</a> 1.3.1 using KingsTools</small></address>
</body>
</html>
