<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gRenderDX9: d3dx9math.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.1 -->
<h1>d3dx9math.h</h1><div class="fragment"><pre>00001 
00002 <span class="comment">//</span>
00003 <span class="comment">//  Copyright (C) Microsoft Corporation.  All Rights Reserved.</span>
00004 <span class="comment">//</span>
00005 <span class="comment">//  File:       d3dx9math.h</span>
00006 <span class="comment">//  Content:    D3DX math types and functions</span>
00007 <span class="comment">//</span>
00009 <span class="comment"></span>
00010 <span class="preprocessor">#include "d3dx9.h"</span>
00011 
00012 <span class="preprocessor">#ifndef __D3DX9MATH_H__</span>
00013 <span class="preprocessor"></span><span class="preprocessor">#define __D3DX9MATH_H__</span>
00014 <span class="preprocessor"></span>
00015 <span class="preprocessor">#include &lt;math.h&gt;</span>
00016 <span class="preprocessor">#if _MSC_VER &gt;= 1200</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(push)</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(disable:4201) // anonymous unions warning</span>
00020 <span class="preprocessor"></span>
00021 
00022 
00023 <span class="comment">//===========================================================================</span>
00024 <span class="comment">//</span>
00025 <span class="comment">// General purpose utilities</span>
00026 <span class="comment">//</span>
00027 <span class="comment">//===========================================================================</span>
00028 <span class="preprocessor">#define D3DX_PI    ((FLOAT)  3.141592654f)</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#define D3DX_1BYPI ((FLOAT)  0.318309886f)</span>
00030 <span class="preprocessor"></span>
00031 <span class="preprocessor">#define D3DXToRadian( degree ) ((degree) * (D3DX_PI / 180.0f))</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define D3DXToDegree( radian ) ((radian) * (180.0f / D3DX_PI))</span>
00033 <span class="preprocessor"></span>
00034 
00035 
00036 <span class="comment">//===========================================================================</span>
00037 <span class="comment">//</span>
00038 <span class="comment">// 16 bit floating point numbers</span>
00039 <span class="comment">//</span>
00040 <span class="comment">//===========================================================================</span>
00041 
00042 <span class="preprocessor">#define D3DX_16F_DIG          3                // # of decimal digits of precision</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#define D3DX_16F_EPSILON      4.8875809e-4f    // smallest such that 1.0 + epsilon != 1.0</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#define D3DX_16F_MANT_DIG     11               // # of bits in mantissa</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#define D3DX_16F_MAX          6.550400e+004    // max value</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define D3DX_16F_MAX_10_EXP   4                // max decimal exponent</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#define D3DX_16F_MAX_EXP      15               // max binary exponent</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#define D3DX_16F_MIN          6.1035156e-5f    // min positive value</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#define D3DX_16F_MIN_10_EXP   (-4)             // min decimal exponent</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#define D3DX_16F_MIN_EXP      (-12)            // min binary exponent</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#define D3DX_16F_RADIX        2                // exponent radix</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#define D3DX_16F_ROUNDS       1                // addition rounding: near</span>
00053 <span class="preprocessor"></span>
00054 
00055 <span class="keyword">typedef</span> <span class="keyword">struct </span>D3DXFLOAT16
00056 {
00057 <span class="preprocessor">#ifdef __cplusplus</span>
00058 <span class="preprocessor"></span><span class="keyword">public</span>:
00059     D3DXFLOAT16() {};
00060     D3DXFLOAT16( FLOAT );
00061     D3DXFLOAT16( CONST D3DXFLOAT16&amp; );
00062 
00063     <span class="comment">// casting</span>
00064     operator FLOAT ();
00065 
00066     <span class="comment">// binary operators</span>
00067     BOOL operator == ( CONST D3DXFLOAT16&amp; ) <span class="keyword">const</span>;
00068     BOOL operator != ( CONST D3DXFLOAT16&amp; ) <span class="keyword">const</span>;
00069 
00070 <span class="keyword">protected</span>:
00071 <span class="preprocessor">#endif //__cplusplus</span>
00072 <span class="preprocessor"></span>    WORD value;
00073 } D3DXFLOAT16, *LPD3DXFLOAT16;
00074 
00075 
00076 
00077 <span class="comment">//===========================================================================</span>
00078 <span class="comment">//</span>
00079 <span class="comment">// Vectors</span>
00080 <span class="comment">//</span>
00081 <span class="comment">//===========================================================================</span>
00082 
00083 
00084 <span class="comment">//--------------------------</span>
00085 <span class="comment">// 2D Vector</span>
00086 <span class="comment">//--------------------------</span>
00087 <span class="keyword">typedef</span> <span class="keyword">struct </span>D3DXVECTOR2
00088 {
00089 <span class="preprocessor">#ifdef __cplusplus</span>
00090 <span class="preprocessor"></span><span class="keyword">public</span>:
00091     D3DXVECTOR2() {};
00092     D3DXVECTOR2( CONST FLOAT * );
00093     D3DXVECTOR2( CONST D3DXFLOAT16 * );
00094     D3DXVECTOR2( FLOAT x, FLOAT y );
00095 
00096     <span class="comment">// casting</span>
00097     operator FLOAT* ();
00098     operator CONST FLOAT* () <span class="keyword">const</span>;
00099 
00100     <span class="comment">// assignment operators</span>
00101     D3DXVECTOR2&amp; operator += ( CONST D3DXVECTOR2&amp; );
00102     D3DXVECTOR2&amp; operator -= ( CONST D3DXVECTOR2&amp; );
00103     D3DXVECTOR2&amp; operator *= ( FLOAT );
00104     D3DXVECTOR2&amp; operator /= ( FLOAT );
00105 
00106     <span class="comment">// unary operators</span>
00107     D3DXVECTOR2 operator + () <span class="keyword">const</span>;
00108     D3DXVECTOR2 operator - () <span class="keyword">const</span>;
00109 
00110     <span class="comment">// binary operators</span>
00111     D3DXVECTOR2 operator + ( CONST D3DXVECTOR2&amp; ) <span class="keyword">const</span>;
00112     D3DXVECTOR2 operator - ( CONST D3DXVECTOR2&amp; ) <span class="keyword">const</span>;
00113     D3DXVECTOR2 operator * ( FLOAT ) <span class="keyword">const</span>;
00114     D3DXVECTOR2 operator / ( FLOAT ) <span class="keyword">const</span>;
00115 
00116     <span class="keyword">friend</span> D3DXVECTOR2 operator * ( FLOAT, CONST D3DXVECTOR2&amp; );
00117 
00118     BOOL operator == ( CONST D3DXVECTOR2&amp; ) <span class="keyword">const</span>;
00119     BOOL operator != ( CONST D3DXVECTOR2&amp; ) <span class="keyword">const</span>;
00120 
00121 
00122 <span class="keyword">public</span>:
00123 <span class="preprocessor">#endif //__cplusplus</span>
00124 <span class="preprocessor"></span>    FLOAT x, y;
00125 } D3DXVECTOR2, *LPD3DXVECTOR2;
00126 
00127 
00128 
00129 <span class="comment">//--------------------------</span>
00130 <span class="comment">// 2D Vector (16 bit)</span>
00131 <span class="comment">//--------------------------</span>
00132 
00133 <span class="keyword">typedef</span> <span class="keyword">struct </span>D3DXVECTOR2_16F
00134 {
00135 <span class="preprocessor">#ifdef __cplusplus</span>
00136 <span class="preprocessor"></span><span class="keyword">public</span>:
00137     D3DXVECTOR2_16F() {};
00138     D3DXVECTOR2_16F( CONST FLOAT * );
00139     D3DXVECTOR2_16F( CONST D3DXFLOAT16 * );
00140     D3DXVECTOR2_16F( CONST D3DXFLOAT16 &amp;x, CONST D3DXFLOAT16 &amp;y );
00141 
00142     <span class="comment">// casting</span>
00143     operator D3DXFLOAT16* ();
00144     operator CONST D3DXFLOAT16* () <span class="keyword">const</span>;
00145 
00146     <span class="comment">// binary operators</span>
00147     BOOL operator == ( CONST D3DXVECTOR2_16F&amp; ) <span class="keyword">const</span>;
00148     BOOL operator != ( CONST D3DXVECTOR2_16F&amp; ) <span class="keyword">const</span>;
00149 
00150 <span class="keyword">public</span>:
00151 <span class="preprocessor">#endif //__cplusplus</span>
00152 <span class="preprocessor"></span>    D3DXFLOAT16 x, y;
00153 
00154 } D3DXVECTOR2_16F, *LPD3DXVECTOR2_16F;
00155 
00156 
00157 
00158 <span class="comment">//--------------------------</span>
00159 <span class="comment">// 3D Vector</span>
00160 <span class="comment">//--------------------------</span>
00161 <span class="preprocessor">#ifdef __cplusplus</span>
00162 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span>D3DXVECTOR3 : <span class="keyword">public</span> D3DVECTOR
00163 {
00164 <span class="keyword">public</span>:
00165     D3DXVECTOR3() {};
00166     D3DXVECTOR3( CONST FLOAT * );
00167     D3DXVECTOR3( CONST D3DVECTOR&amp; );
00168     D3DXVECTOR3( CONST D3DXFLOAT16 * );
00169     D3DXVECTOR3( FLOAT x, FLOAT y, FLOAT z );
00170 
00171     <span class="comment">// casting</span>
00172     operator FLOAT* ();
00173     operator CONST FLOAT* () <span class="keyword">const</span>;
00174 
00175     <span class="comment">// assignment operators</span>
00176     D3DXVECTOR3&amp; operator += ( CONST D3DXVECTOR3&amp; );
00177     D3DXVECTOR3&amp; operator -= ( CONST D3DXVECTOR3&amp; );
00178     D3DXVECTOR3&amp; operator *= ( FLOAT );
00179     D3DXVECTOR3&amp; operator /= ( FLOAT );
00180 
00181     <span class="comment">// unary operators</span>
00182     D3DXVECTOR3 operator + () <span class="keyword">const</span>;
00183     D3DXVECTOR3 operator - () <span class="keyword">const</span>;
00184 
00185     <span class="comment">// binary operators</span>
00186     D3DXVECTOR3 operator + ( CONST D3DXVECTOR3&amp; ) <span class="keyword">const</span>;
00187     D3DXVECTOR3 operator - ( CONST D3DXVECTOR3&amp; ) <span class="keyword">const</span>;
00188     D3DXVECTOR3 operator * ( FLOAT ) <span class="keyword">const</span>;
00189     D3DXVECTOR3 operator / ( FLOAT ) <span class="keyword">const</span>;
00190 
00191     <span class="keyword">friend</span> D3DXVECTOR3 operator * ( FLOAT, CONST <span class="keyword">struct</span> D3DXVECTOR3&amp; );
00192 
00193     BOOL operator == ( CONST D3DXVECTOR3&amp; ) <span class="keyword">const</span>;
00194     BOOL operator != ( CONST D3DXVECTOR3&amp; ) <span class="keyword">const</span>;
00195 
00196 } D3DXVECTOR3, *LPD3DXVECTOR3;
00197 
00198 <span class="preprocessor">#else </span>
00199 <span class="preprocessor">typedef struct _D3DVECTOR D3DXVECTOR3, *LPD3DXVECTOR3;</span>
00200 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
00201 <span class="preprocessor"></span>
00202 <span class="preprocessor"></span>
00203 
00204 <span class="comment">//--------------------------</span>
00205 <span class="comment">// 3D Vector (16 bit)</span>
00206 <span class="comment">//--------------------------</span>
00207 <span class="keyword">typedef</span> <span class="keyword">struct </span>D3DXVECTOR3_16F
00208 {
00209 <span class="preprocessor">#ifdef __cplusplus</span>
00210 <span class="preprocessor"></span><span class="keyword">public</span>:
00211     D3DXVECTOR3_16F() {};
00212     D3DXVECTOR3_16F( CONST FLOAT * );
00213     D3DXVECTOR3_16F( CONST D3DVECTOR&amp; );
00214     D3DXVECTOR3_16F( CONST D3DXFLOAT16 * );
00215     D3DXVECTOR3_16F( CONST D3DXFLOAT16 &amp;x, CONST D3DXFLOAT16 &amp;y, CONST D3DXFLOAT16 &amp;z );
00216 
00217     <span class="comment">// casting</span>
00218     operator D3DXFLOAT16* ();
00219     operator CONST D3DXFLOAT16* () <span class="keyword">const</span>;
00220 
00221     <span class="comment">// binary operators</span>
00222     BOOL operator == ( CONST D3DXVECTOR3_16F&amp; ) <span class="keyword">const</span>;
00223     BOOL operator != ( CONST D3DXVECTOR3_16F&amp; ) <span class="keyword">const</span>;
00224 
00225 <span class="keyword">public</span>:
00226 <span class="preprocessor">#endif //__cplusplus</span>
00227 <span class="preprocessor"></span>    D3DXFLOAT16 x, y, z;
00228 
00229 } D3DXVECTOR3_16F, *LPD3DXVECTOR3_16F;
00230 
00231 
00232 
00233 <span class="comment">//--------------------------</span>
00234 <span class="comment">// 4D Vector</span>
00235 <span class="comment">//--------------------------</span>
00236 <span class="keyword">typedef</span> <span class="keyword">struct </span>D3DXVECTOR4
00237 {
00238 <span class="preprocessor">#ifdef __cplusplus</span>
00239 <span class="preprocessor"></span><span class="keyword">public</span>:
00240     D3DXVECTOR4() {};
00241     D3DXVECTOR4( CONST FLOAT* );
00242     D3DXVECTOR4( CONST D3DXFLOAT16* );
00243     D3DXVECTOR4( CONST D3DVECTOR&amp; xyz, FLOAT w );
00244     D3DXVECTOR4( FLOAT x, FLOAT y, FLOAT z, FLOAT w );
00245 
00246     <span class="comment">// casting</span>
00247     operator FLOAT* ();
00248     operator CONST FLOAT* () <span class="keyword">const</span>;
00249 
00250     <span class="comment">// assignment operators</span>
00251     D3DXVECTOR4&amp; operator += ( CONST D3DXVECTOR4&amp; );
00252     D3DXVECTOR4&amp; operator -= ( CONST D3DXVECTOR4&amp; );
00253     D3DXVECTOR4&amp; operator *= ( FLOAT );
00254     D3DXVECTOR4&amp; operator /= ( FLOAT );
00255 
00256     <span class="comment">// unary operators</span>
00257     D3DXVECTOR4 operator + () <span class="keyword">const</span>;
00258     D3DXVECTOR4 operator - () <span class="keyword">const</span>;
00259 
00260     <span class="comment">// binary operators</span>
00261     D3DXVECTOR4 operator + ( CONST D3DXVECTOR4&amp; ) <span class="keyword">const</span>;
00262     D3DXVECTOR4 operator - ( CONST D3DXVECTOR4&amp; ) <span class="keyword">const</span>;
00263     D3DXVECTOR4 operator * ( FLOAT ) <span class="keyword">const</span>;
00264     D3DXVECTOR4 operator / ( FLOAT ) <span class="keyword">const</span>;
00265 
00266     <span class="keyword">friend</span> D3DXVECTOR4 operator * ( FLOAT, CONST D3DXVECTOR4&amp; );
00267 
00268     BOOL operator == ( CONST D3DXVECTOR4&amp; ) <span class="keyword">const</span>;
00269     BOOL operator != ( CONST D3DXVECTOR4&amp; ) <span class="keyword">const</span>;
00270 
00271 <span class="keyword">public</span>:
00272 <span class="preprocessor">#endif //__cplusplus</span>
00273 <span class="preprocessor"></span>    FLOAT x, y, z, w;
00274 } D3DXVECTOR4, *LPD3DXVECTOR4;
00275 
00276 
00277 <span class="comment">//--------------------------</span>
00278 <span class="comment">// 4D Vector (16 bit)</span>
00279 <span class="comment">//--------------------------</span>
00280 <span class="keyword">typedef</span> <span class="keyword">struct </span>D3DXVECTOR4_16F
00281 {
00282 <span class="preprocessor">#ifdef __cplusplus</span>
00283 <span class="preprocessor"></span><span class="keyword">public</span>:
00284     D3DXVECTOR4_16F() {};
00285     D3DXVECTOR4_16F( CONST FLOAT * );
00286     D3DXVECTOR4_16F( CONST D3DXFLOAT16* );
00287     D3DXVECTOR4_16F( CONST D3DXVECTOR3_16F&amp; xyz, CONST D3DXFLOAT16&amp; w );
00288     D3DXVECTOR4_16F( CONST D3DXFLOAT16&amp; x, CONST D3DXFLOAT16&amp; y, CONST D3DXFLOAT16&amp; z, CONST D3DXFLOAT16&amp; w );
00289 
00290     <span class="comment">// casting</span>
00291     operator D3DXFLOAT16* ();
00292     operator CONST D3DXFLOAT16* () <span class="keyword">const</span>;
00293 
00294     <span class="comment">// binary operators</span>
00295     BOOL operator == ( CONST D3DXVECTOR4_16F&amp; ) <span class="keyword">const</span>;
00296     BOOL operator != ( CONST D3DXVECTOR4_16F&amp; ) <span class="keyword">const</span>;
00297 
00298 <span class="keyword">public</span>:
00299 <span class="preprocessor">#endif //__cplusplus</span>
00300 <span class="preprocessor"></span>    D3DXFLOAT16 x, y, z, w;
00301 
00302 } D3DXVECTOR4_16F, *LPD3DXVECTOR4_16F;
00303 
00304 
00305 
00306 <span class="comment">//===========================================================================</span>
00307 <span class="comment">//</span>
00308 <span class="comment">// Matrices</span>
00309 <span class="comment">//</span>
00310 <span class="comment">//===========================================================================</span>
00311 <span class="preprocessor">#ifdef __cplusplus</span>
00312 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span>D3DXMATRIX : <span class="keyword">public</span> D3DMATRIX
00313 {
00314 <span class="keyword">public</span>:
00315     D3DXMATRIX() {};
00316     D3DXMATRIX( CONST FLOAT * );
00317     D3DXMATRIX( CONST D3DMATRIX&amp; );
00318     D3DXMATRIX( CONST D3DXFLOAT16 * );
00319     D3DXMATRIX( FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,
00320                 FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,
00321                 FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,
00322                 FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44 );
00323 
00324 
00325     <span class="comment">// access grants</span>
00326     FLOAT&amp; operator () ( UINT Row, UINT Col );
00327     FLOAT  operator () ( UINT Row, UINT Col ) <span class="keyword">const</span>;
00328 
00329     <span class="comment">// casting operators</span>
00330     operator FLOAT* ();
00331     operator CONST FLOAT* () <span class="keyword">const</span>;
00332 
00333     <span class="comment">// assignment operators</span>
00334     D3DXMATRIX&amp; operator *= ( CONST D3DXMATRIX&amp; );
00335     D3DXMATRIX&amp; operator += ( CONST D3DXMATRIX&amp; );
00336     D3DXMATRIX&amp; operator -= ( CONST D3DXMATRIX&amp; );
00337     D3DXMATRIX&amp; operator *= ( FLOAT );
00338     D3DXMATRIX&amp; operator /= ( FLOAT );
00339 
00340     <span class="comment">// unary operators</span>
00341     D3DXMATRIX operator + () <span class="keyword">const</span>;
00342     D3DXMATRIX operator - () <span class="keyword">const</span>;
00343 
00344     <span class="comment">// binary operators</span>
00345     D3DXMATRIX operator * ( CONST D3DXMATRIX&amp; ) <span class="keyword">const</span>;
00346     D3DXMATRIX operator + ( CONST D3DXMATRIX&amp; ) <span class="keyword">const</span>;
00347     D3DXMATRIX operator - ( CONST D3DXMATRIX&amp; ) <span class="keyword">const</span>;
00348     D3DXMATRIX operator * ( FLOAT ) <span class="keyword">const</span>;
00349     D3DXMATRIX operator / ( FLOAT ) <span class="keyword">const</span>;
00350 
00351     <span class="keyword">friend</span> D3DXMATRIX operator * ( FLOAT, CONST D3DXMATRIX&amp; );
00352 
00353     BOOL operator == ( CONST D3DXMATRIX&amp; ) <span class="keyword">const</span>;
00354     BOOL operator != ( CONST D3DXMATRIX&amp; ) <span class="keyword">const</span>;
00355 
00356 } D3DXMATRIX, *LPD3DXMATRIX;
00357 
00358 <span class="preprocessor">#else </span>
00359 <span class="preprocessor">typedef struct _D3DMATRIX D3DXMATRIX, *LPD3DXMATRIX;</span>
00360 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
00361 <span class="preprocessor"></span>
00362 <span class="preprocessor"></span>
00363 <span class="comment">//---------------------------------------------------------------------------</span>
00364 <span class="comment">// Aligned Matrices</span>
00365 <span class="comment">//</span>
00366 <span class="comment">// This class helps keep matrices 16-byte aligned as preferred by P4 cpus.</span>
00367 <span class="comment">// It aligns matrices on the stack and on the heap or in global scope.</span>
00368 <span class="comment">// It does this using __declspec(align(16)) which works on VC7 and on VC 6</span>
00369 <span class="comment">// with the processor pack. Unfortunately there is no way to detect the </span>
00370 <span class="comment">// latter so this is turned on only on VC7. On other compilers this is the</span>
00371 <span class="comment">// the same as D3DXMATRIX.</span>
00372 <span class="comment">//</span>
00373 <span class="comment">// Using this class on a compiler that does not actually do the alignment</span>
00374 <span class="comment">// can be dangerous since it will not expose bugs that ignore alignment.</span>
00375 <span class="comment">// E.g if an object of this class in inside a struct or class, and some code</span>
00376 <span class="comment">// memcopys data in it assuming tight packing. This could break on a compiler</span>
00377 <span class="comment">// that eventually start aligning the matrix.</span>
00378 <span class="comment">//---------------------------------------------------------------------------</span>
00379 <span class="preprocessor">#ifdef __cplusplus</span>
00380 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span>_D3DXMATRIXA16 : <span class="keyword">public</span> D3DXMATRIX
00381 {
00382     _D3DXMATRIXA16() {}
00383     _D3DXMATRIXA16( CONST FLOAT * );
00384     _D3DXMATRIXA16( CONST D3DMATRIX&amp; );
00385     _D3DXMATRIXA16( CONST D3DXFLOAT16 * );
00386     _D3DXMATRIXA16( FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,
00387                     FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,
00388                     FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,
00389                     FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44 );
00390 
00391     <span class="comment">// new operators</span>
00392     <span class="keywordtype">void</span>* operator new   ( size_t );
00393     <span class="keywordtype">void</span>* operator new[] ( size_t );
00394 
00395     <span class="comment">// delete operators</span>
00396     <span class="keywordtype">void</span> operator delete   ( <span class="keywordtype">void</span>* );   <span class="comment">// These are NOT virtual; Do not </span>
00397     <span class="keywordtype">void</span> operator delete[] ( <span class="keywordtype">void</span>* );   <span class="comment">// cast to D3DXMATRIX and delete.</span>
00398     
00399     <span class="comment">// assignment operators</span>
00400     _D3DXMATRIXA16&amp; operator = ( CONST D3DXMATRIX&amp; );
00401 
00402 } _D3DXMATRIXA16;
00403 
00404 <span class="preprocessor">#else </span>
00405 <span class="preprocessor">typedef D3DXMATRIX  _D3DXMATRIXA16;</span>
00406 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
00407 <span class="preprocessor"></span>
00408 <span class="preprocessor"></span>
00409 
00410 <span class="preprocessor">#if _MSC_VER &gt;= 1300  // VC7</span>
00411 <span class="preprocessor"></span><span class="preprocessor">#define D3DX_ALIGN16 __declspec(align(16))</span>
00412 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00413 <span class="preprocessor"></span><span class="preprocessor">#define D3DX_ALIGN16  // Earlier compiler may not understand this, do nothing.</span>
00414 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00415 <span class="preprocessor"></span>
00416 <span class="keyword">typedef</span> D3DX_ALIGN16 _D3DXMATRIXA16 D3DXMATRIXA16, *LPD3DXMATRIXA16;
00417 
00418 
00419 
00420 <span class="comment">//===========================================================================</span>
00421 <span class="comment">//</span>
00422 <span class="comment">//    Quaternions</span>
00423 <span class="comment">//</span>
00424 <span class="comment">//===========================================================================</span>
00425 <span class="keyword">typedef</span> <span class="keyword">struct </span>D3DXQUATERNION
00426 {
00427 <span class="preprocessor">#ifdef __cplusplus</span>
00428 <span class="preprocessor"></span><span class="keyword">public</span>:
00429     D3DXQUATERNION() {}
00430     D3DXQUATERNION( CONST FLOAT * );
00431     D3DXQUATERNION( CONST D3DXFLOAT16 * );
00432     D3DXQUATERNION( FLOAT x, FLOAT y, FLOAT z, FLOAT w );
00433 
00434     <span class="comment">// casting</span>
00435     operator FLOAT* ();
00436     operator CONST FLOAT* () <span class="keyword">const</span>;
00437 
00438     <span class="comment">// assignment operators</span>
00439     D3DXQUATERNION&amp; operator += ( CONST D3DXQUATERNION&amp; );
00440     D3DXQUATERNION&amp; operator -= ( CONST D3DXQUATERNION&amp; );
00441     D3DXQUATERNION&amp; operator *= ( CONST D3DXQUATERNION&amp; );
00442     D3DXQUATERNION&amp; operator *= ( FLOAT );
00443     D3DXQUATERNION&amp; operator /= ( FLOAT );
00444 
00445     <span class="comment">// unary operators</span>
00446     D3DXQUATERNION  operator + () <span class="keyword">const</span>;
00447     D3DXQUATERNION  operator - () <span class="keyword">const</span>;
00448 
00449     <span class="comment">// binary operators</span>
00450     D3DXQUATERNION operator + ( CONST D3DXQUATERNION&amp; ) <span class="keyword">const</span>;
00451     D3DXQUATERNION operator - ( CONST D3DXQUATERNION&amp; ) <span class="keyword">const</span>;
00452     D3DXQUATERNION operator * ( CONST D3DXQUATERNION&amp; ) <span class="keyword">const</span>;
00453     D3DXQUATERNION operator * ( FLOAT ) <span class="keyword">const</span>;
00454     D3DXQUATERNION operator / ( FLOAT ) <span class="keyword">const</span>;
00455 
00456     <span class="keyword">friend</span> D3DXQUATERNION operator * (FLOAT, CONST D3DXQUATERNION&amp; );
00457 
00458     BOOL operator == ( CONST D3DXQUATERNION&amp; ) <span class="keyword">const</span>;
00459     BOOL operator != ( CONST D3DXQUATERNION&amp; ) <span class="keyword">const</span>;
00460 
00461 <span class="preprocessor">#endif //__cplusplus</span>
00462 <span class="preprocessor"></span>    FLOAT x, y, z, w;
00463 } D3DXQUATERNION, *LPD3DXQUATERNION;
00464 
00465 
00466 <span class="comment">//===========================================================================</span>
00467 <span class="comment">//</span>
00468 <span class="comment">// Planes</span>
00469 <span class="comment">//</span>
00470 <span class="comment">//===========================================================================</span>
00471 <span class="keyword">typedef</span> <span class="keyword">struct </span>D3DXPLANE
00472 {
00473 <span class="preprocessor">#ifdef __cplusplus</span>
00474 <span class="preprocessor"></span><span class="keyword">public</span>:
00475     D3DXPLANE() {}
00476     D3DXPLANE( CONST FLOAT* );
00477     D3DXPLANE( CONST D3DXFLOAT16* );
00478     D3DXPLANE( FLOAT a, FLOAT b, FLOAT c, FLOAT d );
00479 
00480     <span class="comment">// casting</span>
00481     operator FLOAT* ();
00482     operator CONST FLOAT* () <span class="keyword">const</span>;
00483 
00484     <span class="comment">// assignment operators</span>
00485     D3DXPLANE&amp; operator *= ( FLOAT );
00486     D3DXPLANE&amp; operator /= ( FLOAT );
00487 
00488     <span class="comment">// unary operators</span>
00489     D3DXPLANE operator + () <span class="keyword">const</span>;
00490     D3DXPLANE operator - () <span class="keyword">const</span>;
00491 
00492     <span class="comment">// binary operators</span>
00493     D3DXPLANE operator * ( FLOAT ) <span class="keyword">const</span>;
00494     D3DXPLANE operator / ( FLOAT ) <span class="keyword">const</span>;
00495 
00496     <span class="keyword">friend</span> D3DXPLANE operator * ( FLOAT, CONST D3DXPLANE&amp; );
00497 
00498     BOOL operator == ( CONST D3DXPLANE&amp; ) <span class="keyword">const</span>;
00499     BOOL operator != ( CONST D3DXPLANE&amp; ) <span class="keyword">const</span>;
00500 
00501 <span class="preprocessor">#endif //__cplusplus</span>
00502 <span class="preprocessor"></span>    FLOAT a, b, c, d;
00503 } D3DXPLANE, *LPD3DXPLANE;
00504 
00505 
00506 <span class="comment">//===========================================================================</span>
00507 <span class="comment">//</span>
00508 <span class="comment">// Colors</span>
00509 <span class="comment">//</span>
00510 <span class="comment">//===========================================================================</span>
00511 
00512 <span class="keyword">typedef</span> <span class="keyword">struct </span>D3DXCOLOR
00513 {
00514 <span class="preprocessor">#ifdef __cplusplus</span>
00515 <span class="preprocessor"></span><span class="keyword">public</span>:
00516     D3DXCOLOR() {}
00517     D3DXCOLOR( DWORD argb );
00518     D3DXCOLOR( CONST FLOAT * );
00519     D3DXCOLOR( CONST D3DXFLOAT16 * );
00520     D3DXCOLOR( CONST D3DCOLORVALUE&amp; );
00521     D3DXCOLOR( FLOAT r, FLOAT g, FLOAT b, FLOAT a );
00522 
00523     <span class="comment">// casting</span>
00524     operator DWORD () <span class="keyword">const</span>;
00525 
00526     operator FLOAT* ();
00527     operator CONST FLOAT* () <span class="keyword">const</span>;
00528 
00529     operator D3DCOLORVALUE* ();
00530     operator CONST D3DCOLORVALUE* () <span class="keyword">const</span>;
00531 
00532     operator D3DCOLORVALUE&amp; ();
00533     operator CONST D3DCOLORVALUE&amp; () <span class="keyword">const</span>;
00534 
00535     <span class="comment">// assignment operators</span>
00536     D3DXCOLOR&amp; operator += ( CONST D3DXCOLOR&amp; );
00537     D3DXCOLOR&amp; operator -= ( CONST D3DXCOLOR&amp; );
00538     D3DXCOLOR&amp; operator *= ( FLOAT );
00539     D3DXCOLOR&amp; operator /= ( FLOAT );
00540 
00541     <span class="comment">// unary operators</span>
00542     D3DXCOLOR operator + () <span class="keyword">const</span>;
00543     D3DXCOLOR operator - () <span class="keyword">const</span>;
00544 
00545     <span class="comment">// binary operators</span>
00546     D3DXCOLOR operator + ( CONST D3DXCOLOR&amp; ) <span class="keyword">const</span>;
00547     D3DXCOLOR operator - ( CONST D3DXCOLOR&amp; ) <span class="keyword">const</span>;
00548     D3DXCOLOR operator * ( FLOAT ) <span class="keyword">const</span>;
00549     D3DXCOLOR operator / ( FLOAT ) <span class="keyword">const</span>;
00550 
00551     <span class="keyword">friend</span> D3DXCOLOR operator * ( FLOAT, CONST D3DXCOLOR&amp; );
00552 
00553     BOOL operator == ( CONST D3DXCOLOR&amp; ) <span class="keyword">const</span>;
00554     BOOL operator != ( CONST D3DXCOLOR&amp; ) <span class="keyword">const</span>;
00555 
00556 <span class="preprocessor">#endif //__cplusplus</span>
00557 <span class="preprocessor"></span>    FLOAT r, g, b, a;
00558 } D3DXCOLOR, *LPD3DXCOLOR;
00559 
00560 
00561 
00562 <span class="comment">//===========================================================================</span>
00563 <span class="comment">//</span>
00564 <span class="comment">// D3DX math functions:</span>
00565 <span class="comment">//</span>
00566 <span class="comment">// NOTE:</span>
00567 <span class="comment">//  * All these functions can take the same object as in and out parameters.</span>
00568 <span class="comment">//</span>
00569 <span class="comment">//  * Out parameters are typically also returned as return values, so that</span>
00570 <span class="comment">//    the output of one function may be used as a parameter to another.</span>
00571 <span class="comment">//</span>
00572 <span class="comment">//===========================================================================</span>
00573 
00574 <span class="comment">//--------------------------</span>
00575 <span class="comment">// Float16</span>
00576 <span class="comment">//--------------------------</span>
00577 
00578 <span class="comment">// non-inline</span>
00579 <span class="preprocessor">#ifdef __cplusplus</span>
00580 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00581 <span class="preprocessor">#endif</span>
00582 <span class="preprocessor"></span>
00583 <span class="comment">// Converts an array 32-bit floats to 16-bit floats</span>
00584 D3DXFLOAT16* WINAPI D3DXFloat32To16Array
00585     ( D3DXFLOAT16 *pOut, CONST FLOAT *pIn, UINT n );
00586 
00587 <span class="comment">// Converts an array 16-bit floats to 32-bit floats</span>
00588 FLOAT* WINAPI D3DXFloat16To32Array
00589     ( FLOAT *pOut, CONST D3DXFLOAT16 *pIn, UINT n );
00590 
00591 <span class="preprocessor">#ifdef __cplusplus</span>
00592 <span class="preprocessor"></span>}
00593 <span class="preprocessor">#endif</span>
00594 <span class="preprocessor"></span>
00595 
00596 <span class="comment">//--------------------------</span>
00597 <span class="comment">// 2D Vector</span>
00598 <span class="comment">//--------------------------</span>
00599 
00600 <span class="comment">// inline</span>
00601 
00602 FLOAT D3DXVec2Length
00603     ( CONST D3DXVECTOR2 *pV );
00604 
00605 FLOAT D3DXVec2LengthSq
00606     ( CONST D3DXVECTOR2 *pV );
00607 
00608 FLOAT D3DXVec2Dot
00609     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
00610 
00611 <span class="comment">// Z component of ((x1,y1,0) cross (x2,y2,0))</span>
00612 FLOAT D3DXVec2CCW
00613     ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
00614 
00615 D3DXVECTOR2* D3DXVec2Add
00616     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
00617 
00618 D3DXVECTOR2* D3DXVec2Subtract
00619     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
00620 
00621 <span class="comment">// Minimize each component.  x = min(x1, x2), y = min(y1, y2)</span>
00622 D3DXVECTOR2* D3DXVec2Minimize
00623     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
00624 
00625 <span class="comment">// Maximize each component.  x = max(x1, x2), y = max(y1, y2)</span>
00626 D3DXVECTOR2* D3DXVec2Maximize
00627     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );
00628 
00629 D3DXVECTOR2* D3DXVec2Scale
00630     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s );
00631 
00632 <span class="comment">// Linear interpolation. V1 + s(V2-V1)</span>
00633 D3DXVECTOR2* D3DXVec2Lerp
00634     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
00635       FLOAT s );
00636 
00637 <span class="comment">// non-inline</span>
00638 <span class="preprocessor">#ifdef __cplusplus</span>
00639 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00640 <span class="preprocessor">#endif</span>
00641 <span class="preprocessor"></span>
00642 D3DXVECTOR2* WINAPI D3DXVec2Normalize
00643     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV );
00644 
00645 <span class="comment">// Hermite interpolation between position V1, tangent T1 (when s == 0)</span>
00646 <span class="comment">// and position V2, tangent T2 (when s == 1).</span>
00647 D3DXVECTOR2* WINAPI D3DXVec2Hermite
00648     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pT1,
00649       CONST D3DXVECTOR2 *pV2, CONST D3DXVECTOR2 *pT2, FLOAT s );
00650 
00651 <span class="comment">// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)</span>
00652 D3DXVECTOR2* WINAPI D3DXVec2CatmullRom
00653     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV0, CONST D3DXVECTOR2 *pV1,
00654       CONST D3DXVECTOR2 *pV2, CONST D3DXVECTOR2 *pV3, FLOAT s );
00655 
00656 <span class="comment">// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)</span>
00657 D3DXVECTOR2* WINAPI D3DXVec2BaryCentric
00658     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
00659       CONST D3DXVECTOR2 *pV3, FLOAT f, FLOAT g);
00660 
00661 <span class="comment">// Transform (x, y, 0, 1) by matrix.</span>
00662 D3DXVECTOR4* WINAPI D3DXVec2Transform
00663     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );
00664 
00665 <span class="comment">// Transform (x, y, 0, 1) by matrix, project result back into w=1.</span>
00666 D3DXVECTOR2* WINAPI D3DXVec2TransformCoord
00667     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );
00668 
00669 <span class="comment">// Transform (x, y, 0, 0) by matrix.</span>
00670 D3DXVECTOR2* WINAPI D3DXVec2TransformNormal
00671     ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );
00672      
00673 <span class="comment">// Transform Array (x, y, 0, 1) by matrix.</span>
00674 D3DXVECTOR4* WINAPI D3DXVec2TransformArray
00675     ( D3DXVECTOR4 *pOut, UINT OutStride, CONST D3DXVECTOR2 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n);
00676 
00677 <span class="comment">// Transform Array (x, y, 0, 1) by matrix, project result back into w=1.</span>
00678 D3DXVECTOR2* WINAPI D3DXVec2TransformCoordArray
00679     ( D3DXVECTOR2 *pOut, UINT OutStride, CONST D3DXVECTOR2 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
00680 
00681 <span class="comment">// Transform Array (x, y, 0, 0) by matrix.</span>
00682 D3DXVECTOR2* WINAPI D3DXVec2TransformNormalArray
00683     ( D3DXVECTOR2 *pOut, UINT OutStride, CONST D3DXVECTOR2 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
00684     
00685     
00686 
00687 <span class="preprocessor">#ifdef __cplusplus</span>
00688 <span class="preprocessor"></span>}
00689 <span class="preprocessor">#endif</span>
00690 <span class="preprocessor"></span>
00691 
00692 <span class="comment">//--------------------------</span>
00693 <span class="comment">// 3D Vector</span>
00694 <span class="comment">//--------------------------</span>
00695 
00696 <span class="comment">// inline</span>
00697 
00698 FLOAT D3DXVec3Length
00699     ( CONST D3DXVECTOR3 *pV );
00700 
00701 FLOAT D3DXVec3LengthSq
00702     ( CONST D3DXVECTOR3 *pV );
00703 
00704 FLOAT D3DXVec3Dot
00705     ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
00706 
00707 D3DXVECTOR3* D3DXVec3Cross
00708     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
00709 
00710 D3DXVECTOR3* D3DXVec3Add
00711     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
00712 
00713 D3DXVECTOR3* D3DXVec3Subtract
00714     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
00715 
00716 <span class="comment">// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...</span>
00717 D3DXVECTOR3* D3DXVec3Minimize
00718     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
00719 
00720 <span class="comment">// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...</span>
00721 D3DXVECTOR3* D3DXVec3Maximize
00722     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );
00723 
00724 D3DXVECTOR3* D3DXVec3Scale
00725     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, FLOAT s);
00726 
00727 <span class="comment">// Linear interpolation. V1 + s(V2-V1)</span>
00728 D3DXVECTOR3* D3DXVec3Lerp
00729     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
00730       FLOAT s );
00731 
00732 <span class="comment">// non-inline</span>
00733 <span class="preprocessor">#ifdef __cplusplus</span>
00734 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00735 <span class="preprocessor">#endif</span>
00736 <span class="preprocessor"></span>
00737 D3DXVECTOR3* WINAPI D3DXVec3Normalize
00738     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV );
00739 
00740 <span class="comment">// Hermite interpolation between position V1, tangent T1 (when s == 0)</span>
00741 <span class="comment">// and position V2, tangent T2 (when s == 1).</span>
00742 D3DXVECTOR3* WINAPI D3DXVec3Hermite
00743     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pT1,
00744       CONST D3DXVECTOR3 *pV2, CONST D3DXVECTOR3 *pT2, FLOAT s );
00745 
00746 <span class="comment">// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)</span>
00747 D3DXVECTOR3* WINAPI D3DXVec3CatmullRom
00748     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV0, CONST D3DXVECTOR3 *pV1,
00749       CONST D3DXVECTOR3 *pV2, CONST D3DXVECTOR3 *pV3, FLOAT s );
00750 
00751 <span class="comment">// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)</span>
00752 D3DXVECTOR3* WINAPI D3DXVec3BaryCentric
00753     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
00754       CONST D3DXVECTOR3 *pV3, FLOAT f, FLOAT g);
00755 
00756 <span class="comment">// Transform (x, y, z, 1) by matrix.</span>
00757 D3DXVECTOR4* WINAPI D3DXVec3Transform
00758     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );
00759 
00760 <span class="comment">// Transform (x, y, z, 1) by matrix, project result back into w=1.</span>
00761 D3DXVECTOR3* WINAPI D3DXVec3TransformCoord
00762     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );
00763 
00764 <span class="comment">// Transform (x, y, z, 0) by matrix.  If you transforming a normal by a </span>
00765 <span class="comment">// non-affine matrix, the matrix you pass to this function should be the </span>
00766 <span class="comment">// transpose of the inverse of the matrix you would use to transform a coord.</span>
00767 D3DXVECTOR3* WINAPI D3DXVec3TransformNormal
00768     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );
00769     
00770     
00771 <span class="comment">// Transform Array (x, y, z, 1) by matrix. </span>
00772 D3DXVECTOR4* WINAPI D3DXVec3TransformArray
00773     ( D3DXVECTOR4 *pOut, UINT OutStride, CONST D3DXVECTOR3 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
00774 
00775 <span class="comment">// Transform Array (x, y, z, 1) by matrix, project result back into w=1.</span>
00776 D3DXVECTOR3* WINAPI D3DXVec3TransformCoordArray
00777     ( D3DXVECTOR3 *pOut, UINT OutStride, CONST D3DXVECTOR3 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
00778 
00779 <span class="comment">// Transform (x, y, z, 0) by matrix.  If you transforming a normal by a </span>
00780 <span class="comment">// non-affine matrix, the matrix you pass to this function should be the </span>
00781 <span class="comment">// transpose of the inverse of the matrix you would use to transform a coord.</span>
00782 D3DXVECTOR3* WINAPI D3DXVec3TransformNormalArray
00783     ( D3DXVECTOR3 *pOut, UINT OutStride, CONST D3DXVECTOR3 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
00784 
00785 <span class="comment">// Project vector from object space into screen space</span>
00786 D3DXVECTOR3* WINAPI D3DXVec3Project
00787     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DVIEWPORT9 *pViewport,
00788       CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld);
00789 
00790 <span class="comment">// Project vector from screen space into object space</span>
00791 D3DXVECTOR3* WINAPI D3DXVec3Unproject
00792     ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DVIEWPORT9 *pViewport,
00793       CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld);
00794       
00795 <span class="comment">// Project vector Array from object space into screen space</span>
00796 D3DXVECTOR3* WINAPI D3DXVec3ProjectArray
00797     ( D3DXVECTOR3 *pOut, UINT OutStride,CONST D3DXVECTOR3 *pV, UINT VStride,CONST D3DVIEWPORT9 *pViewport,
00798       CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld, UINT n);
00799 
00800 <span class="comment">// Project vector Array from screen space into object space</span>
00801 D3DXVECTOR3* WINAPI D3DXVec3UnprojectArray
00802     ( D3DXVECTOR3 *pOut, UINT OutStride, CONST D3DXVECTOR3 *pV, UINT VStride, CONST D3DVIEWPORT9 *pViewport,
00803       CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld, UINT n);
00804 
00805 
00806 <span class="preprocessor">#ifdef __cplusplus</span>
00807 <span class="preprocessor"></span>}
00808 <span class="preprocessor">#endif</span>
00809 <span class="preprocessor"></span>
00810 
00811 
00812 <span class="comment">//--------------------------</span>
00813 <span class="comment">// 4D Vector</span>
00814 <span class="comment">//--------------------------</span>
00815 
00816 <span class="comment">// inline</span>
00817 
00818 FLOAT D3DXVec4Length
00819     ( CONST D3DXVECTOR4 *pV );
00820 
00821 FLOAT D3DXVec4LengthSq
00822     ( CONST D3DXVECTOR4 *pV );
00823 
00824 FLOAT D3DXVec4Dot
00825     ( CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2 );
00826 
00827 D3DXVECTOR4* D3DXVec4Add
00828     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);
00829 
00830 D3DXVECTOR4* D3DXVec4Subtract
00831     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);
00832 
00833 <span class="comment">// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...</span>
00834 D3DXVECTOR4* D3DXVec4Minimize
00835     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);
00836 
00837 <span class="comment">// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...</span>
00838 D3DXVECTOR4* D3DXVec4Maximize
00839     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);
00840 
00841 D3DXVECTOR4* D3DXVec4Scale
00842     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, FLOAT s);
00843 
00844 <span class="comment">// Linear interpolation. V1 + s(V2-V1)</span>
00845 D3DXVECTOR4* D3DXVec4Lerp
00846     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
00847       FLOAT s );
00848 
00849 <span class="comment">// non-inline</span>
00850 <span class="preprocessor">#ifdef __cplusplus</span>
00851 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00852 <span class="preprocessor">#endif</span>
00853 <span class="preprocessor"></span>
00854 <span class="comment">// Cross-product in 4 dimensions.</span>
00855 D3DXVECTOR4* WINAPI D3DXVec4Cross
00856     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
00857       CONST D3DXVECTOR4 *pV3);
00858 
00859 D3DXVECTOR4* WINAPI D3DXVec4Normalize
00860     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV );
00861 
00862 <span class="comment">// Hermite interpolation between position V1, tangent T1 (when s == 0)</span>
00863 <span class="comment">// and position V2, tangent T2 (when s == 1).</span>
00864 D3DXVECTOR4* WINAPI D3DXVec4Hermite
00865     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pT1,
00866       CONST D3DXVECTOR4 *pV2, CONST D3DXVECTOR4 *pT2, FLOAT s );
00867 
00868 <span class="comment">// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)</span>
00869 D3DXVECTOR4* WINAPI D3DXVec4CatmullRom
00870     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV0, CONST D3DXVECTOR4 *pV1,
00871       CONST D3DXVECTOR4 *pV2, CONST D3DXVECTOR4 *pV3, FLOAT s );
00872 
00873 <span class="comment">// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)</span>
00874 D3DXVECTOR4* WINAPI D3DXVec4BaryCentric
00875     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
00876       CONST D3DXVECTOR4 *pV3, FLOAT f, FLOAT g);
00877 
00878 <span class="comment">// Transform vector by matrix.</span>
00879 D3DXVECTOR4* WINAPI D3DXVec4Transform
00880     ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, CONST D3DXMATRIX *pM );
00881     
00882 <span class="comment">// Transform vector array by matrix.</span>
00883 D3DXVECTOR4* WINAPI D3DXVec4TransformArray
00884     ( D3DXVECTOR4 *pOut, UINT OutStride, CONST D3DXVECTOR4 *pV, UINT VStride, CONST D3DXMATRIX *pM, UINT n );
00885 
00886 <span class="preprocessor">#ifdef __cplusplus</span>
00887 <span class="preprocessor"></span>}
00888 <span class="preprocessor">#endif</span>
00889 <span class="preprocessor"></span>
00890 
00891 <span class="comment">//--------------------------</span>
00892 <span class="comment">// 4D Matrix</span>
00893 <span class="comment">//--------------------------</span>
00894 
00895 <span class="comment">// inline</span>
00896 
00897 D3DXMATRIX* D3DXMatrixIdentity
00898     ( D3DXMATRIX *pOut );
00899 
00900 BOOL D3DXMatrixIsIdentity
00901     ( CONST D3DXMATRIX *pM );
00902 
00903 
00904 <span class="comment">// non-inline</span>
00905 <span class="preprocessor">#ifdef __cplusplus</span>
00906 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00907 <span class="preprocessor">#endif</span>
00908 <span class="preprocessor"></span>
00909 FLOAT WINAPI D3DXMatrixDeterminant
00910     ( CONST D3DXMATRIX *pM );
00911 
00912 HRESULT WINAPI D3DXMatrixDecompose
00913     ( D3DXVECTOR3 *pOutScale, D3DXQUATERNION *pOutRotation, 
00914       D3DXVECTOR3 *pOutTranslation, CONST D3DXMATRIX *pM );
00915 
00916 D3DXMATRIX* WINAPI D3DXMatrixTranspose
00917     ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM );
00918 
00919 <span class="comment">// Matrix multiplication.  The result represents the transformation M2</span>
00920 <span class="comment">// followed by the transformation M1.  (Out = M1 * M2)</span>
00921 D3DXMATRIX* WINAPI D3DXMatrixMultiply
00922     ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM1, CONST D3DXMATRIX *pM2 );
00923 
00924 <span class="comment">// Matrix multiplication, followed by a transpose. (Out = T(M1 * M2))</span>
00925 D3DXMATRIX* WINAPI D3DXMatrixMultiplyTranspose
00926     ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM1, CONST D3DXMATRIX *pM2 );
00927 
00928 <span class="comment">// Calculate inverse of matrix.  Inversion my fail, in which case NULL will</span>
00929 <span class="comment">// be returned.  The determinant of pM is also returned it pfDeterminant</span>
00930 <span class="comment">// is non-NULL.</span>
00931 D3DXMATRIX* WINAPI D3DXMatrixInverse
00932     ( D3DXMATRIX *pOut, FLOAT *pDeterminant, CONST D3DXMATRIX *pM );
00933 
00934 <span class="comment">// Build a matrix which scales by (sx, sy, sz)</span>
00935 D3DXMATRIX* WINAPI D3DXMatrixScaling
00936     ( D3DXMATRIX *pOut, FLOAT sx, FLOAT sy, FLOAT sz );
00937 
00938 <span class="comment">// Build a matrix which translates by (x, y, z)</span>
00939 D3DXMATRIX* WINAPI D3DXMatrixTranslation
00940     ( D3DXMATRIX *pOut, FLOAT x, FLOAT y, FLOAT z );
00941 
00942 <span class="comment">// Build a matrix which rotates around the X axis</span>
00943 D3DXMATRIX* WINAPI D3DXMatrixRotationX
00944     ( D3DXMATRIX *pOut, FLOAT Angle );
00945 
00946 <span class="comment">// Build a matrix which rotates around the Y axis</span>
00947 D3DXMATRIX* WINAPI D3DXMatrixRotationY
00948     ( D3DXMATRIX *pOut, FLOAT Angle );
00949 
00950 <span class="comment">// Build a matrix which rotates around the Z axis</span>
00951 D3DXMATRIX* WINAPI D3DXMatrixRotationZ
00952     ( D3DXMATRIX *pOut, FLOAT Angle );
00953 
00954 <span class="comment">// Build a matrix which rotates around an arbitrary axis</span>
00955 D3DXMATRIX* WINAPI D3DXMatrixRotationAxis
00956     ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pV, FLOAT Angle );
00957 
00958 <span class="comment">// Build a matrix from a quaternion</span>
00959 D3DXMATRIX* WINAPI D3DXMatrixRotationQuaternion
00960     ( D3DXMATRIX *pOut, CONST D3DXQUATERNION *pQ);
00961 
00962 <span class="comment">// Yaw around the Y axis, a pitch around the X axis,</span>
00963 <span class="comment">// and a roll around the Z axis.</span>
00964 D3DXMATRIX* WINAPI D3DXMatrixRotationYawPitchRoll
00965     ( D3DXMATRIX *pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll );
00966 
00967 <span class="comment">// Build transformation matrix.  NULL arguments are treated as identity.</span>
00968 <span class="comment">// Mout = Msc-1 * Msr-1 * Ms * Msr * Msc * Mrc-1 * Mr * Mrc * Mt</span>
00969 D3DXMATRIX* WINAPI D3DXMatrixTransformation
00970     ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pScalingCenter,
00971       CONST D3DXQUATERNION *pScalingRotation, CONST D3DXVECTOR3 *pScaling,
00972       CONST D3DXVECTOR3 *pRotationCenter, CONST D3DXQUATERNION *pRotation,
00973       CONST D3DXVECTOR3 *pTranslation);
00974 
00975 <span class="comment">// Build 2D transformation matrix in XY plane.  NULL arguments are treated as identity.</span>
00976 <span class="comment">// Mout = Msc-1 * Msr-1 * Ms * Msr * Msc * Mrc-1 * Mr * Mrc * Mt</span>
00977 D3DXMATRIX* WINAPI D3DXMatrixTransformation2D
00978     ( D3DXMATRIX *pOut, CONST D3DXVECTOR2* pScalingCenter, 
00979       FLOAT ScalingRotation, CONST D3DXVECTOR2* pScaling, 
00980       CONST D3DXVECTOR2* pRotationCenter, FLOAT Rotation, 
00981       CONST D3DXVECTOR2* pTranslation);
00982 
00983 <span class="comment">// Build affine transformation matrix.  NULL arguments are treated as identity.</span>
00984 <span class="comment">// Mout = Ms * Mrc-1 * Mr * Mrc * Mt</span>
00985 D3DXMATRIX* WINAPI D3DXMatrixAffineTransformation
00986     ( D3DXMATRIX *pOut, FLOAT Scaling, CONST D3DXVECTOR3 *pRotationCenter,
00987       CONST D3DXQUATERNION *pRotation, CONST D3DXVECTOR3 *pTranslation);
00988 
00989 <span class="comment">// Build 2D affine transformation matrix in XY plane.  NULL arguments are treated as identity.</span>
00990 <span class="comment">// Mout = Ms * Mrc-1 * Mr * Mrc * Mt</span>
00991 D3DXMATRIX* WINAPI D3DXMatrixAffineTransformation2D
00992     ( D3DXMATRIX *pOut, FLOAT Scaling, CONST D3DXVECTOR2* pRotationCenter, 
00993       FLOAT Rotation, CONST D3DXVECTOR2* pTranslation);
00994 
00995 <span class="comment">// Build a lookat matrix. (right-handed)</span>
00996 D3DXMATRIX* WINAPI D3DXMatrixLookAtRH
00997     ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pEye, CONST D3DXVECTOR3 *pAt,
00998       CONST D3DXVECTOR3 *pUp );
00999 
01000 <span class="comment">// Build a lookat matrix. (left-handed)</span>
01001 D3DXMATRIX* WINAPI D3DXMatrixLookAtLH
01002     ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pEye, CONST D3DXVECTOR3 *pAt,
01003       CONST D3DXVECTOR3 *pUp );
01004 
01005 <span class="comment">// Build a perspective projection matrix. (right-handed)</span>
01006 D3DXMATRIX* WINAPI D3DXMatrixPerspectiveRH
01007     ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );
01008 
01009 <span class="comment">// Build a perspective projection matrix. (left-handed)</span>
01010 D3DXMATRIX* WINAPI D3DXMatrixPerspectiveLH
01011     ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );
01012 
01013 <span class="comment">// Build a perspective projection matrix. (right-handed)</span>
01014 D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovRH
01015     ( D3DXMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf );
01016 
01017 <span class="comment">// Build a perspective projection matrix. (left-handed)</span>
01018 D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovLH
01019     ( D3DXMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf );
01020 
01021 <span class="comment">// Build a perspective projection matrix. (right-handed)</span>
01022 D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterRH
01023     ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
01024       FLOAT zf );
01025 
01026 <span class="comment">// Build a perspective projection matrix. (left-handed)</span>
01027 D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterLH
01028     ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
01029       FLOAT zf );
01030 
01031 <span class="comment">// Build an ortho projection matrix. (right-handed)</span>
01032 D3DXMATRIX* WINAPI D3DXMatrixOrthoRH
01033     ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );
01034 
01035 <span class="comment">// Build an ortho projection matrix. (left-handed)</span>
01036 D3DXMATRIX* WINAPI D3DXMatrixOrthoLH
01037     ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );
01038 
01039 <span class="comment">// Build an ortho projection matrix. (right-handed)</span>
01040 D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterRH
01041     ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
01042       FLOAT zf );
01043 
01044 <span class="comment">// Build an ortho projection matrix. (left-handed)</span>
01045 D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterLH
01046     ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
01047       FLOAT zf );
01048 
01049 <span class="comment">// Build a matrix which flattens geometry into a plane, as if casting</span>
01050 <span class="comment">// a shadow from a light.</span>
01051 D3DXMATRIX* WINAPI D3DXMatrixShadow
01052     ( D3DXMATRIX *pOut, CONST D3DXVECTOR4 *pLight,
01053       CONST D3DXPLANE *pPlane );
01054 
01055 <span class="comment">// Build a matrix which reflects the coordinate system about a plane</span>
01056 D3DXMATRIX* WINAPI D3DXMatrixReflect
01057     ( D3DXMATRIX *pOut, CONST D3DXPLANE *pPlane );
01058 
01059 <span class="preprocessor">#ifdef __cplusplus</span>
01060 <span class="preprocessor"></span>}
01061 <span class="preprocessor">#endif</span>
01062 <span class="preprocessor"></span>
01063 
01064 <span class="comment">//--------------------------</span>
01065 <span class="comment">// Quaternion</span>
01066 <span class="comment">//--------------------------</span>
01067 
01068 <span class="comment">// inline</span>
01069 
01070 FLOAT D3DXQuaternionLength
01071     ( CONST D3DXQUATERNION *pQ );
01072 
01073 <span class="comment">// Length squared, or "norm"</span>
01074 FLOAT D3DXQuaternionLengthSq
01075     ( CONST D3DXQUATERNION *pQ );
01076 
01077 FLOAT D3DXQuaternionDot
01078     ( CONST D3DXQUATERNION *pQ1, CONST D3DXQUATERNION *pQ2 );
01079 
01080 <span class="comment">// (0, 0, 0, 1)</span>
01081 D3DXQUATERNION* D3DXQuaternionIdentity
01082     ( D3DXQUATERNION *pOut );
01083 
01084 BOOL D3DXQuaternionIsIdentity
01085     ( CONST D3DXQUATERNION *pQ );
01086 
01087 <span class="comment">// (-x, -y, -z, w)</span>
01088 D3DXQUATERNION* D3DXQuaternionConjugate
01089     ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );
01090 
01091 
01092 <span class="comment">// non-inline</span>
01093 <span class="preprocessor">#ifdef __cplusplus</span>
01094 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
01095 <span class="preprocessor">#endif</span>
01096 <span class="preprocessor"></span>
01097 <span class="comment">// Compute a quaternin's axis and angle of rotation. Expects unit quaternions.</span>
01098 <span class="keywordtype">void</span> WINAPI D3DXQuaternionToAxisAngle
01099     ( CONST D3DXQUATERNION *pQ, D3DXVECTOR3 *pAxis, FLOAT *pAngle );
01100 
01101 <span class="comment">// Build a quaternion from a rotation matrix.</span>
01102 D3DXQUATERNION* WINAPI D3DXQuaternionRotationMatrix
01103     ( D3DXQUATERNION *pOut, CONST D3DXMATRIX *pM);
01104 
01105 <span class="comment">// Rotation about arbitrary axis.</span>
01106 D3DXQUATERNION* WINAPI D3DXQuaternionRotationAxis
01107     ( D3DXQUATERNION *pOut, CONST D3DXVECTOR3 *pV, FLOAT Angle );
01108 
01109 <span class="comment">// Yaw around the Y axis, a pitch around the X axis,</span>
01110 <span class="comment">// and a roll around the Z axis.</span>
01111 D3DXQUATERNION* WINAPI D3DXQuaternionRotationYawPitchRoll
01112     ( D3DXQUATERNION *pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll );
01113 
01114 <span class="comment">// Quaternion multiplication.  The result represents the rotation Q2</span>
01115 <span class="comment">// followed by the rotation Q1.  (Out = Q2 * Q1)</span>
01116 D3DXQUATERNION* WINAPI D3DXQuaternionMultiply
01117     ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
01118       CONST D3DXQUATERNION *pQ2 );
01119 
01120 D3DXQUATERNION* WINAPI D3DXQuaternionNormalize
01121     ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );
01122 
01123 <span class="comment">// Conjugate and re-norm</span>
01124 D3DXQUATERNION* WINAPI D3DXQuaternionInverse
01125     ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );
01126 
01127 <span class="comment">// Expects unit quaternions.</span>
01128 <span class="comment">// if q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)</span>
01129 D3DXQUATERNION* WINAPI D3DXQuaternionLn
01130     ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );
01131 
01132 <span class="comment">// Expects pure quaternions. (w == 0)  w is ignored in calculation.</span>
01133 <span class="comment">// if q = (0, theta * v); exp(q) = (cos(theta), sin(theta) * v)</span>
01134 D3DXQUATERNION* WINAPI D3DXQuaternionExp
01135     ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );
01136       
01137 <span class="comment">// Spherical linear interpolation between Q1 (t == 0) and Q2 (t == 1).</span>
01138 <span class="comment">// Expects unit quaternions.</span>
01139 D3DXQUATERNION* WINAPI D3DXQuaternionSlerp
01140     ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
01141       CONST D3DXQUATERNION *pQ2, FLOAT t );
01142 
01143 <span class="comment">// Spherical quadrangle interpolation.</span>
01144 <span class="comment">// Slerp(Slerp(Q1, C, t), Slerp(A, B, t), 2t(1-t))</span>
01145 D3DXQUATERNION* WINAPI D3DXQuaternionSquad
01146     ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
01147       CONST D3DXQUATERNION *pA, CONST D3DXQUATERNION *pB,
01148       CONST D3DXQUATERNION *pC, FLOAT t );
01149 
01150 <span class="comment">// Setup control points for spherical quadrangle interpolation</span>
01151 <span class="comment">// from Q1 to Q2.  The control points are chosen in such a way </span>
01152 <span class="comment">// to ensure the continuity of tangents with adjacent segments.</span>
01153 <span class="keywordtype">void</span> WINAPI D3DXQuaternionSquadSetup
01154     ( D3DXQUATERNION *pAOut, D3DXQUATERNION *pBOut, D3DXQUATERNION *pCOut,
01155       CONST D3DXQUATERNION *pQ0, CONST D3DXQUATERNION *pQ1, 
01156       CONST D3DXQUATERNION *pQ2, CONST D3DXQUATERNION *pQ3 );
01157 
01158 <span class="comment">// Barycentric interpolation.</span>
01159 <span class="comment">// Slerp(Slerp(Q1, Q2, f+g), Slerp(Q1, Q3, f+g), g/(f+g))</span>
01160 D3DXQUATERNION* WINAPI D3DXQuaternionBaryCentric
01161     ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
01162       CONST D3DXQUATERNION *pQ2, CONST D3DXQUATERNION *pQ3,
01163       FLOAT f, FLOAT g );
01164 
01165 <span class="preprocessor">#ifdef __cplusplus</span>
01166 <span class="preprocessor"></span>}
01167 <span class="preprocessor">#endif</span>
01168 <span class="preprocessor"></span>
01169 
01170 <span class="comment">//--------------------------</span>
01171 <span class="comment">// Plane</span>
01172 <span class="comment">//--------------------------</span>
01173 
01174 <span class="comment">// inline</span>
01175 
01176 <span class="comment">// ax + by + cz + dw</span>
01177 FLOAT D3DXPlaneDot
01178     ( CONST D3DXPLANE *pP, CONST D3DXVECTOR4 *pV);
01179 
01180 <span class="comment">// ax + by + cz + d</span>
01181 FLOAT D3DXPlaneDotCoord
01182     ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV);
01183 
01184 <span class="comment">// ax + by + cz</span>
01185 FLOAT D3DXPlaneDotNormal
01186     ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV);
01187 
01188 D3DXPLANE* D3DXPlaneScale
01189     (D3DXPLANE *pOut, CONST D3DXPLANE *pP, FLOAT s);
01190 
01191 <span class="comment">// non-inline</span>
01192 <span class="preprocessor">#ifdef __cplusplus</span>
01193 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
01194 <span class="preprocessor">#endif</span>
01195 <span class="preprocessor"></span>
01196 <span class="comment">// Normalize plane (so that |a,b,c| == 1)</span>
01197 D3DXPLANE* WINAPI D3DXPlaneNormalize
01198     ( D3DXPLANE *pOut, CONST D3DXPLANE *pP);
01199 
01200 <span class="comment">// Find the intersection between a plane and a line.  If the line is</span>
01201 <span class="comment">// parallel to the plane, NULL is returned.</span>
01202 D3DXVECTOR3* WINAPI D3DXPlaneIntersectLine
01203     ( D3DXVECTOR3 *pOut, CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV1,
01204       CONST D3DXVECTOR3 *pV2);
01205 
01206 <span class="comment">// Construct a plane from a point and a normal</span>
01207 D3DXPLANE* WINAPI D3DXPlaneFromPointNormal
01208     ( D3DXPLANE *pOut, CONST D3DXVECTOR3 *pPoint, CONST D3DXVECTOR3 *pNormal);
01209 
01210 <span class="comment">// Construct a plane from 3 points</span>
01211 D3DXPLANE* WINAPI D3DXPlaneFromPoints
01212     ( D3DXPLANE *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
01213       CONST D3DXVECTOR3 *pV3);
01214 
01215 <span class="comment">// Transform a plane by a matrix.  The vector (a,b,c) must be normal.</span>
01216 <span class="comment">// M should be the inverse transpose of the transformation desired.</span>
01217 D3DXPLANE* WINAPI D3DXPlaneTransform
01218     ( D3DXPLANE *pOut, CONST D3DXPLANE *pP, CONST D3DXMATRIX *pM );
01219     
01220 <span class="comment">// Transform an array of planes by a matrix.  The vectors (a,b,c) must be normal.</span>
01221 <span class="comment">// M should be the inverse transpose of the transformation desired.</span>
01222 D3DXPLANE* WINAPI D3DXPlaneTransformArray
01223     ( D3DXPLANE *pOut, UINT OutStride, CONST D3DXPLANE *pP, UINT PStride, CONST D3DXMATRIX *pM, UINT n );
01224 
01225 <span class="preprocessor">#ifdef __cplusplus</span>
01226 <span class="preprocessor"></span>}
01227 <span class="preprocessor">#endif</span>
01228 <span class="preprocessor"></span>
01229 
01230 <span class="comment">//--------------------------</span>
01231 <span class="comment">// Color</span>
01232 <span class="comment">//--------------------------</span>
01233 
01234 <span class="comment">// inline</span>
01235 
01236 <span class="comment">// (1-r, 1-g, 1-b, a)</span>
01237 D3DXCOLOR* D3DXColorNegative
01238     (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC);
01239 
01240 D3DXCOLOR* D3DXColorAdd
01241     (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);
01242 
01243 D3DXCOLOR* D3DXColorSubtract
01244     (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);
01245 
01246 D3DXCOLOR* D3DXColorScale
01247     (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s);
01248 
01249 <span class="comment">// (r1*r2, g1*g2, b1*b2, a1*a2)</span>
01250 D3DXCOLOR* D3DXColorModulate
01251     (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);
01252 
01253 <span class="comment">// Linear interpolation of r,g,b, and a. C1 + s(C2-C1)</span>
01254 D3DXCOLOR* D3DXColorLerp
01255     (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2, FLOAT s);
01256 
01257 <span class="comment">// non-inline</span>
01258 <span class="preprocessor">#ifdef __cplusplus</span>
01259 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
01260 <span class="preprocessor">#endif</span>
01261 <span class="preprocessor"></span>
01262 <span class="comment">// Interpolate r,g,b between desaturated color and color.</span>
01263 <span class="comment">// DesaturatedColor + s(Color - DesaturatedColor)</span>
01264 D3DXCOLOR* WINAPI D3DXColorAdjustSaturation
01265     (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s);
01266 
01267 <span class="comment">// Interpolate r,g,b between 50% grey and color.  Grey + s(Color - Grey)</span>
01268 D3DXCOLOR* WINAPI D3DXColorAdjustContrast
01269     (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT c);
01270 
01271 <span class="preprocessor">#ifdef __cplusplus</span>
01272 <span class="preprocessor"></span>}
01273 <span class="preprocessor">#endif</span>
01274 <span class="preprocessor"></span>
01275 
01276 
01277 
01278 <span class="comment">//--------------------------</span>
01279 <span class="comment">// Misc</span>
01280 <span class="comment">//--------------------------</span>
01281 
01282 <span class="preprocessor">#ifdef __cplusplus</span>
01283 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
01284 <span class="preprocessor">#endif</span>
01285 <span class="preprocessor"></span>
01286 <span class="comment">// Calculate Fresnel term given the cosine of theta (likely obtained by</span>
01287 <span class="comment">// taking the dot of two normals), and the refraction index of the material.</span>
01288 FLOAT WINAPI D3DXFresnelTerm
01289     (FLOAT CosTheta, FLOAT RefractionIndex);     
01290 
01291 <span class="preprocessor">#ifdef __cplusplus</span>
01292 <span class="preprocessor"></span>}
01293 <span class="preprocessor">#endif</span>
01294 <span class="preprocessor"></span>
01295 
01296 
01297 <span class="comment">//===========================================================================</span>
01298 <span class="comment">//</span>
01299 <span class="comment">//    Matrix Stack</span>
01300 <span class="comment">//</span>
01301 <span class="comment">//===========================================================================</span>
01302 
01303 <span class="keyword">typedef</span> interface ID3DXMatrixStack ID3DXMatrixStack;
01304 <span class="keyword">typedef</span> interface ID3DXMatrixStack *LPD3DXMATRIXSTACK;
01305 
01306 <span class="comment">// {C7885BA7-F990-4fe7-922D-8515E477DD85}</span>
01307 DEFINE_GUID(IID_ID3DXMatrixStack, 
01308 0xc7885ba7, 0xf990, 0x4fe7, 0x92, 0x2d, 0x85, 0x15, 0xe4, 0x77, 0xdd, 0x85);
01309 
01310 
01311 <span class="preprocessor">#undef INTERFACE</span>
01312 <span class="preprocessor"></span><span class="preprocessor">#define INTERFACE ID3DXMatrixStack</span>
01313 <span class="preprocessor"></span>
01314 DECLARE_INTERFACE_(ID3DXMatrixStack, IUnknown)
01315 {
01316     <span class="comment">//</span>
01317     <span class="comment">// IUnknown methods</span>
01318     <span class="comment">//</span>
01319     STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
01320     STDMETHOD_(ULONG,AddRef)(THIS) PURE;
01321     STDMETHOD_(ULONG,Release)(THIS) PURE;
01322 
01323     <span class="comment">//</span>
01324     <span class="comment">// ID3DXMatrixStack methods</span>
01325     <span class="comment">//</span>
01326 
01327     <span class="comment">// Pops the top of the stack, returns the current top</span>
01328     <span class="comment">// *after* popping the top.</span>
01329     STDMETHOD(Pop)(THIS) PURE;
01330 
01331     <span class="comment">// Pushes the stack by one, duplicating the current matrix.</span>
01332     STDMETHOD(Push)(THIS) PURE;
01333 
01334     <span class="comment">// Loads identity in the current matrix.</span>
01335     STDMETHOD(LoadIdentity)(THIS) PURE;
01336 
01337     <span class="comment">// Loads the given matrix into the current matrix</span>
01338     STDMETHOD(LoadMatrix)(THIS_ CONST D3DXMATRIX* pM ) PURE;
01339 
01340     <span class="comment">// Right-Multiplies the given matrix to the current matrix.</span>
01341     <span class="comment">// (transformation is about the current world origin)</span>
01342     STDMETHOD(MultMatrix)(THIS_ CONST D3DXMATRIX* pM ) PURE;
01343 
01344     <span class="comment">// Left-Multiplies the given matrix to the current matrix</span>
01345     <span class="comment">// (transformation is about the local origin of the object)</span>
01346     STDMETHOD(MultMatrixLocal)(THIS_ CONST D3DXMATRIX* pM ) PURE;
01347 
01348     <span class="comment">// Right multiply the current matrix with the computed rotation</span>
01349     <span class="comment">// matrix, counterclockwise about the given axis with the given angle.</span>
01350     <span class="comment">// (rotation is about the current world origin)</span>
01351     STDMETHOD(RotateAxis)
01352         (THIS_ CONST D3DXVECTOR3* pV, FLOAT Angle) PURE;
01353 
01354     <span class="comment">// Left multiply the current matrix with the computed rotation</span>
01355     <span class="comment">// matrix, counterclockwise about the given axis with the given angle.</span>
01356     <span class="comment">// (rotation is about the local origin of the object)</span>
01357     STDMETHOD(RotateAxisLocal)
01358         (THIS_ CONST D3DXVECTOR3* pV, FLOAT Angle) PURE;
01359 
01360     <span class="comment">// Right multiply the current matrix with the computed rotation</span>
01361     <span class="comment">// matrix. All angles are counterclockwise. (rotation is about the</span>
01362     <span class="comment">// current world origin)</span>
01363 
01364     <span class="comment">// The rotation is composed of a yaw around the Y axis, a pitch around</span>
01365     <span class="comment">// the X axis, and a roll around the Z axis.</span>
01366     STDMETHOD(RotateYawPitchRoll)
01367         (THIS_ FLOAT Yaw, FLOAT Pitch, FLOAT Roll) PURE;
01368 
01369     <span class="comment">// Left multiply the current matrix with the computed rotation</span>
01370     <span class="comment">// matrix. All angles are counterclockwise. (rotation is about the</span>
01371     <span class="comment">// local origin of the object)</span>
01372 
01373     <span class="comment">// The rotation is composed of a yaw around the Y axis, a pitch around</span>
01374     <span class="comment">// the X axis, and a roll around the Z axis.</span>
01375     STDMETHOD(RotateYawPitchRollLocal)
01376         (THIS_ FLOAT Yaw, FLOAT Pitch, FLOAT Roll) PURE;
01377 
01378     <span class="comment">// Right multiply the current matrix with the computed scale</span>
01379     <span class="comment">// matrix. (transformation is about the current world origin)</span>
01380     STDMETHOD(Scale)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;
01381 
01382     <span class="comment">// Left multiply the current matrix with the computed scale</span>
01383     <span class="comment">// matrix. (transformation is about the local origin of the object)</span>
01384     STDMETHOD(ScaleLocal)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;
01385 
01386     <span class="comment">// Right multiply the current matrix with the computed translation</span>
01387     <span class="comment">// matrix. (transformation is about the current world origin)</span>
01388     STDMETHOD(Translate)(THIS_ FLOAT x, FLOAT y, FLOAT z ) PURE;
01389 
01390     <span class="comment">// Left multiply the current matrix with the computed translation</span>
01391     <span class="comment">// matrix. (transformation is about the local origin of the object)</span>
01392     STDMETHOD(TranslateLocal)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;
01393 
01394     <span class="comment">// Obtain the current matrix at the top of the stack</span>
01395     STDMETHOD_(D3DXMATRIX*, GetTop)(THIS) PURE;
01396 };
01397 
01398 <span class="preprocessor">#ifdef __cplusplus</span>
01399 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
01400 <span class="preprocessor">#endif</span>
01401 <span class="preprocessor"></span>
01402 HRESULT WINAPI 
01403     D3DXCreateMatrixStack( 
01404         DWORD               Flags, 
01405         LPD3DXMATRIXSTACK*  ppStack);
01406 
01407 <span class="preprocessor">#ifdef __cplusplus</span>
01408 <span class="preprocessor"></span>}
01409 <span class="preprocessor">#endif</span>
01410 <span class="preprocessor"></span>
01411 <span class="comment">//===========================================================================</span>
01412 <span class="comment">//</span>
01413 <span class="comment">//  Spherical Harmonic Runtime Routines</span>
01414 <span class="comment">//</span>
01415 <span class="comment">// NOTE:</span>
01416 <span class="comment">//  * Most of these functions can take the same object as in and out parameters.</span>
01417 <span class="comment">//    The exceptions are the rotation functions.  </span>
01418 <span class="comment">//</span>
01419 <span class="comment">//  * Out parameters are typically also returned as return values, so that</span>
01420 <span class="comment">//    the output of one function may be used as a parameter to another.</span>
01421 <span class="comment">//</span>
01422 <span class="comment">//============================================================================</span>
01423 
01424 
01425 <span class="comment">// non-inline</span>
01426 <span class="preprocessor">#ifdef __cplusplus</span>
01427 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
01428 <span class="preprocessor">#endif</span>
01429 <span class="preprocessor"></span>
01430 <span class="comment">//============================================================================</span>
01431 <span class="comment">//</span>
01432 <span class="comment">//  Basic Spherical Harmonic math routines</span>
01433 <span class="comment">//</span>
01434 <span class="comment">//============================================================================</span>
01435 
01436 <span class="preprocessor">#define D3DXSH_MINORDER 2</span>
01437 <span class="preprocessor"></span><span class="preprocessor">#define D3DXSH_MAXORDER 6</span>
01438 <span class="preprocessor"></span>
01439 <span class="comment">//============================================================================</span>
01440 <span class="comment">//</span>
01441 <span class="comment">//  D3DXSHEvalDirection:</span>
01442 <span class="comment">//  --------------------</span>
01443 <span class="comment">//  Evaluates the Spherical Harmonic basis functions</span>
01444 <span class="comment">//</span>
01445 <span class="comment">//  Parameters:</span>
01446 <span class="comment">//   pOut</span>
01447 <span class="comment">//      Output SH coefficients - basis function Ylm is stored at l*l + m+l</span>
01448 <span class="comment">//      This is the pointer that is returned.</span>
01449 <span class="comment">//   Order</span>
01450 <span class="comment">//      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1</span>
01451 <span class="comment">//   pDir</span>
01452 <span class="comment">//      Direction to evaluate in - assumed to be normalized</span>
01453 <span class="comment">//</span>
01454 <span class="comment">//============================================================================</span>
01455 
01456 FLOAT* WINAPI D3DXSHEvalDirection
01457     (  FLOAT *pOut, UINT Order, CONST D3DXVECTOR3 *pDir );
01458     
01459 <span class="comment">//============================================================================</span>
01460 <span class="comment">//</span>
01461 <span class="comment">//  D3DXSHRotate:</span>
01462 <span class="comment">//  --------------------</span>
01463 <span class="comment">//  Rotates SH vector by a rotation matrix</span>
01464 <span class="comment">//</span>
01465 <span class="comment">//  Parameters:</span>
01466 <span class="comment">//   pOut</span>
01467 <span class="comment">//      Output SH coefficients - basis function Ylm is stored at l*l + m+l</span>
01468 <span class="comment">//      This is the pointer that is returned (should not alias with pIn.)</span>
01469 <span class="comment">//   Order</span>
01470 <span class="comment">//      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1</span>
01471 <span class="comment">//   pMatrix</span>
01472 <span class="comment">//      Matrix used for rotation - rotation sub matrix should be orthogonal</span>
01473 <span class="comment">//      and have a unit determinant.</span>
01474 <span class="comment">//   pIn</span>
01475 <span class="comment">//      Input SH coeffs (rotated), incorect results if this is also output.</span>
01476 <span class="comment">//</span>
01477 <span class="comment">//============================================================================</span>
01478 
01479 FLOAT* WINAPI D3DXSHRotate
01480     ( FLOAT *pOut, UINT Order, CONST D3DXMATRIX *pMatrix, CONST FLOAT *pIn );
01481     
01482 <span class="comment">//============================================================================</span>
01483 <span class="comment">//</span>
01484 <span class="comment">//  D3DXSHRotateZ:</span>
01485 <span class="comment">//  --------------------</span>
01486 <span class="comment">//  Rotates the SH vector in the Z axis by an angle</span>
01487 <span class="comment">//</span>
01488 <span class="comment">//  Parameters:</span>
01489 <span class="comment">//   pOut</span>
01490 <span class="comment">//      Output SH coefficients - basis function Ylm is stored at l*l + m+l</span>
01491 <span class="comment">//      This is the pointer that is returned (should not alias with pIn.)</span>
01492 <span class="comment">//   Order</span>
01493 <span class="comment">//      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1</span>
01494 <span class="comment">//   Angle</span>
01495 <span class="comment">//      Angle in radians to rotate around the Z axis.</span>
01496 <span class="comment">//   pIn</span>
01497 <span class="comment">//      Input SH coeffs (rotated), incorect results if this is also output.</span>
01498 <span class="comment">//</span>
01499 <span class="comment">//============================================================================</span>
01500 
01501 
01502 FLOAT* WINAPI D3DXSHRotateZ
01503     ( FLOAT *pOut, UINT Order, FLOAT Angle, CONST FLOAT *pIn );
01504     
01505 <span class="comment">//============================================================================</span>
01506 <span class="comment">//</span>
01507 <span class="comment">//  D3DXSHAdd:</span>
01508 <span class="comment">//  --------------------</span>
01509 <span class="comment">//  Adds two SH vectors, pOut[i] = pA[i] + pB[i];</span>
01510 <span class="comment">//</span>
01511 <span class="comment">//  Parameters:</span>
01512 <span class="comment">//   pOut</span>
01513 <span class="comment">//      Output SH coefficients - basis function Ylm is stored at l*l + m+l</span>
01514 <span class="comment">//      This is the pointer that is returned.</span>
01515 <span class="comment">//   Order</span>
01516 <span class="comment">//      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1</span>
01517 <span class="comment">//   pA</span>
01518 <span class="comment">//      Input SH coeffs.</span>
01519 <span class="comment">//   pB</span>
01520 <span class="comment">//      Input SH coeffs (second vector.)</span>
01521 <span class="comment">//</span>
01522 <span class="comment">//============================================================================</span>
01523 
01524 FLOAT* WINAPI D3DXSHAdd
01525     ( FLOAT *pOut, UINT Order, CONST FLOAT *pA, CONST FLOAT *pB );
01526 
01527 <span class="comment">//============================================================================</span>
01528 <span class="comment">//</span>
01529 <span class="comment">//  D3DXSHScale:</span>
01530 <span class="comment">//  --------------------</span>
01531 <span class="comment">//  Adds two SH vectors, pOut[i] = pA[i]*Scale;</span>
01532 <span class="comment">//</span>
01533 <span class="comment">//  Parameters:</span>
01534 <span class="comment">//   pOut</span>
01535 <span class="comment">//      Output SH coefficients - basis function Ylm is stored at l*l + m+l</span>
01536 <span class="comment">//      This is the pointer that is returned.</span>
01537 <span class="comment">//   Order</span>
01538 <span class="comment">//      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1</span>
01539 <span class="comment">//   pIn</span>
01540 <span class="comment">//      Input SH coeffs.</span>
01541 <span class="comment">//   Scale</span>
01542 <span class="comment">//      Scale factor.</span>
01543 <span class="comment">//</span>
01544 <span class="comment">//============================================================================</span>
01545 
01546 FLOAT* WINAPI D3DXSHScale
01547     ( FLOAT *pOut, UINT Order, CONST FLOAT *pIn, CONST FLOAT Scale );
01548     
01549 <span class="comment">//============================================================================</span>
01550 <span class="comment">//</span>
01551 <span class="comment">//  D3DXSHDot:</span>
01552 <span class="comment">//  --------------------</span>
01553 <span class="comment">//  Computes the dot product of two SH vectors</span>
01554 <span class="comment">//</span>
01555 <span class="comment">//  Parameters:</span>
01556 <span class="comment">//   Order</span>
01557 <span class="comment">//      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1</span>
01558 <span class="comment">//   pA</span>
01559 <span class="comment">//      Input SH coeffs.</span>
01560 <span class="comment">//   pB</span>
01561 <span class="comment">//      Second set of input SH coeffs.</span>
01562 <span class="comment">//</span>
01563 <span class="comment">//============================================================================</span>
01564 
01565 FLOAT WINAPI D3DXSHDot
01566     ( UINT Order, CONST FLOAT *pA, CONST FLOAT *pB );
01567 
01568 <span class="comment">//============================================================================</span>
01569 <span class="comment">//</span>
01570 <span class="comment">//  Basic Spherical Harmonic lighting routines</span>
01571 <span class="comment">//</span>
01572 <span class="comment">//============================================================================</span>
01573 
01574 <span class="comment">//============================================================================</span>
01575 <span class="comment">//</span>
01576 <span class="comment">//  D3DXSHEvalDirectionalLight:</span>
01577 <span class="comment">//  --------------------</span>
01578 <span class="comment">//  Evaluates a directional light and returns spectral SH data.  The output </span>
01579 <span class="comment">//  vector is computed so that if the intensity of R/G/B is unit the resulting</span>
01580 <span class="comment">//  exit radiance of a point directly under the light on a diffuse object with</span>
01581 <span class="comment">//  an albedo of 1 would be 1.0.  This will compute 3 spectral samples, pROut</span>
01582 <span class="comment">//  has to be specified, while pGout and pBout are optional.</span>
01583 <span class="comment">//</span>
01584 <span class="comment">//  Parameters:</span>
01585 <span class="comment">//   Order</span>
01586 <span class="comment">//      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1</span>
01587 <span class="comment">//   pDir</span>
01588 <span class="comment">//      Direction light is coming from (assumed to be normalized.)</span>
01589 <span class="comment">//   RIntensity</span>
01590 <span class="comment">//      Red intensity of light.</span>
01591 <span class="comment">//   GIntensity</span>
01592 <span class="comment">//      Green intensity of light.</span>
01593 <span class="comment">//   BIntensity</span>
01594 <span class="comment">//      Blue intensity of light.</span>
01595 <span class="comment">//   pROut</span>
01596 <span class="comment">//      Output SH vector for Red.</span>
01597 <span class="comment">//   pGOut</span>
01598 <span class="comment">//      Output SH vector for Green (optional.)</span>
01599 <span class="comment">//   pBOut</span>
01600 <span class="comment">//      Output SH vector for Blue (optional.)        </span>
01601 <span class="comment">//</span>
01602 <span class="comment">//============================================================================</span>
01603 
01604 HRESULT WINAPI D3DXSHEvalDirectionalLight
01605     ( UINT Order, CONST D3DXVECTOR3 *pDir, 
01606       FLOAT RIntensity, FLOAT GIntensity, FLOAT BIntensity,
01607       FLOAT *pROut, FLOAT *pGOut, FLOAT *pBOut );
01608 
01609 <span class="comment">//============================================================================</span>
01610 <span class="comment">//</span>
01611 <span class="comment">//  D3DXSHEvalSphericalLight:</span>
01612 <span class="comment">//  --------------------</span>
01613 <span class="comment">//  Evaluates a spherical light and returns spectral SH data.  There is no </span>
01614 <span class="comment">//  normalization of the intensity of the light like there is for directional</span>
01615 <span class="comment">//  lights, care has to be taken when specifiying the intensities.  This will </span>
01616 <span class="comment">//  compute 3 spectral samples, pROut has to be specified, while pGout and </span>
01617 <span class="comment">//  pBout are optional.</span>
01618 <span class="comment">//</span>
01619 <span class="comment">//  Parameters:</span>
01620 <span class="comment">//   Order</span>
01621 <span class="comment">//      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1</span>
01622 <span class="comment">//   pPos</span>
01623 <span class="comment">//      Position of light - reciever is assumed to be at the origin.</span>
01624 <span class="comment">//   Radius</span>
01625 <span class="comment">//      Radius of the spherical light source.</span>
01626 <span class="comment">//   RIntensity</span>
01627 <span class="comment">//      Red intensity of light.</span>
01628 <span class="comment">//   GIntensity</span>
01629 <span class="comment">//      Green intensity of light.</span>
01630 <span class="comment">//   BIntensity</span>
01631 <span class="comment">//      Blue intensity of light.</span>
01632 <span class="comment">//   pROut</span>
01633 <span class="comment">//      Output SH vector for Red.</span>
01634 <span class="comment">//   pGOut</span>
01635 <span class="comment">//      Output SH vector for Green (optional.)</span>
01636 <span class="comment">//   pBOut</span>
01637 <span class="comment">//      Output SH vector for Blue (optional.)        </span>
01638 <span class="comment">//</span>
01639 <span class="comment">//============================================================================</span>
01640 
01641 HRESULT WINAPI D3DXSHEvalSphericalLight
01642     ( UINT Order, CONST D3DXVECTOR3 *pPos, FLOAT Radius,
01643       FLOAT RIntensity, FLOAT GIntensity, FLOAT BIntensity,
01644       FLOAT *pROut, FLOAT *pGOut, FLOAT *pBOut );
01645 
01646 <span class="comment">//============================================================================</span>
01647 <span class="comment">//</span>
01648 <span class="comment">//  D3DXSHEvalConeLight:</span>
01649 <span class="comment">//  --------------------</span>
01650 <span class="comment">//  Evaluates a light that is a cone of constant intensity and returns spectral</span>
01651 <span class="comment">//  SH data.  The output vector is computed so that if the intensity of R/G/B is</span>
01652 <span class="comment">//  unit the resulting exit radiance of a point directly under the light oriented</span>
01653 <span class="comment">//  in the cone direction on a diffuse object with an albedo of 1 would be 1.0.</span>
01654 <span class="comment">//  This will compute 3 spectral samples, pROut has to be specified, while pGout</span>
01655 <span class="comment">//  and pBout are optional.</span>
01656 <span class="comment">//</span>
01657 <span class="comment">//  Parameters:</span>
01658 <span class="comment">//   Order</span>
01659 <span class="comment">//      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1</span>
01660 <span class="comment">//   pDir</span>
01661 <span class="comment">//      Direction light is coming from (assumed to be normalized.)</span>
01662 <span class="comment">//   Radius</span>
01663 <span class="comment">//      Radius of cone in radians.</span>
01664 <span class="comment">//   RIntensity</span>
01665 <span class="comment">//      Red intensity of light.</span>
01666 <span class="comment">//   GIntensity</span>
01667 <span class="comment">//      Green intensity of light.</span>
01668 <span class="comment">//   BIntensity</span>
01669 <span class="comment">//      Blue intensity of light.</span>
01670 <span class="comment">//   pROut</span>
01671 <span class="comment">//      Output SH vector for Red.</span>
01672 <span class="comment">//   pGOut</span>
01673 <span class="comment">//      Output SH vector for Green (optional.)</span>
01674 <span class="comment">//   pBOut</span>
01675 <span class="comment">//      Output SH vector for Blue (optional.)        </span>
01676 <span class="comment">//</span>
01677 <span class="comment">//============================================================================</span>
01678 
01679 HRESULT WINAPI D3DXSHEvalConeLight
01680     ( UINT Order, CONST D3DXVECTOR3 *pDir, FLOAT Radius,
01681       FLOAT RIntensity, FLOAT GIntensity, FLOAT BIntensity,
01682       FLOAT *pROut, FLOAT *pGOut, FLOAT *pBOut );
01683       
01684 <span class="comment">//============================================================================</span>
01685 <span class="comment">//</span>
01686 <span class="comment">//  D3DXSHEvalHemisphereLight:</span>
01687 <span class="comment">//  --------------------</span>
01688 <span class="comment">//  Evaluates a light that is a linear interpolant between two colors over the</span>
01689 <span class="comment">//  sphere.  The interpolant is linear along the axis of the two points, not</span>
01690 <span class="comment">//  over the surface of the sphere (ie: if the axis was (0,0,1) it is linear in</span>
01691 <span class="comment">//  Z, not in the azimuthal angle.)  The resulting spherical lighting function</span>
01692 <span class="comment">//  is normalized so that a point on a perfectly diffuse surface with no</span>
01693 <span class="comment">//  shadowing and a normal pointed in the direction pDir would result in exit</span>
01694 <span class="comment">//  radiance with a value of 1 if the top color was white and the bottom color</span>
01695 <span class="comment">//  was black.  This is a very simple model where Top represents the intensity </span>
01696 <span class="comment">//  of the "sky" and Bottom represents the intensity of the "ground".</span>
01697 <span class="comment">//</span>
01698 <span class="comment">//  Parameters:</span>
01699 <span class="comment">//   Order</span>
01700 <span class="comment">//      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1</span>
01701 <span class="comment">//   pDir</span>
01702 <span class="comment">//      Axis of the hemisphere.</span>
01703 <span class="comment">//   Top</span>
01704 <span class="comment">//      Color of the upper hemisphere.</span>
01705 <span class="comment">//   Bottom</span>
01706 <span class="comment">//      Color of the lower hemisphere.</span>
01707 <span class="comment">//   pROut</span>
01708 <span class="comment">//      Output SH vector for Red.</span>
01709 <span class="comment">//   pGOut</span>
01710 <span class="comment">//      Output SH vector for Green</span>
01711 <span class="comment">//   pBOut</span>
01712 <span class="comment">//      Output SH vector for Blue        </span>
01713 <span class="comment">//</span>
01714 <span class="comment">//============================================================================</span>
01715 
01716 HRESULT WINAPI D3DXSHEvalHemisphereLight
01717     ( UINT Order, CONST D3DXVECTOR3 *pDir, D3DXCOLOR Top, D3DXCOLOR Bottom,
01718       FLOAT *pROut, FLOAT *pGOut, FLOAT *pBOut );
01719 
01720 <span class="comment">//============================================================================</span>
01721 <span class="comment">//</span>
01722 <span class="comment">//  Basic Spherical Harmonic projection routines</span>
01723 <span class="comment">//</span>
01724 <span class="comment">//============================================================================</span>
01725 
01726 <span class="comment">//============================================================================</span>
01727 <span class="comment">//</span>
01728 <span class="comment">//  D3DXSHProjectCubeMap:</span>
01729 <span class="comment">//  --------------------</span>
01730 <span class="comment">//  Projects a function represented on a cube map into spherical harmonics.</span>
01731 <span class="comment">//</span>
01732 <span class="comment">//  Parameters:</span>
01733 <span class="comment">//   Order</span>
01734 <span class="comment">//      Order of the SH evaluation, generates Order^2 coefs, degree is Order-1</span>
01735 <span class="comment">//   pCubeMap</span>
01736 <span class="comment">//      CubeMap that is going to be projected into spherical harmonics</span>
01737 <span class="comment">//   pROut</span>
01738 <span class="comment">//      Output SH vector for Red.</span>
01739 <span class="comment">//   pGOut</span>
01740 <span class="comment">//      Output SH vector for Green</span>
01741 <span class="comment">//   pBOut</span>
01742 <span class="comment">//      Output SH vector for Blue        </span>
01743 <span class="comment">//</span>
01744 <span class="comment">//============================================================================</span>
01745 
01746 HRESULT WINAPI D3DXSHProjectCubeMap
01747     ( UINT uOrder, LPDIRECT3DCUBETEXTURE9 pCubeMap,
01748       FLOAT *pROut, FLOAT *pGOut, FLOAT *pBOut );
01749 
01750 
01751 <span class="preprocessor">#ifdef __cplusplus</span>
01752 <span class="preprocessor"></span>}
01753 <span class="preprocessor">#endif</span>
01754 <span class="preprocessor"></span>
01755 
01756 <span class="preprocessor">#include "d3dx9math.inl"</span>
01757 
01758 <span class="preprocessor">#if _MSC_VER &gt;= 1200</span>
01759 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(pop)</span>
01760 <span class="preprocessor"></span><span class="preprocessor">#else</span>
01761 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(default:4201)</span>
01762 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01763 <span class="preprocessor"></span>
01764 <span class="preprocessor">#endif // __D3DX9MATH_H__</span>
01765 <span class="preprocessor"></span>
</pre></div><hr><address style="align: right;"><small>
Generated on Tue Jun 13 11:14:34 2006 for gRenderDX9 by <a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 width=110 height=53>
</a> 1.3.1 using KingsTools</small></address>
</body>
</html>
