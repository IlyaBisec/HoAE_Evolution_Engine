<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gRenderDX9: d3dApp.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.1 -->
<h1>d3dApp.cpp</h1><div class="fragment"><pre>00001 <span class="comment">//-----------------------------------------------------------------------------</span>
00002 <span class="comment">// File: D3DApp.cpp</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// Desc: Application class for the Direct3D samples framework library.</span>
00005 <span class="comment">//</span>
00006 <span class="comment">// Copyright (c) Microsoft Corporation. All rights reserved.</span>
00007 <span class="comment">//-----------------------------------------------------------------------------</span>
00008 <span class="preprocessor">#include "gRenderPch.h"</span>
00009 <span class="preprocessor">#include "kLog.h"</span>
00010 <span class="preprocessor">#include "IRenderSystem.h"</span>
00011 
00012 <span class="comment">//#define SHIPPING_VERSION</span>
00013 
00014 <span class="comment">//-----------------------------------------------------------------------------</span>
00015 <span class="comment">// Global access to the app (needed for the global WndProc())</span>
00016 <span class="comment">//-----------------------------------------------------------------------------</span>
00017 <span class="keyword">static</span> D3DApplication* g_pD3DApp = NULL;
00018 
00019 <span class="comment">//-----------------------------------------------------------------------------</span>
00020 <span class="comment">// Name: D3DApplication()</span>
00021 <span class="comment">// Desc: Constructor</span>
00022 <span class="comment">//-----------------------------------------------------------------------------</span>
00023 D3DApplication::D3DApplication()
00024 {
00025     g_pD3DApp                   = <span class="keyword">this</span>;
00026 
00027     m_pD3D                      = NULL;
00028     m_pDevice                   = NULL;
00029     m_hWnd                      = NULL;
00030     m_hWndFocus                 = NULL;
00031     m_hMenu                     = NULL;
00032     m_bWindowed                 = <span class="keyword">true</span>;
00033     m_bActive                   = <span class="keyword">false</span>;
00034     m_bDeviceLost               = <span class="keyword">false</span>;
00035     m_bMinimized                = <span class="keyword">false</span>;
00036     m_bMaximized                = <span class="keyword">false</span>;
00037     m_bIgnoreSizeChange         = <span class="keyword">false</span>;
00038     m_bDeviceObjectsInited      = <span class="keyword">false</span>;
00039     m_bDeviceObjectsRestored    = <span class="keyword">false</span>;
00040     m_dwCreateFlags             = 0;
00041 
00042     m_bFrameMoving              = <span class="keyword">true</span>;
00043     m_bSingleStep               = <span class="keyword">false</span>;
00044     m_fTime                     = 0.0f;
00045     m_fElapsedTime              = 0.0f;
00046     m_fFPS                      = 0.0f;
00047     m_strDeviceStats[0]         = _T(<span class="charliteral">'\0'</span>);
00048     m_strFrameStats[0]          = _T(<span class="charliteral">'\0'</span>);
00049 
00050     m_strWindowTitle            = _T(<span class="stringliteral">"D3D9 Application"</span>);
00051     m_dwCreationWidth           = 640;
00052     m_dwCreationHeight          = 480;
00053     m_bShowCursorWhenFullscreen = <span class="keyword">false</span>;
00054     m_bStartFullscreen          = <span class="keyword">false</span>;
00055     m_bCreateMultithreadDevice  = <span class="keyword">false</span>;
00056     m_bAllowDialogBoxMode       = <span class="keyword">false</span>;
00057 
00058     m_bActive                   = <span class="keyword">false</span>;
00059 
00060     <span class="comment">// When m_bClipCursorWhenFullscreen is true, the cursor is limited to</span>
00061     <span class="comment">// the device window when the app goes fullscreen.  This prevents users</span>
00062     <span class="comment">// from accidentally clicking outside the app window on a multimon system.</span>
00063     <span class="comment">// This flag is turned off by default for debug builds, since it makes </span>
00064     <span class="comment">// multimon debugging difficult.</span>
00065 <span class="preprocessor">#if defined(_DEBUG) || defined(DEBUG)</span>
00066 <span class="preprocessor"></span>    m_bClipCursorWhenFullscreen = <span class="keyword">false</span>;
00067 <span class="preprocessor">#else</span>
00068 <span class="preprocessor"></span>    m_bClipCursorWhenFullscreen = <span class="keyword">true</span>;
00069 <span class="preprocessor">#endif</span>
00070 <span class="preprocessor"></span>} <span class="comment">// D3DApplication::D3DApplication</span>
00071 
00072 <span class="comment">//-----------------------------------------------------------------------------</span>
00073 <span class="comment">// Name: WndProc()</span>
00074 <span class="comment">// Desc: Static msg handler which passes messages to the application class.</span>
00075 <span class="comment">//-----------------------------------------------------------------------------</span>
00076 LRESULT CALLBACK WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
00077 {
00078     g_pD3DApp-&gt;HostWndProc( hWnd, uMsg, wParam, lParam );
00079     <span class="keywordflow">return</span> g_pD3DApp-&gt;MsgProc( hWnd, uMsg, wParam, lParam );
00080 }
00081 
00082 LRESULT D3DApplication::HostWndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
00083 {
00084     <span class="keywordflow">if</span> (m_HostWndProc) <span class="keywordflow">return</span> m_HostWndProc( hWnd, uMsg, wParam, lParam );
00085     <span class="keywordflow">return</span> 0;
00086 } <span class="comment">// D3DApplication::HostWndProc</span>
00087 
00088 <span class="comment">//-----------------------------------------------------------------------------</span>
00089 <span class="comment">// Name: ConfirmDeviceHelper()</span>
00090 <span class="comment">// Desc: Static function used by D3DEnumeration</span>
00091 <span class="comment">//-----------------------------------------------------------------------------</span>
00092 <span class="keywordtype">bool</span> D3DApplication::ConfirmDeviceHelper( D3DCAPS9* pCaps, VertexProcessingType vertexProcessingType, 
00093                                             D3DFORMAT adapterFormat, D3DFORMAT backBufferFormat )
00094 {
00095     DWORD dwBehavior;
00096 
00097     <span class="keywordflow">if</span> (vertexProcessingType == vpSoftware) dwBehavior = D3DCREATE_SOFTWARE_VERTEXPROCESSING;
00098     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vertexProcessingType == vpMixed) dwBehavior = D3DCREATE_MIXED_VERTEXPROCESSING;
00099     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vertexProcessingType == vpHardware) dwBehavior = D3DCREATE_HARDWARE_VERTEXPROCESSING;
00100     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vertexProcessingType == vpPureHardware)
00101         dwBehavior = D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_PUREDEVICE;
00102     <span class="keywordflow">else</span>
00103         dwBehavior = 0; <span class="comment">// TODO: throw exception</span>
00104     
00105     <span class="keywordflow">return</span> SUCCEEDED( g_pD3DApp-&gt;ConfirmDevice( pCaps, dwBehavior, adapterFormat, backBufferFormat ) );
00106 } <span class="comment">// D3DApplication::ConfirmDeviceHelper</span>
00107 
00108 <span class="comment">//-----------------------------------------------------------------------------</span>
00109 <span class="comment">// Name: Create()</span>
00110 <span class="comment">// Desc: Here's what this function does:</span>
00111 <span class="comment">//       - Checks to make sure app is still active (if fullscreen, etc)</span>
00112 <span class="comment">//       - Checks to see if it is time to draw with DXUtil_Timer, if not, it just returns S_OK</span>
00113 <span class="comment">//       - Calls Render() to draw the new frame</span>
00114 <span class="comment">//       - Updates some frame count statistics</span>
00115 <span class="comment">//       - Calls m_pDevice-&gt;Present() to display the rendered frame.</span>
00116 <span class="comment">//-----------------------------------------------------------------------------</span>
00117 HRESULT D3DApplication::Create( HINSTANCE hInstance, HWND hWnd )
00118 {
00119     HRESULT hr;
00120     assert( !m_hWnd );
00121     m_hWnd = hWnd;
00122 
00123     <span class="comment">// Create the Direct3D object</span>
00124     m_pD3D = Direct3DCreate9( D3D_SDK_VERSION );
00125     <span class="keywordflow">if</span> (m_pD3D == NULL) <span class="keywordflow">return</span> DisplayErrorMsg( D3DAPPERR_NODIRECT3D, MSGERR_APPMUSTEXIT );
00126 
00127     <span class="comment">//  get current desktop display mode in order to restore it at shutdown</span>
00128     EnumDisplaySettings( NULL, ENUM_CURRENT_SETTINGS, &amp;m_InitialDesktopMode );
00129 
00130     <span class="comment">// Build a list of Direct3D adapters, modes and devices. The</span>
00131     <span class="comment">// ConfirmDevice() callback is used to confirm that only devices that</span>
00132     <span class="comment">// meet the app's requirements are considered.</span>
00133     m_d3dEnum.SetD3D( m_pD3D );
00134     m_d3dEnum.ConfirmDevice              = ConfirmDeviceHelper;
00135     m_d3dEnum.m_AppMinFullscreenWidth    = 800;
00136     m_d3dEnum.m_AppMinFullscreenHeight   = 600;
00137     <span class="keywordflow">if</span> (FAILED( hr = m_d3dEnum.Enumerate() ))
00138     {
00139         SAFE_RELEASE( m_pD3D );
00140         <span class="keywordflow">return</span> DisplayErrorMsg( hr, MSGERR_APPMUSTEXIT );
00141     }
00142 
00143     <span class="comment">// Unless a substitute hWnd has been specified, create a window to</span>
00144     <span class="comment">// render into</span>
00145     <span class="keywordflow">if</span> (m_hWnd == NULL)
00146     {
00147         <span class="comment">// Register the windows class</span>
00148         WNDCLASS wndClass = { CS_DBLCLKS, WndProc, 0, 0, hInstance,
00149                               LoadIcon( hInstance, MAKEINTRESOURCE(IDI_MAIN_ICON) ),
00150                               LoadCursor( NULL, IDC_ARROW ),
00151                               (HBRUSH)GetStockObject(WHITE_BRUSH),
00152                               NULL, _T(<span class="stringliteral">"D3D Window"</span>) };
00153         RegisterClass( &amp;wndClass );
00154 
00155         <span class="comment">// Set the window's initial style</span>
00156         m_dwWindowStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | 
00157                           WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_VISIBLE;
00158         m_dwWindowStyle = WS_POPUP;
00159         
00160         <span class="comment">// Set the window's initial width</span>
00161         RECT rc;
00162         SetRect( &amp;rc, 0, 0, m_dwCreationWidth, m_dwCreationHeight );        
00163         
00164         <span class="comment">// Create the render window</span>
00165         m_hWnd = CreateWindow( _T(<span class="stringliteral">"D3D Window"</span>), m_strWindowTitle, m_dwWindowStyle,
00166                                CW_USEDEFAULT, CW_USEDEFAULT,
00167                                (rc.right-rc.left), (rc.bottom-rc.top), 0,
00168                                NULL, hInstance, 0 );
00169 
00170 
00171     }
00172     <span class="keywordflow">else</span>
00173     {
00174         <span class="comment">//  hook in window message procedure</span>
00175         m_HostWndProc = (WNDPROC)SetWindowLong( m_hWnd, GWL_WNDPROC, (LONG)WndProc );
00176     }
00177 
00178     <span class="comment">// The focus window can be a specified to be a different window than the</span>
00179     <span class="comment">// device window.  If not, use the device window as the focus window.</span>
00180     <span class="keywordflow">if</span>( m_hWndFocus == NULL ) m_hWndFocus = m_hWnd;
00181 
00182     <span class="comment">// Save window properties</span>
00183     m_dwWindowStyle = GetWindowLong( m_hWnd, GWL_STYLE );
00184     GetWindowRect( m_hWnd, &amp;m_rcWindowBounds );
00185     GetClientRect( m_hWnd, &amp;m_rcWindowClient );
00186 
00187     <span class="keywordflow">if</span>( FAILED( hr = ChooseInitialD3DSettings() ) )
00188     {
00189         SAFE_RELEASE( m_pD3D );
00190         <span class="keywordflow">return</span> DisplayErrorMsg( hr, MSGERR_APPMUSTEXIT );
00191     }
00192 
00193     <span class="comment">// Initialize the application timer</span>
00194     DXUtil_Timer( TIMER_START );
00195 
00196     <span class="comment">// Initialize the app's custom scene stuff</span>
00197     <span class="keywordflow">if</span>( FAILED( hr = OneTimeSceneInit() ) )
00198     {
00199         SAFE_RELEASE( m_pD3D );
00200         <span class="keywordflow">return</span> DisplayErrorMsg( hr, MSGERR_APPMUSTEXIT );
00201     }
00202 
00203     <span class="comment">// Initialize the 3D environment for the app</span>
00204     <span class="keywordflow">if</span>( FAILED( hr = Initialize3DEnvironment() ) )
00205     {
00206         SAFE_RELEASE( m_pD3D );
00207         <span class="keywordflow">return</span> DisplayErrorMsg( hr, MSGERR_APPMUSTEXIT );
00208     }
00209 
00210     <span class="comment">// The app is ready to go</span>
00211     m_bActive = <span class="keyword">true</span>;
00212 
00213     <span class="keywordflow">return</span> S_OK;
00214 } <span class="comment">// D3DApplication::Create</span>
00215 
00216 <span class="comment">//-----------------------------------------------------------------------------</span>
00217 <span class="comment">// Name: FindBestWindowedMode()</span>
00218 <span class="comment">// Desc: Sets up m_d3dSettings with best available windowed mode, subject to </span>
00219 <span class="comment">//       the bRequireHAL and bRequireREF constraints.  Returns false if no such</span>
00220 <span class="comment">//       mode can be found.</span>
00221 <span class="comment">//-----------------------------------------------------------------------------</span>
00222 <span class="keywordtype">bool</span> D3DApplication::FindBestWindowedMode( <span class="keywordtype">bool</span> bRequireHAL, <span class="keywordtype">bool</span> bRequireREF )
00223 {
00224     <span class="comment">// Get display mode of primary adapter (which is assumed to be where the window </span>
00225     <span class="comment">// will appear)</span>
00226     D3DDISPLAYMODE desktopMode;
00227     m_pD3D-&gt;GetAdapterDisplayMode( 0, &amp;desktopMode );
00228 
00229     D3DAdapterInfo* pBestAdapterInfo = NULL;
00230     D3DDeviceInfo*  pBestDeviceInfo = NULL;
00231     D3DDeviceCombo* pBestDeviceCombo = NULL;
00232 
00233     <span class="keywordtype">bool</span> bEndSearch = <span class="keyword">false</span>;
00234     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_d3dEnum.m_AdapterInfoList.size(); i++ )
00235     {
00236         D3DAdapterInfo&amp; adInfo = m_d3dEnum.m_AdapterInfoList[i];
00237         <span class="keywordflow">for</span>( UINT j = 0; j &lt; adInfo.m_DevInfos.size(); j++ )
00238         {
00239             D3DDeviceInfo&amp; devInfo = adInfo.m_DevInfos[j];
00240             <span class="keywordflow">if</span> (bRequireHAL &amp;&amp; devInfo.m_DevType != D3DDEVTYPE_HAL) <span class="keywordflow">continue</span>;
00241             <span class="keywordflow">if</span> (bRequireREF &amp;&amp; devInfo.m_DevType != D3DDEVTYPE_REF) <span class="keywordflow">continue</span>;
00242             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; devInfo.m_DevCombos.size(); k++)
00243             {
00244                 D3DDeviceCombo&amp; devCombo = devInfo.m_DevCombos[k];
00245                 <span class="keywordtype">bool</span> bAdapterMatchesBB = (devCombo.m_BackBufferFormat == devCombo.m_AdapterFormat);
00246                 <span class="keywordflow">if</span> (!devCombo.m_bIsWindowed) <span class="keywordflow">continue</span>;
00247 
00248                 <span class="keywordflow">if</span> (devCombo.m_BackBufferFormat != D3DFMT_R5G6B5) <span class="keywordflow">continue</span>;
00249                 <span class="keywordflow">if</span> (devCombo.m_AdapterFormat != desktopMode.Format) <span class="keywordflow">continue</span>;
00250                 <span class="comment">// If we haven't found a compatible DeviceCombo yet, or if this set</span>
00251                 <span class="comment">// is better (because it's a HAL, and/or because formats match better), save it</span>
00252                 <span class="keywordflow">if</span> (pBestDeviceCombo == NULL || 
00253                     pBestDeviceCombo-&gt;m_DevType != D3DDEVTYPE_HAL &amp;&amp; 
00254                     devCombo.m_DevType == D3DDEVTYPE_HAL ||
00255                     (devCombo.m_DevType == D3DDEVTYPE_HAL &amp;&amp; bAdapterMatchesBB))
00256                 {
00257                     pBestAdapterInfo    = &amp;adInfo;
00258                     pBestDeviceInfo     = &amp;devInfo;
00259                     pBestDeviceCombo    = &amp;devCombo;
00260                     <span class="keywordflow">if</span> (devCombo.m_DevType == D3DDEVTYPE_HAL &amp;&amp; bAdapterMatchesBB)
00261                     {
00262                         <span class="comment">// This windowed device combo looks great -- take it</span>
00263                         bEndSearch = <span class="keyword">true</span>;
00264                     }
00265                     <span class="comment">// Otherwise keep looking for a better windowed device combo</span>
00266                 }
00267                 <span class="keywordflow">if</span> (bEndSearch) <span class="keywordflow">break</span>;
00268             }
00269             <span class="keywordflow">if</span> (bEndSearch) <span class="keywordflow">break</span>;
00270         }
00271         <span class="keywordflow">if</span> (bEndSearch) <span class="keywordflow">break</span>;
00272     }
00273     
00274     <span class="keywordflow">if</span> (pBestDeviceCombo == NULL ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00275 
00276     D3DSettings&amp; s = m_d3dSettings;
00277     s.pWindowed_AdapterInfo         = pBestAdapterInfo;
00278     s.pWindowed_DeviceInfo          = pBestDeviceInfo;
00279     s.pWindowed_DeviceCombo         = pBestDeviceCombo;
00280     s.m_bIsWindowed                 = <span class="keyword">true</span>;
00281     s.Windowed_DisplayMode          = desktopMode;
00282     s.Windowed_Width                = m_rcWindowClient.right - m_rcWindowClient.left;
00283     s.Windowed_Height               = m_rcWindowClient.bottom - m_rcWindowClient.top;
00284     s.Windowed_MultisampleType = s.Windowed_WorstMultisampleType = pBestDeviceCombo-&gt;m_MSampleTypes[0];
00285     s.Windowed_BestMultisampleType  = pBestDeviceCombo-&gt;m_MSampleTypes[pBestDeviceCombo-&gt;m_MSampleTypes.size() - 1];
00286 
00287     s.Windowed_MultisampleQuality   = 0;
00288     s.Windowed_VertexProcessingType = pBestDeviceCombo-&gt;m_VProcessTypes[0];
00289     s.Windowed_PresentInterval      = pBestDeviceCombo-&gt;m_PresentIntervals[0];
00290     <span class="keywordflow">if</span> (m_d3dEnum.m_bUseZBuffer)
00291     {
00292         s.Windowed_DepthStencilBufferFormat = pBestDeviceCombo-&gt;m_DepthStencilFormats[0];
00293     }
00294     
00295     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00296 } <span class="comment">// D3DApplication::FindBestWindowedMode</span>
00297 
00298 <span class="comment">//-----------------------------------------------------------------------------</span>
00299 <span class="comment">// Name: FindBestFullscreenMode()</span>
00300 <span class="comment">// Desc: Sets up m_d3dSettings with best available fullscreen mode, subject to </span>
00301 <span class="comment">//       the bRequireHAL and bRequireREF constraints.  Returns false if no such</span>
00302 <span class="comment">//       mode can be found.</span>
00303 <span class="comment">//-----------------------------------------------------------------------------</span>
00304 <span class="keywordtype">bool</span> D3DApplication::FindBestFullscreenMode( <span class="keywordtype">bool</span> bRequireHAL, <span class="keywordtype">bool</span> bRequireREF )
00305 {
00306     <span class="comment">// For fullscreen, default to first HAL DeviceCombo that supports the current desktop </span>
00307     <span class="comment">// display mode, or any display mode if HAL is not compatible with the desktop mode, or </span>
00308     <span class="comment">// non-HAL if no HAL is available</span>
00309     D3DDISPLAYMODE deskMode;
00310     D3DDISPLAYMODE bestDeskMode;
00311     D3DDISPLAYMODE bestDisplayMode;
00312     bestDeskMode.Width = 0;
00313     bestDeskMode.Height = 0;
00314     bestDeskMode.Format = D3DFMT_UNKNOWN;
00315     bestDeskMode.RefreshRate = 0;
00316 
00317     D3DAdapterInfo* pBestAdapterInfo = NULL;
00318     D3DDeviceInfo* pBestDeviceInfo = NULL;
00319     D3DDeviceCombo* pBestDeviceCombo = NULL;
00320 
00321     <span class="keywordflow">for</span>( UINT i = 0; i &lt; m_d3dEnum.m_AdapterInfoList.size(); i++ )
00322     {
00323         D3DAdapterInfo&amp; adInfo = m_d3dEnum.m_AdapterInfoList[i];
00324         m_pD3D-&gt;GetAdapterDisplayMode( adInfo.m_Ordinal, &amp;deskMode );
00325         <span class="keywordflow">for</span>( UINT j = 0; j &lt; adInfo.m_DevInfos.size(); j++ )
00326         {
00327             D3DDeviceInfo&amp; devInfo = adInfo.m_DevInfos[j];
00328             <span class="keywordflow">if</span> (bRequireHAL &amp;&amp; devInfo.m_DevType != D3DDEVTYPE_HAL) <span class="keywordflow">continue</span>;
00329             <span class="keywordflow">if</span> (bRequireREF &amp;&amp; devInfo.m_DevType != D3DDEVTYPE_REF) <span class="keywordflow">continue</span>;
00330             <span class="keywordflow">for</span>( UINT k = 0; k &lt; devInfo.m_DevCombos.size(); k++ )
00331             {
00332                 D3DDeviceCombo&amp; devCombo  = devInfo.m_DevCombos[k];
00333                 <span class="keywordtype">bool</span> bAdapterMatchesBB          = (devCombo.m_BackBufferFormat == devCombo.m_AdapterFormat);
00334                 <span class="keywordtype">bool</span> bAdapterMatchesDesktop     = (devCombo.m_AdapterFormat == deskMode.Format);
00335                 <span class="keywordflow">if</span> (devCombo.m_bIsWindowed) <span class="keywordflow">continue</span>;
00336                 <span class="comment">// If we haven't found a compatible set yet, or if this set</span>
00337                 <span class="comment">// is better (because it's a HAL, and/or because formats match better),</span>
00338                 <span class="comment">// save it</span>
00339                 <span class="keywordflow">if</span> (pBestDeviceCombo == NULL ||
00340                     pBestDeviceCombo-&gt;m_DevType != D3DDEVTYPE_HAL &amp;&amp; 
00341                     devInfo.m_DevType == D3DDEVTYPE_HAL ||
00342                     devCombo.m_DevType == D3DDEVTYPE_HAL &amp;&amp; 
00343                     pBestDeviceCombo-&gt;m_AdapterFormat != deskMode.Format &amp;&amp; 
00344                     bAdapterMatchesDesktop ||
00345                     devCombo.m_DevType == D3DDEVTYPE_HAL &amp;&amp; 
00346                     bAdapterMatchesDesktop &amp;&amp; 
00347                     bAdapterMatchesBB )
00348                 {
00349                     bestDeskMode        = deskMode;
00350                     pBestAdapterInfo    = &amp;adInfo;
00351                     pBestDeviceInfo     = &amp;devInfo;
00352                     pBestDeviceCombo    = &amp;devCombo;
00353                     <span class="keywordflow">if</span> (devInfo.m_DevType == D3DDEVTYPE_HAL &amp;&amp; bAdapterMatchesDesktop &amp;&amp; bAdapterMatchesBB)
00354                     {
00355                         <span class="comment">// This fullscreen device combo looks great -- take it</span>
00356                         <span class="keywordflow">goto</span> EndFullscreenDeviceComboSearch;
00357                     }
00358                     <span class="comment">// Otherwise keep looking for a better fullscreen device combo</span>
00359                 }
00360             }
00361         }
00362     }
00363 EndFullscreenDeviceComboSearch:
00364     <span class="keywordflow">if</span> (pBestDeviceCombo == NULL)
00365         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00366 
00367     <span class="comment">// Need to find a display mode on the best adapter that uses pBestDeviceCombo-&gt;m_AdapterFormat</span>
00368     <span class="comment">// and is as close to bestDeskMode's res as possible</span>
00369     bestDisplayMode.Width = 0;
00370     bestDisplayMode.Height = 0;
00371     bestDisplayMode.Format = D3DFMT_UNKNOWN;
00372     bestDisplayMode.RefreshRate = 0;
00373     <span class="keywordflow">for</span>( UINT idm = 0; idm &lt; pBestAdapterInfo-&gt;m_DisplayModes.size(); idm++ )
00374     {
00375         D3DDISPLAYMODE* pdm = &amp;pBestAdapterInfo-&gt;m_DisplayModes[idm];
00376         <span class="keywordflow">if</span>( pdm-&gt;Format != pBestDeviceCombo-&gt;m_AdapterFormat )
00377             <span class="keywordflow">continue</span>;
00378         <span class="keywordflow">if</span>( pdm-&gt;Width == bestDeskMode.Width &amp;&amp;
00379             pdm-&gt;Height == bestDeskMode.Height &amp;&amp; 
00380             pdm-&gt;RefreshRate == bestDeskMode.RefreshRate )
00381         {
00382             <span class="comment">// found a perfect match, so stop</span>
00383             bestDisplayMode = *pdm;
00384             <span class="keywordflow">break</span>;
00385         }
00386         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( pdm-&gt;Width == bestDeskMode.Width &amp;&amp;
00387                  pdm-&gt;Height == bestDeskMode.Height &amp;&amp; 
00388                  pdm-&gt;RefreshRate &gt; bestDisplayMode.RefreshRate )
00389         {
00390             <span class="comment">// refresh rate doesn't match, but width/height match, so keep this</span>
00391             <span class="comment">// and keep looking</span>
00392             bestDisplayMode = *pdm;
00393         }
00394         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( pdm-&gt;Width == bestDeskMode.Width )
00395         {
00396             <span class="comment">// width matches, so keep this and keep looking</span>
00397             bestDisplayMode = *pdm;
00398         }
00399         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( bestDisplayMode.Width == 0 )
00400         {
00401             <span class="comment">// we don't have anything better yet, so keep this and keep looking</span>
00402             bestDisplayMode = *pdm;
00403         }
00404     }
00405 
00406     m_d3dSettings.pFullscreen_AdapterInfo                   = pBestAdapterInfo;
00407     m_d3dSettings.pFullscreen_DeviceInfo                    = pBestDeviceInfo;
00408     m_d3dSettings.pFullscreen_DeviceCombo                   = pBestDeviceCombo;
00409     m_d3dSettings.m_bIsWindowed                             = <span class="keyword">false</span>;
00410     m_d3dSettings.Fullscreen_DisplayMode                    = bestDisplayMode;
00411     <span class="keywordflow">if</span> (m_d3dEnum.m_bUseZBuffer)
00412         m_d3dSettings.Fullscreen_DepthStencilBufferFormat   = pBestDeviceCombo-&gt;m_DepthStencilFormats[0];
00413     m_d3dSettings.Fullscreen_MultisampleType = m_d3dSettings.Fullscreen_WorstMultisampleType = pBestDeviceCombo-&gt;m_MSampleTypes[0];
00414     m_d3dSettings.Fullscreen_BestMultisampleType            = pBestDeviceCombo-&gt;m_MSampleTypes[pBestDeviceCombo-&gt;m_MSampleTypes.size() - 1];
00415     m_d3dSettings.Fullscreen_MultisampleQuality             = 0;
00416     m_d3dSettings.Fullscreen_VertexProcessingType           = pBestDeviceCombo-&gt;m_VProcessTypes[0];
00417     m_d3dSettings.Fullscreen_PresentInterval                = D3DPRESENT_INTERVAL_DEFAULT;
00418     
00419     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00420 } <span class="comment">// D3DApplication::FindBestFullscreenMode</span>
00421 
00422 <span class="comment">//-----------------------------------------------------------------------------</span>
00423 <span class="comment">// Name: ChooseInitialD3DSettings()</span>
00424 <span class="comment">//-----------------------------------------------------------------------------</span>
00425 HRESULT D3DApplication::ChooseInitialD3DSettings()
00426 {
00427     <span class="keywordtype">bool</span> bFoundFullscreen = FindBestFullscreenMode( <span class="keyword">false</span>, <span class="keyword">false</span> );
00428     <span class="keywordtype">bool</span> bFoundWindowed = FindBestWindowedMode( <span class="keyword">false</span>, <span class="keyword">false</span> );
00429     m_d3dSettings.SetDeviceClip( <span class="keyword">false</span> );
00430 
00431     <span class="keywordflow">if</span>( m_bStartFullscreen &amp;&amp; bFoundFullscreen )
00432         m_d3dSettings.m_bIsWindowed = <span class="keyword">false</span>;
00433     <span class="keywordflow">if</span>( !bFoundWindowed &amp;&amp; bFoundFullscreen )
00434         m_d3dSettings.m_bIsWindowed = <span class="keyword">false</span>;
00435 
00436     <span class="keywordflow">if</span>( !bFoundFullscreen &amp;&amp; !bFoundWindowed )
00437         <span class="keywordflow">return</span> D3DAPPERR_NOCOMPATIBLEDEVICES;
00438 
00439     <span class="keywordflow">return</span> S_OK;
00440 } <span class="comment">// D3DApplication::ChooseInitialD3DSettings</span>
00441 
00442 <span class="comment">//-----------------------------------------------------------------------------</span>
00443 <span class="comment">// Name: MsgProc()</span>
00444 <span class="comment">// Desc: Message handling function.  Here's what this function does:</span>
00445 <span class="comment">//       - WM_PAINT: calls Render() and Present() is called if !m_bReady</span>
00446 <span class="comment">//       - WM_EXITSIZEMOVE: window size recalc'd and calls HandlePossibleSizeChange()</span>
00447 <span class="comment">//       - WM_CLOSE: calls Cleanup3dEnvironment(), DestroyMenu(), DestroyWindow(), PostQuitMessage()</span>
00448 <span class="comment">//       - WM_COMMAND: IDM_CHANGEDEVICE calls UserSelectNewDevice() to select a new device</span>
00449 <span class="comment">//       - WM_COMMAND: IDM_TOGGLEFULLSCREEN calls ToggleFullScreen() to toggle </span>
00450 <span class="comment">//                  between fullscreen and windowed</span>
00451 <span class="comment">//       - WM_COMMAND: IDM_EXIT: shuts down the app with a WM_CLOSE </span>
00452 <span class="comment">//       - anything not handled goes to DefWindowProc()     </span>
00453 <span class="comment">//-----------------------------------------------------------------------------</span>
00454 LRESULT D3DApplication::MsgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
00455 {
00456     <span class="keywordflow">switch</span>( uMsg )
00457     {
00458         <span class="keywordflow">case</span> WM_PAINT:
00460             <span class="comment">//if( m_pDevice &amp;&amp; !m_bActive &amp;&amp; </span>
00461             <span class="comment">//    m_bDeviceObjectsInited &amp;&amp; m_bDeviceObjectsRestored )</span>
00462             <span class="comment">//{</span>
00463             <span class="comment">//    HRESULT hr;</span>
00464             <span class="comment">//    hr = m_pDevice-&gt;Present( NULL, NULL, NULL, NULL );</span>
00465             <span class="comment">//    if( D3DERR_DEVICELOST == hr )</span>
00466             <span class="comment">//        m_bDeviceLost = true;</span>
00467             <span class="comment">//}</span>
00468             <span class="keywordflow">break</span>;
00469 
00470         <span class="keywordflow">case</span> WM_GETMINMAXINFO:
00471             ((MINMAXINFO*)lParam)-&gt;ptMinTrackSize.x = 100;
00472             ((MINMAXINFO*)lParam)-&gt;ptMinTrackSize.y = 100;
00473             <span class="keywordflow">break</span>;
00474 
00475         <span class="keywordflow">case</span> WM_ENTERSIZEMOVE:
00476             <span class="comment">// Halt frame movement while the app is sizing or moving</span>
00477             m_bActive = <span class="keyword">false</span>;
00478             <span class="keywordflow">break</span>;
00479 
00480         <span class="keywordflow">case</span> WM_SIZE:
00481             <span class="comment">// Pick up possible changes to window style due to maximize, etc.</span>
00482             <span class="keywordflow">if</span>( m_bWindowed &amp;&amp; m_hWnd != NULL )
00483                 m_dwWindowStyle = GetWindowLong( m_hWnd, GWL_STYLE );
00484 
00485             <span class="keywordflow">if</span>( SIZE_MINIMIZED == wParam )
00486             {
00487                 <span class="keywordflow">if</span>( m_bClipCursorWhenFullscreen &amp;&amp; !m_bWindowed )
00488                     ClipCursor( NULL );
00489                 m_bActive = <span class="keyword">false</span>;
00490                 m_bMinimized = <span class="keyword">true</span>;
00491                 m_bMaximized = <span class="keyword">false</span>;
00492             }
00493             <span class="keywordflow">else</span> <span class="keywordflow">if</span>( SIZE_MAXIMIZED == wParam )
00494             {
00495                 <span class="keywordflow">if</span>( m_bMinimized ) m_bActive = <span class="keyword">true</span>;
00496                 m_bMinimized = <span class="keyword">false</span>;
00497                 m_bMaximized = <span class="keyword">true</span>;
00498                 HandlePossibleSizeChange();
00499             }
00500             <span class="keywordflow">else</span> <span class="keywordflow">if</span>( SIZE_RESTORED == wParam )
00501             {
00502                 <span class="keywordflow">if</span>( m_bMaximized )
00503                 {
00504                     m_bMaximized = <span class="keyword">false</span>;
00505                     HandlePossibleSizeChange();
00506                 }
00507                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>( m_bMinimized)
00508                 {
00509                     m_bActive = <span class="keyword">true</span>;
00510                     m_bMinimized = <span class="keyword">false</span>;
00511                     HandlePossibleSizeChange();
00512                 }
00513                 <span class="keywordflow">else</span>
00514                 {
00515                     <span class="comment">// If we're neither maximized nor minimized, the window size </span>
00516                     <span class="comment">// is changing by the user dragging the window edges.  In this </span>
00517                     <span class="comment">// case, we don't reset the device yet -- we wait until the </span>
00518                     <span class="comment">// user stops dragging, and a WM_EXITSIZEMOVE message comes.</span>
00519                 }
00520             }
00521             <span class="keywordflow">break</span>;
00522 
00523         <span class="keywordflow">case</span> WM_EXITSIZEMOVE:
00524             m_bActive = <span class="keyword">true</span>;
00525             HandlePossibleSizeChange();
00526             <span class="keywordflow">break</span>;
00527 
00528         <span class="keywordflow">case</span> WM_SETCURSOR:
00529             <span class="comment">// Turn off Windows cursor in fullscreen mode</span>
00530             <span class="keywordflow">if</span>( m_bActive &amp;&amp; !m_bWindowed )
00531             {
00532                 SetCursor( NULL );
00533                 <span class="keywordflow">if</span>( m_bShowCursorWhenFullscreen )
00534                     m_pDevice-&gt;ShowCursor( <span class="keyword">true</span> );
00535                 <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// prevent Windows from setting cursor to window class cursor</span>
00536             }
00537             <span class="keywordflow">break</span>;
00538 
00539          <span class="keywordflow">case</span> WM_MOUSEMOVE:
00540             <span class="keywordflow">if</span>( m_bActive &amp;&amp; m_pDevice != NULL )
00541             {
00542                 POINT ptCursor;
00543                 GetCursorPos( &amp;ptCursor );
00544                 <span class="keywordflow">if</span>( !m_bWindowed )
00545                     ScreenToClient( m_hWnd, &amp;ptCursor );
00546                 m_pDevice-&gt;SetCursorPosition( ptCursor.x, ptCursor.y, 0 );
00547             }
00548             <span class="keywordflow">break</span>;
00549 
00550        <span class="keywordflow">case</span> WM_ENTERMENULOOP:
00551             m_bActive = <span class="keyword">false</span>;
00552             <span class="keywordflow">break</span>;
00553 
00554         <span class="keywordflow">case</span> WM_EXITMENULOOP:
00555             m_bActive = <span class="keyword">true</span>;
00556             <span class="keywordflow">break</span>;
00557 
00558         <span class="keywordflow">case</span> WM_NCHITTEST:
00559             <span class="comment">// Prevent the user from selecting the menu in fullscreen mode</span>
00560             <span class="keywordflow">if</span>( !m_bWindowed )
00561                 <span class="keywordflow">return</span> HTCLIENT;
00562             <span class="keywordflow">break</span>;
00563 
00564         <span class="keywordflow">case</span> WM_POWERBROADCAST:
00565             <span class="keywordflow">switch</span>( wParam )
00566             {
00567 <span class="preprocessor">                #ifndef PBT_APMQUERYSUSPEND</span>
00568 <span class="preprocessor"></span><span class="preprocessor">                    #define PBT_APMQUERYSUSPEND 0x0000</span>
00569 <span class="preprocessor"></span><span class="preprocessor">                #endif</span>
00570 <span class="preprocessor"></span>                <span class="keywordflow">case</span> PBT_APMQUERYSUSPEND:
00571                     <span class="comment">// At this point, the app should save any data for open</span>
00572                     <span class="comment">// network connections, files, etc., and prepare to go into</span>
00573                     <span class="comment">// a suspended mode.</span>
00574                     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00575 
00576 <span class="preprocessor">                #ifndef PBT_APMRESUMESUSPEND</span>
00577 <span class="preprocessor"></span><span class="preprocessor">                    #define PBT_APMRESUMESUSPEND 0x0007</span>
00578 <span class="preprocessor"></span><span class="preprocessor">                #endif</span>
00579 <span class="preprocessor"></span>                <span class="keywordflow">case</span> PBT_APMRESUMESUSPEND:
00580                     <span class="comment">// At this point, the app should recover any data, network</span>
00581                     <span class="comment">// connections, files, etc., and resume running from when</span>
00582                     <span class="comment">// the app was suspended.</span>
00583                     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00584             }
00585             <span class="keywordflow">break</span>;
00586 
00587         <span class="keywordflow">case</span> WM_SYSCOMMAND:
00588             <span class="comment">// Prevent moving/sizing and power loss in fullscreen mode</span>
00589             <span class="keywordflow">switch</span>( wParam )
00590             {
00591                 <span class="keywordflow">case</span> SC_MOVE:
00592                 <span class="keywordflow">case</span> SC_SIZE:
00593                 <span class="keywordflow">case</span> SC_MAXIMIZE:
00594                 <span class="keywordflow">case</span> SC_KEYMENU:
00595                 <span class="keywordflow">case</span> SC_MONITORPOWER:
00596                     <span class="keywordflow">if</span>( <span class="keyword">false</span> == m_bWindowed )
00597                         <span class="keywordflow">return</span> 1;
00598                     <span class="keywordflow">break</span>;
00599             }
00600             <span class="keywordflow">break</span>;
00601 
00602         <span class="keywordflow">case</span> WM_COMMAND:
00603             <span class="keywordflow">switch</span>( LOWORD(wParam) )
00604             {
00605                 <span class="keywordflow">case</span> IDM_TOGGLESTART:
00606                     <span class="comment">// Toggle frame movement</span>
00607                     m_bFrameMoving = !m_bFrameMoving;
00608                     DXUtil_Timer( m_bFrameMoving ? TIMER_START : TIMER_STOP );
00609                     <span class="keywordflow">break</span>;
00610 
00611                 <span class="keywordflow">case</span> IDM_SINGLESTEP:
00612                     <span class="comment">// Single-step frame movement</span>
00613                     <span class="keywordflow">if</span>( <span class="keyword">false</span> == m_bFrameMoving )
00614                         DXUtil_Timer( TIMER_ADVANCE );
00615                     <span class="keywordflow">else</span>
00616                         DXUtil_Timer( TIMER_STOP );
00617                     m_bFrameMoving = <span class="keyword">false</span>;
00618                     m_bSingleStep  = <span class="keyword">true</span>;
00619                     <span class="keywordflow">break</span>;
00620 
00621                 <span class="keywordflow">case</span> IDM_CHANGEDEVICE:
00622                     <span class="comment">// Prompt the user to select a new device or mode</span>
00623                     m_bActive = <span class="keyword">false</span>;
00624                     UserSelectNewDevice();
00625                     m_bActive = <span class="keyword">true</span>;
00626                     <span class="keywordflow">return</span> 0;
00627 
00628                 <span class="keywordflow">case</span> IDM_TOGGLEFULLSCREEN:
00629                     <span class="comment">// Toggle the fullscreen/window mode</span>
00630                     m_bActive = <span class="keyword">false</span>;
00631                     <span class="keywordflow">if</span>( FAILED( ToggleFullscreen() ) )
00632                         DisplayErrorMsg( D3DAPPERR_RESETFAILED, MSGERR_APPMUSTEXIT );
00633                     m_bActive = <span class="keyword">true</span>;                        
00634                     <span class="keywordflow">return</span> 0;
00635 
00636                 <span class="keywordflow">case</span> IDM_EXIT:
00637                     <span class="comment">// received key/menu command to exit app</span>
00638                     SendMessage( hWnd, WM_CLOSE, 0, 0 );
00639                     <span class="keywordflow">return</span> 0;
00640             }
00641             <span class="keywordflow">break</span>;
00642 
00643         <span class="keywordflow">case</span> WM_ACTIVATE: 
00644             m_bActive = ( wParam != WA_INACTIVE );
00645             <span class="keywordflow">break</span>;
00646         <span class="keywordflow">case</span> WM_CLOSE:
00647             Cleanup3DEnvironment();
00648             SAFE_RELEASE( m_pD3D );
00649             FinalCleanup();
00650             DestroyWindow( hWnd );
00651             PostQuitMessage(0);
00652             m_hWnd = NULL;
00653             <span class="keywordflow">return</span> 0;
00654     }
00655 
00656     <span class="keywordflow">return</span> DefWindowProc( hWnd, uMsg, wParam, lParam );
00657 } <span class="comment">// D3DApplication::MsgProc</span>
00658 
00659 <span class="comment">//-----------------------------------------------------------------------------</span>
00660 <span class="comment">// Name: HandlePossibleSizeChange()</span>
00661 <span class="comment">// Desc: Reset the device if the client area size has changed.</span>
00662 <span class="comment">//-----------------------------------------------------------------------------</span>
00663 HRESULT D3DApplication::HandlePossibleSizeChange()
00664 {
00665     HRESULT hr = S_OK;
00666     RECT rcClientOld;
00667     rcClientOld = m_rcWindowClient;
00668 
00669     <span class="keywordflow">if</span>( m_bIgnoreSizeChange )
00670         <span class="keywordflow">return</span> S_OK;
00671 
00672     <span class="comment">// Update window properties</span>
00673     GetWindowRect( m_hWnd, &amp;m_rcWindowBounds );
00674     GetClientRect( m_hWnd, &amp;m_rcWindowClient );
00675 
00676     <span class="keywordflow">if</span>( rcClientOld.right - rcClientOld.left !=
00677         m_rcWindowClient.right - m_rcWindowClient.left ||
00678         rcClientOld.bottom - rcClientOld.top !=
00679         m_rcWindowClient.bottom - m_rcWindowClient.top)
00680     {
00681         <span class="comment">// A new window size will require a new backbuffer</span>
00682         <span class="comment">// size, so the 3D structures must be changed accordingly.</span>
00683         m_bActive = <span class="keyword">false</span>;
00684 
00685         m_d3dpp.BackBufferWidth  = m_rcWindowClient.right - m_rcWindowClient.left;
00686         m_d3dpp.BackBufferHeight = m_rcWindowClient.bottom - m_rcWindowClient.top;
00687 
00688         m_d3dSettings.Windowed_Width = m_d3dpp.BackBufferWidth;
00689         m_d3dSettings.Windowed_Height = m_d3dpp.BackBufferHeight;
00690     
00691         <span class="keywordflow">if</span>( m_pDevice != NULL )
00692         {
00693             <span class="comment">// Reset the 3D environment</span>
00694             <span class="keywordflow">if</span>( FAILED( hr = Reset3DEnvironment() ) )
00695             {
00696                 <span class="keywordflow">if</span>( hr == D3DERR_DEVICELOST )
00697                 {
00698                     m_bDeviceLost = <span class="keyword">true</span>;
00699                     hr = S_OK;
00700                 }
00701                 <span class="keywordflow">else</span>
00702                 {
00703                     <span class="keywordflow">if</span>( hr != D3DERR_OUTOFVIDEOMEMORY )
00704                         hr = D3DAPPERR_RESETFAILED;
00705 
00706                     DisplayErrorMsg( hr, MSGERR_APPMUSTEXIT );
00707                 }
00708             }
00709         }
00710         m_bActive = <span class="keyword">true</span>;
00711     }
00712     <span class="keywordflow">return</span> hr;
00713 } <span class="comment">// D3DApplication::HandlePossibleSizeChange</span>
00714 
00715 <span class="comment">//-----------------------------------------------------------------------------</span>
00716 <span class="comment">// Name: Initialize3DEnvironment()</span>
00717 <span class="comment">// Desc: Usually this function is not overridden.  Here's what this function does:</span>
00718 <span class="comment">//       - Sets the windowed flag to be either windowed or fullscreen</span>
00719 <span class="comment">//       - Sets parameters for z-buffer depth and back buffer</span>
00720 <span class="comment">//       - Creates the D3D device</span>
00721 <span class="comment">//       - Sets the window position (if windowed, that is)</span>
00722 <span class="comment">//       - Makes some determinations as to the abilites of the driver (HAL, etc)</span>
00723 <span class="comment">//       - Sets up some cursor stuff</span>
00724 <span class="comment">//       - Calls InitDeviceObjects()</span>
00725 <span class="comment">//       - Calls RestoreDeviceObjects()</span>
00726 <span class="comment">//       - If all goes well, m_bActive is set to TRUE, and the function returns</span>
00727 <span class="comment">//       - Otherwise, initialization is reattempted using the reference device</span>
00728 <span class="comment">//-----------------------------------------------------------------------------</span>
00729 
00730 
00731 HRESULT D3DApplication::Initialize3DEnvironment()
00732 {
00733     HRESULT hr;
00734 
00735     D3DAdapterInfo* pAdapterInfo = m_d3dSettings.PAdapterInfo();
00736     D3DDeviceInfo* pDeviceInfo = m_d3dSettings.PDeviceInfo();
00737 
00738     m_bWindowed = m_d3dSettings.m_bIsWindowed;
00739 
00740     <span class="comment">// Prepare window for possible windowed/fullscreen change</span>
00741     AdjustWindowForChange();
00742 
00743     <span class="comment">// Set up the presentation parameters</span>
00744     BuildPresentParamsFromSettings();
00745 
00746     <span class="keywordflow">if</span>( pDeviceInfo-&gt;m_Caps.PrimitiveMiscCaps &amp; D3DPMISCCAPS_NULLREFERENCE )
00747     {
00748         <span class="comment">// Warn user about null ref device that can't render anything</span>
00749         DisplayErrorMsg( D3DAPPERR_NULLREFDEVICE, 0 );
00750     }
00751 
00752     DWORD behaviorFlags;
00753     <span class="keywordflow">if</span> (m_d3dSettings.GetVertexProcessingType() == vpSoftware)
00754         behaviorFlags = D3DCREATE_SOFTWARE_VERTEXPROCESSING;
00755     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_d3dSettings.GetVertexProcessingType() == vpMixed)
00756         behaviorFlags = D3DCREATE_MIXED_VERTEXPROCESSING;
00757     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_d3dSettings.GetVertexProcessingType() == vpHardware)
00758         behaviorFlags = D3DCREATE_HARDWARE_VERTEXPROCESSING;
00759     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_d3dSettings.GetVertexProcessingType() == vpPureHardware)
00760         behaviorFlags = D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_PUREDEVICE;
00761     <span class="keywordflow">else</span>
00762         behaviorFlags = 0; <span class="comment">// TODO: throw exception</span>
00763 
00764     <span class="comment">// Add multithreaded flag if requested by app</span>
00765     <span class="keywordflow">if</span>( m_bCreateMultithreadDevice )
00766         behaviorFlags |= D3DCREATE_MULTITHREADED;
00767 
00768     <span class="comment">// Create the device</span>
00769     <span class="comment">//</span>
00770     <span class="comment">// Set default settings</span>
00771     UINT AdapterToUse=D3DADAPTER_DEFAULT; 
00772     D3DDEVTYPE DeviceType=D3DDEVTYPE_HAL; 
00773 <span class="preprocessor">#ifdef SHIPPING_VERSION </span>
00774 <span class="preprocessor"></span>    <span class="comment">// When building a shipping version, disable NVPerfHUD (opt-out) </span>
00775 <span class="preprocessor">#else // Look for 'NVIDIA NVPerfHUD' adapter </span>
00776 <span class="preprocessor"></span>    <span class="comment">// If it is present, override default settings </span>
00777     <span class="keywordflow">for</span> (UINT Adapter=0;Adapter&lt;m_pD3D-&gt;GetAdapterCount();Adapter++) { 
00778         D3DADAPTER_IDENTIFIER9 Identifier; 
00779         HRESULT Res; 
00780         Res = m_pD3D-&gt;GetAdapterIdentifier(Adapter,0,&amp;Identifier); 
00781         <span class="keywordflow">if</span> (strcmp(Identifier.Description,<span class="stringliteral">"NVIDIA NVPerfHUD"</span>) == 0) { 
00782             AdapterToUse=Adapter; 
00783             DeviceType=D3DDEVTYPE_REF; 
00784             <span class="keywordflow">break</span>; 
00785         } 
00786     }
00787 <span class="preprocessor">#endif </span>
00788 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (FAILED(m_pD3D-&gt;CreateDevice( AdapterToUse, DeviceType,
00789         m_hWndFocus, D3DCREATE_HARDWARE_VERTEXPROCESSING, &amp;m_d3dpp, &amp;m_pDevice) ) ) 
00790     { 
00791         <span class="keywordflow">return</span> E_FAIL; 
00792     }
00793 
00794     <span class="comment">//hr = m_pD3D-&gt;CreateDevice( m_d3dSettings.Ordinal(), pDeviceInfo-&gt;m_DevType,</span>
00795     <span class="comment">//                           m_hWndFocus, behaviorFlags, &amp;m_d3dpp, &amp;m_pDevice );</span>
00796     <span class="comment">//</span>
00797     <span class="comment">//if( SUCCEEDED(hr) )</span>
00798     {
00799         <span class="comment">// When moving from fullscreen to windowed mode, it is important to</span>
00800         <span class="comment">// adjust the window size after recreating the device rather than</span>
00801         <span class="comment">// beforehand to ensure that you get the window size you want.  For</span>
00802         <span class="comment">// example, when switching from 640x480 fullscreen to windowed with</span>
00803         <span class="comment">// a 1000x600 window on a 1024x768 desktop, it is impossible to set</span>
00804         <span class="comment">// the window size to 1000x600 until after the display mode has</span>
00805         <span class="comment">// changed to 1024x768, because windows cannot be larger than the</span>
00806         <span class="comment">// desktop.</span>
00807         <span class="keywordflow">if</span>( m_bWindowed )
00808         {
00809             SetWindowPos( m_hWnd, HWND_NOTOPMOST,
00810                           m_rcWindowBounds.left, m_rcWindowBounds.top,
00811                           ( m_rcWindowBounds.right - m_rcWindowBounds.left ),
00812                           ( m_rcWindowBounds.bottom - m_rcWindowBounds.top ),
00813                           SWP_SHOWWINDOW );
00814         }
00815 
00816         <span class="comment">// Store device Caps</span>
00817         m_pDevice-&gt;GetDeviceCaps( &amp;m_Caps );
00818         m_dwCreateFlags = behaviorFlags;
00819 
00820         <span class="comment">// Store device description</span>
00821         <span class="keywordflow">if</span>( pDeviceInfo-&gt;m_DevType == D3DDEVTYPE_REF )
00822             lstrcpy( m_strDeviceStats, TEXT(<span class="stringliteral">"REF"</span>) );
00823         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( pDeviceInfo-&gt;m_DevType == D3DDEVTYPE_HAL )
00824             lstrcpy( m_strDeviceStats, TEXT(<span class="stringliteral">"HAL"</span>) );
00825         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( pDeviceInfo-&gt;m_DevType == D3DDEVTYPE_SW )
00826             lstrcpy( m_strDeviceStats, TEXT(<span class="stringliteral">"SW"</span>) );
00827 
00828         <span class="keywordflow">if</span>( behaviorFlags &amp; D3DCREATE_HARDWARE_VERTEXPROCESSING &amp;&amp;
00829             behaviorFlags &amp; D3DCREATE_PUREDEVICE )
00830         {
00831             <span class="keywordflow">if</span>( pDeviceInfo-&gt;m_DevType == D3DDEVTYPE_HAL )
00832                 lstrcat( m_strDeviceStats, TEXT(<span class="stringliteral">" (pure hw vp)"</span>) );
00833             <span class="keywordflow">else</span>
00834                 lstrcat( m_strDeviceStats, TEXT(<span class="stringliteral">" (simulated pure hw vp)"</span>) );
00835         }
00836         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( behaviorFlags &amp; D3DCREATE_HARDWARE_VERTEXPROCESSING )
00837         {
00838             <span class="keywordflow">if</span>( pDeviceInfo-&gt;m_DevType == D3DDEVTYPE_HAL )
00839                 lstrcat( m_strDeviceStats, TEXT(<span class="stringliteral">" (hw vp)"</span>) );
00840             <span class="keywordflow">else</span>
00841                 lstrcat( m_strDeviceStats, TEXT(<span class="stringliteral">" (simulated hw vp)"</span>) );
00842         }
00843         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( behaviorFlags &amp; D3DCREATE_MIXED_VERTEXPROCESSING )
00844         {
00845             <span class="keywordflow">if</span>( pDeviceInfo-&gt;m_DevType == D3DDEVTYPE_HAL )
00846                 lstrcat( m_strDeviceStats, TEXT(<span class="stringliteral">" (mixed vp)"</span>) );
00847             <span class="keywordflow">else</span>
00848                 lstrcat( m_strDeviceStats, TEXT(<span class="stringliteral">" (simulated mixed vp)"</span>) );
00849         }
00850         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( behaviorFlags &amp; D3DCREATE_SOFTWARE_VERTEXPROCESSING )
00851         {
00852             lstrcat( m_strDeviceStats, TEXT(<span class="stringliteral">" (sw vp)"</span>) );
00853         }
00854 
00855         <span class="keywordflow">if</span>( pDeviceInfo-&gt;m_DevType == D3DDEVTYPE_HAL )
00856         {
00857             <span class="comment">// Be sure not to overflow m_strDeviceStats when appending the adapter </span>
00858             <span class="comment">// description, since it can be long.  Note that the adapter description</span>
00859             <span class="comment">// is initially CHAR and must be converted to TCHAR.</span>
00860             lstrcat( m_strDeviceStats, TEXT(<span class="stringliteral">": "</span>) );
00861             <span class="keyword">const</span> <span class="keywordtype">int</span> cchDesc = <span class="keyword">sizeof</span>(pAdapterInfo-&gt;m_Identifier.Description);
00862             TCHAR szDescription[cchDesc];
00863             DXUtil_ConvertAnsiStringToGenericCch( szDescription, 
00864                 pAdapterInfo-&gt;m_Identifier.Description, cchDesc );
00865             <span class="keywordtype">int</span> maxAppend = <span class="keyword">sizeof</span>(m_strDeviceStats) / <span class="keyword">sizeof</span>(TCHAR) -
00866                 lstrlen( m_strDeviceStats ) - 1;
00867             _tcsncat( m_strDeviceStats, szDescription, maxAppend );
00868         }
00869 
00870         <span class="comment">// Store render target surface desc</span>
00871         LPDIRECT3DSURFACE9 pBackBuffer = NULL;
00872         m_pDevice-&gt;GetBackBuffer( 0, 0, D3DBACKBUFFER_TYPE_MONO, &amp;pBackBuffer );
00873         pBackBuffer-&gt;GetDesc( &amp;m_d3dsdBackBuffer );
00874         pBackBuffer-&gt;Release();
00875 
00876         <span class="comment">// Set up the fullscreen cursor</span>
00877         <span class="keywordflow">if</span>( m_bShowCursorWhenFullscreen &amp;&amp; !m_bWindowed )
00878         {
00879             HCURSOR hCursor;
00880 <span class="preprocessor">#ifdef _WIN64</span>
00881 <span class="preprocessor"></span>            hCursor = (HCURSOR)GetClassLongPtr( m_hWnd, GCLP_HCURSOR );
00882 <span class="preprocessor">#else</span>
00883 <span class="preprocessor"></span>            hCursor = (HCURSOR)ULongToHandle( GetClassLong( m_hWnd, GCL_HCURSOR ) );
00884 <span class="preprocessor">#endif</span>
00885 <span class="preprocessor"></span>            D3DUtil_SetDeviceCursor( m_pDevice, hCursor, <span class="keyword">true</span> );
00886             m_pDevice-&gt;ShowCursor( <span class="keyword">true</span> );
00887         }
00888 
00889         <span class="comment">// Confine cursor to fullscreen window</span>
00890         <span class="keywordflow">if</span>( m_bClipCursorWhenFullscreen )
00891         {
00892             <span class="keywordflow">if</span> (!m_bWindowed )
00893             {
00894                 RECT rcWindow;
00895                 GetWindowRect( m_hWnd, &amp;rcWindow );
00896                 ClipCursor( &amp;rcWindow );
00897             }
00898             <span class="keywordflow">else</span>
00899             {
00900                 ClipCursor( NULL );
00901             }
00902         }
00903 
00904         <span class="comment">// Initialize the app's device-dependent objects</span>
00905         hr = InitDeviceObjects();
00906         <span class="keywordflow">if</span>( FAILED(hr) )
00907         {
00908             DeleteDeviceObjects();
00909         }
00910         <span class="keywordflow">else</span>
00911         {
00912             m_bDeviceObjectsInited = <span class="keyword">true</span>;
00913             hr = RestoreDeviceObjects();
00914             <span class="keywordflow">if</span>( FAILED(hr) )
00915             {
00916                 InvalidateDeviceObjects();
00917             }
00918             <span class="keywordflow">else</span>
00919             {
00920                 m_bDeviceObjectsRestored = <span class="keyword">true</span>;
00921                 <span class="keywordflow">return</span> S_OK;
00922             }
00923         }
00924 
00925         <span class="comment">// Cleanup before we try again</span>
00926         Cleanup3DEnvironment();
00927     }
00928 
00929     <span class="comment">// If that failed, fall back to the reference rasterizer</span>
00930     <span class="keywordflow">if</span> (hr != D3DAPPERR_MEDIANOTFOUND &amp;&amp; 
00931         hr != HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) &amp;&amp; 
00932         pDeviceInfo-&gt;m_DevType == D3DDEVTYPE_HAL)
00933     {
00934         <span class="keywordflow">if</span> (FindBestWindowedMode(<span class="keyword">false</span>, <span class="keyword">true</span>))
00935         {
00936             m_bWindowed = <span class="keyword">true</span>;
00937             AdjustWindowForChange();
00938             <span class="comment">// Make sure main window isn't topmost, so error message is visible</span>
00939             SetWindowPos( m_hWnd, HWND_NOTOPMOST,
00940                           m_rcWindowBounds.left, m_rcWindowBounds.top,
00941                           ( m_rcWindowBounds.right - m_rcWindowBounds.left ),
00942                           ( m_rcWindowBounds.bottom - m_rcWindowBounds.top ),
00943                           SWP_SHOWWINDOW );
00944 
00945             <span class="comment">// Let the user know we are switching from HAL to the reference rasterizer</span>
00946             <span class="comment">//DisplayErrorMsg( hr, MSGWARN_SWITCHEDTOREF );</span>
00947 
00948             hr = Initialize3DEnvironment();
00949         }
00950     }
00951     <span class="keywordflow">return</span> hr;
00952 } <span class="comment">// D3DApplication::Initialize3DEnvironment</span>
00953 
00954 <span class="comment">//-----------------------------------------------------------------------------</span>
00955 <span class="comment">// Name: BuildPresentParamsFromSettings()</span>
00956 <span class="comment">// Desc:</span>
00957 <span class="comment">//-----------------------------------------------------------------------------</span>
00958 <span class="keywordtype">void</span> D3DApplication::BuildPresentParamsFromSettings()
00959 {
00960     m_d3dpp.Windowed               = m_d3dSettings.m_bIsWindowed;
00961     m_d3dpp.BackBufferCount        = 1;
00962     m_d3dpp.MultiSampleType        = m_d3dSettings.MultisampleType();
00963     m_d3dpp.MultiSampleQuality     = m_d3dSettings.MultisampleQuality();
00964     m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;
00965     m_d3dpp.EnableAutoDepthStencil = m_d3dEnum.m_bUseZBuffer;
00966     m_d3dpp.hDeviceWindow          = m_hWnd;
00967     <span class="keywordflow">if</span> (m_d3dEnum.m_bUseZBuffer)
00968     {
00969         m_d3dpp.Flags              = D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL;
00970         m_d3dpp.AutoDepthStencilFormat = m_d3dSettings.DepthStencilBufferFormat();
00971     }
00972     <span class="keywordflow">else</span>
00973     {
00974         m_d3dpp.Flags              = 0;
00975     }
00976 
00977     <span class="keywordflow">if</span> (m_d3dSettings.DeviceClip()) m_d3dpp.Flags |= D3DPRESENTFLAG_DEVICECLIP;
00978     <span class="keywordflow">if</span> (m_bWindowed)
00979     {
00980         m_d3dpp.BackBufferWidth  = m_d3dSettings.Windowed_Width;
00981         m_d3dpp.BackBufferHeight = m_d3dSettings.Windowed_Height;
00982         m_d3dpp.BackBufferFormat = m_d3dSettings.BackBufferFormat();<span class="comment">//m_d3dSettings.PDeviceCombo()-&gt;m_BackBufferFormat;</span>
00983         m_d3dpp.FullScreen_RefreshRateInHz = 0;
00984         m_d3dpp.PresentationInterval = m_d3dSettings.PresentInterval();
00985     }
00986     <span class="keywordflow">else</span>
00987     {
00988         m_d3dpp.BackBufferWidth  = m_d3dSettings.DisplayMode().Width;
00989         m_d3dpp.BackBufferHeight = m_d3dSettings.DisplayMode().Height;
00990         m_d3dpp.BackBufferFormat = m_d3dSettings.BackBufferFormat();<span class="comment">//m_d3dSettings.PDeviceCombo()-&gt;m_BackBufferFormat;</span>
00991         m_d3dpp.FullScreen_RefreshRateInHz = m_d3dSettings.Fullscreen_DisplayMode.RefreshRate;
00992         m_d3dpp.PresentationInterval = m_d3dSettings.PresentInterval();
00993 
00994         <span class="keywordflow">if</span> (m_bAllowDialogBoxMode)
00995         {
00996             <span class="comment">// Make the back buffers lockable in fullscreen mode</span>
00997             <span class="comment">// so we can show dialog boxes via SetDialogBoxMode() </span>
00998             <span class="comment">// but since lockable back buffers incur a performance cost on </span>
00999             <span class="comment">// some graphics hardware configurations we'll only </span>
01000             <span class="comment">// enable lockable backbuffers where SetDialogBoxMode() would work.</span>
01001             <span class="keywordflow">if</span> ( (  m_d3dpp.BackBufferFormat == D3DFMT_X1R5G5B5 || 
01002                     m_d3dpp.BackBufferFormat == D3DFMT_R5G6B5 || 
01003                     m_d3dpp.BackBufferFormat == D3DFMT_X8R8G8B8 ) &amp;&amp;
01004                     ( m_d3dpp.MultiSampleType == D3DMULTISAMPLE_NONE ) &amp;&amp;
01005                     ( m_d3dpp.SwapEffect == D3DSWAPEFFECT_DISCARD ) )
01006             {
01007                 m_d3dpp.Flags |= D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;
01008             }
01009         }
01010     }
01011 } <span class="comment">// D3DApplication::BuildPresentParamsFromSettings</span>
01012 
01013 <span class="comment">//-----------------------------------------------------------------------------</span>
01014 <span class="comment">// Name: Reset3DEnvironment()</span>
01015 <span class="comment">// Desc: Usually this function is not overridden.  Here's what this function does:</span>
01016 <span class="comment">//       - Sets the windowed flag to be either windowed or fullscreen</span>
01017 <span class="comment">//       - Sets parameters for z-buffer depth and back buffer</span>
01018 <span class="comment">//       - Creates the D3D device</span>
01019 <span class="comment">//       - Sets the window position (if windowed, that is)</span>
01020 <span class="comment">//       - Makes some determinations as to the abilites of the driver (HAL, etc)</span>
01021 <span class="comment">//       - Sets up some cursor stuff</span>
01022 <span class="comment">//       - Calls InitDeviceObjects()</span>
01023 <span class="comment">//       - Calls RestoreDeviceObjects()</span>
01024 <span class="comment">//       - If all goes well, m_bActive is set to TRUE, and the function returns</span>
01025 <span class="comment">//       - Otherwise, initialization is reattempted using the reference device</span>
01026 <span class="comment">//-----------------------------------------------------------------------------</span>
01027 HRESULT D3DApplication::Reset3DEnvironment()
01028 {
01029     HRESULT hr;
01030 
01031     <span class="comment">// Release all vidmem objects</span>
01032     <span class="keywordflow">if</span> (m_bDeviceObjectsRestored)
01033     {
01034         m_bDeviceObjectsRestored = <span class="keyword">false</span>;
01035         InvalidateDeviceObjects();
01036     }
01037     <span class="comment">// Reset the device</span>
01038     <span class="keywordflow">if</span> (FAILED( hr = m_pDevice-&gt;Reset( &amp;m_d3dpp ) )) <span class="keywordflow">return</span> hr;
01039 
01040     <span class="comment">// Store render target surface desc</span>
01041     LPDIRECT3DSURFACE9 pBackBuffer;
01042     m_pDevice-&gt;GetBackBuffer( 0, 0, D3DBACKBUFFER_TYPE_MONO, &amp;pBackBuffer );
01043     pBackBuffer-&gt;GetDesc( &amp;m_d3dsdBackBuffer );
01044     pBackBuffer-&gt;Release();
01045 
01046     <span class="comment">// Set up the fullscreen cursor</span>
01047     <span class="keywordflow">if</span> (m_bShowCursorWhenFullscreen &amp;&amp; !m_bWindowed)
01048     {
01049         HCURSOR hCursor;
01050 <span class="preprocessor">#ifdef _WIN64</span>
01051 <span class="preprocessor"></span>        hCursor = (HCURSOR)GetClassLongPtr( m_hWnd, GCLP_HCURSOR );
01052 <span class="preprocessor">#else</span>
01053 <span class="preprocessor"></span>        hCursor = (HCURSOR)ULongToHandle( GetClassLong( m_hWnd, GCL_HCURSOR ) );
01054 <span class="preprocessor">#endif</span>
01055 <span class="preprocessor"></span>        D3DUtil_SetDeviceCursor( m_pDevice, hCursor, <span class="keyword">true</span> );
01056         m_pDevice-&gt;ShowCursor( <span class="keyword">true</span> );
01057     }
01058 
01059     <span class="comment">// Confine cursor to fullscreen window</span>
01060     <span class="keywordflow">if</span> (m_bClipCursorWhenFullscreen)
01061     {
01062         <span class="keywordflow">if</span> (!m_bWindowed)
01063         {
01064             RECT rcWindow;
01065             GetWindowRect( m_hWnd, &amp;rcWindow );
01066             ClipCursor( &amp;rcWindow );
01067         }
01068         <span class="keywordflow">else</span>
01069         {
01070             ClipCursor( NULL );
01071         }
01072     }
01073 
01074     <span class="comment">// Initialize the app's device-dependent objects</span>
01075     hr = RestoreDeviceObjects();
01076     <span class="keywordflow">if</span> (FAILED(hr))
01077     {
01078         InvalidateDeviceObjects();
01079         <span class="keywordflow">return</span> hr;
01080     }
01081     m_bDeviceObjectsRestored = <span class="keyword">true</span>;
01082 
01083     <span class="comment">// If the app is paused, trigger the rendering of the current frame</span>
01084     <span class="keywordflow">if</span> (<span class="keyword">false</span> == m_bFrameMoving)
01085     {
01086         m_bSingleStep = <span class="keyword">true</span>;
01087         DXUtil_Timer( TIMER_START );
01088         DXUtil_Timer( TIMER_STOP );
01089     }
01090 
01091     <span class="keywordflow">return</span> S_OK;
01092 } <span class="comment">// D3DApplication::Reset3DEnvironment</span>
01093 
01094 <span class="comment">//-----------------------------------------------------------------------------</span>
01095 <span class="comment">// Name: ToggleFullScreen()</span>
01096 <span class="comment">// Desc: Called when user toggles between fullscreen mode and windowed mode</span>
01097 <span class="comment">//-----------------------------------------------------------------------------</span>
01098 HRESULT D3DApplication::ToggleFullscreen()
01099 {
01100     HRESULT hr;
01101     <span class="keywordtype">int</span> AdapterOrdinalOld = m_d3dSettings.Ordinal();
01102     D3DDEVTYPE DevTypeOld = m_d3dSettings.DevType();
01103 
01104     m_bActive = <span class="keyword">false</span>;
01105     m_bIgnoreSizeChange = <span class="keyword">true</span>;
01106 
01107     <span class="comment">// Toggle the windowed state</span>
01108     m_bWindowed = !m_bWindowed;
01109     m_d3dSettings.m_bIsWindowed = m_bWindowed;
01110 
01111     <span class="comment">// Prepare window for windowed/fullscreen change</span>
01112     AdjustWindowForChange();
01113 
01114     <span class="comment">// If m_Ordinal and m_DevType are the same, we can just do a Reset().</span>
01115     <span class="comment">// If they've changed, we need to do a complete device teardown/rebuild.</span>
01116     <span class="keywordflow">if</span> (m_d3dSettings.Ordinal() == AdapterOrdinalOld &amp;&amp;
01117         m_d3dSettings.DevType() == DevTypeOld)
01118     {
01119         <span class="comment">// Reset the 3D device</span>
01120         BuildPresentParamsFromSettings();
01121         hr = Reset3DEnvironment();
01122     }
01123     <span class="keywordflow">else</span>
01124     {
01125         Cleanup3DEnvironment();
01126         hr = Initialize3DEnvironment();
01127     }
01128 
01129     <span class="keywordflow">if</span> (FAILED( hr ))
01130     {
01131         <span class="keywordflow">if</span> (hr != D3DERR_OUTOFVIDEOMEMORY)
01132             hr = D3DAPPERR_RESETFAILED;
01133         m_bIgnoreSizeChange = <span class="keyword">false</span>;
01134         <span class="keywordflow">if</span> (!m_bWindowed)
01135         {
01136             <span class="comment">// Restore window type to windowed mode</span>
01137             m_bWindowed = !m_bWindowed;
01138             m_d3dSettings.m_bIsWindowed = m_bWindowed;
01139             AdjustWindowForChange();
01140             SetWindowPos( m_hWnd, HWND_NOTOPMOST,
01141                         m_rcWindowBounds.left, m_rcWindowBounds.top,
01142                         ( m_rcWindowBounds.right - m_rcWindowBounds.left ),
01143                         ( m_rcWindowBounds.bottom - m_rcWindowBounds.top ),
01144                         SWP_SHOWWINDOW );
01145         }
01146         <span class="keywordflow">return</span> DisplayErrorMsg( hr, MSGERR_APPMUSTEXIT );
01147     }
01148 
01149     m_bIgnoreSizeChange = <span class="keyword">false</span>;
01150 
01151     <span class="comment">// When moving from fullscreen to windowed mode, it is important to</span>
01152     <span class="comment">// adjust the window size after resetting the device rather than</span>
01153     <span class="comment">// beforehand to ensure that you get the window size you want.  For</span>
01154     <span class="comment">// example, when switching from 640x480 fullscreen to windowed with</span>
01155     <span class="comment">// a 1000x600 window on a 1024x768 desktop, it is impossible to set</span>
01156     <span class="comment">// the window size to 1000x600 until after the display mode has</span>
01157     <span class="comment">// changed to 1024x768, because windows cannot be larger than the</span>
01158     <span class="comment">// desktop.</span>
01159     <span class="keywordflow">if</span> (m_bWindowed)
01160     {
01161         SetWindowPos( m_hWnd, HWND_NOTOPMOST,
01162                       m_rcWindowBounds.left, m_rcWindowBounds.top,
01163                       ( m_rcWindowBounds.right - m_rcWindowBounds.left ),
01164                       ( m_rcWindowBounds.bottom - m_rcWindowBounds.top ),
01165                       SWP_SHOWWINDOW );
01166     }
01167 
01168     GetClientRect( m_hWnd, &amp;m_rcWindowClient );  <span class="comment">// Update our copy</span>
01169 
01170     m_bActive = <span class="keyword">true</span>;
01171     <span class="keywordflow">return</span> S_OK;
01172 } <span class="comment">// D3DApplication::ToggleFullscreen</span>
01173 
01174 <span class="comment">//-----------------------------------------------------------------------------</span>
01175 <span class="comment">// Name: ForceWindowed()</span>
01176 <span class="comment">// Desc: Switch to a windowed mode, even if that means picking a new device</span>
01177 <span class="comment">//       and/or adapter</span>
01178 <span class="comment">//-----------------------------------------------------------------------------</span>
01179 HRESULT D3DApplication::ForceWindowed()
01180 {
01181     HRESULT hr;
01182 
01183     <span class="keywordflow">if</span> (m_bWindowed) <span class="keywordflow">return</span> S_OK;
01184     <span class="keywordflow">if</span> (!FindBestWindowedMode( <span class="keyword">false</span>, <span class="keyword">false</span> ))
01185     {
01186         <span class="keywordflow">return</span> E_FAIL;
01187     }
01188     m_bWindowed = <span class="keyword">true</span>;
01189 
01190     <span class="comment">// Now destroy the current 3D device objects, then reinitialize</span>
01191     m_bActive = <span class="keyword">false</span>;
01192 
01193     <span class="comment">// Release all scene objects that will be re-created for the new device</span>
01194     Cleanup3DEnvironment();
01195 
01196     <span class="comment">// Create the new device</span>
01197     <span class="keywordflow">if</span> (FAILED( hr = Initialize3DEnvironment() )) <span class="keywordflow">return</span> DisplayErrorMsg( hr, MSGERR_APPMUSTEXIT );
01198 
01199     m_bActive = <span class="keyword">true</span>;
01200     <span class="keywordflow">return</span> S_OK;
01201 } <span class="comment">// D3DApplication::ForceWindowed</span>
01202 
01203 <span class="comment">//-----------------------------------------------------------------------------</span>
01204 <span class="comment">// Name: AdjustWindowForChange()</span>
01205 <span class="comment">// Desc: Prepare the window for a possible change between windowed mode and</span>
01206 <span class="comment">//       fullscreen mode.  This function is virtual and thus can be overridden</span>
01207 <span class="comment">//       to provide different behavior, such as switching to an entirely</span>
01208 <span class="comment">//       different window for fullscreen mode (as in the MFC sample apps).</span>
01209 <span class="comment">//-----------------------------------------------------------------------------</span>
01210 HRESULT D3DApplication::AdjustWindowForChange()
01211 {
01212     <span class="keywordflow">if</span> (m_bWindowed)
01213     {
01214         <span class="comment">// Set windowed-mode style</span>
01215         SetWindowLong( m_hWnd, GWL_STYLE, m_dwWindowStyle );
01216         <span class="keywordflow">if</span> (m_hMenu != NULL)
01217         {
01218             SetMenu( m_hWnd, m_hMenu );
01219             m_hMenu = NULL;
01220         }
01221     }
01222     <span class="keywordflow">else</span>
01223     {
01224         <span class="comment">// Set fullscreen-mode style</span>
01225         SetWindowLong( m_hWnd, GWL_STYLE, WS_POPUP|WS_SYSMENU|WS_VISIBLE );
01226         <span class="keywordflow">if</span> (m_hMenu == NULL)
01227         {
01228             m_hMenu = GetMenu( m_hWnd );
01229             SetMenu( m_hWnd, NULL );
01230         }
01231     }
01232     <span class="keywordflow">return</span> S_OK;
01233 } <span class="comment">// D3DApplication::AdjustWindowForChange</span>
01234 
01235 <span class="comment">//-----------------------------------------------------------------------------</span>
01236 <span class="comment">// Name: UserSelectNewDevice()</span>
01237 <span class="comment">// Desc: Displays a dialog so the user can select a new adapter, device, or</span>
01238 <span class="comment">//       display mode, and then recreates the 3D environment if needed</span>
01239 <span class="comment">//-----------------------------------------------------------------------------</span>
01240 HRESULT D3DApplication::UserSelectNewDevice()
01241 {
01242     HRESULT hr;
01243     <span class="keywordtype">bool</span> bDialogBoxMode = <span class="keyword">false</span>;
01244     <span class="keywordtype">bool</span> bOldWindowed = m_bWindowed;  <span class="comment">// Preserve original windowed flag</span>
01245 
01246     <span class="keywordflow">if</span> (m_bWindowed == <span class="keyword">false</span>)
01247     {
01248         <span class="comment">// See if the current settings comply with the rules</span>
01249         <span class="comment">// for allowing SetDialogBoxMode().  </span>
01250         <span class="keywordflow">if</span>( (m_d3dpp.BackBufferFormat == D3DFMT_X1R5G5B5 || m_d3dpp.BackBufferFormat == D3DFMT_R5G6B5 || m_d3dpp.BackBufferFormat == D3DFMT_X8R8G8B8 ) &amp;&amp;
01251             ( m_d3dpp.MultiSampleType == D3DMULTISAMPLE_NONE ) &amp;&amp;
01252             ( m_d3dpp.SwapEffect == D3DSWAPEFFECT_DISCARD ) &amp;&amp;
01253             ( (m_d3dpp.Flags &amp; D3DPRESENTFLAG_LOCKABLE_BACKBUFFER) == D3DPRESENTFLAG_LOCKABLE_BACKBUFFER ) &amp;&amp;
01254             ( (m_dwCreateFlags &amp; D3DCREATE_ADAPTERGROUP_DEVICE) != D3DCREATE_ADAPTERGROUP_DEVICE ) )
01255         {
01256             <span class="keywordflow">if</span> (SUCCEEDED( m_pDevice-&gt;SetDialogBoxMode( <span class="keyword">true</span> ) )) bDialogBoxMode = <span class="keyword">true</span>;
01257         }
01258 
01259         <span class="comment">// If SetDialogBoxMode(true) didn't work then we can't display dialogs  </span>
01260         <span class="comment">// in fullscreen mode so we'll go back to windowed mode</span>
01261         <span class="keywordflow">if</span> (FALSE == bDialogBoxMode)
01262         {
01263             <span class="keywordflow">if</span> (FAILED( ToggleFullscreen() ))
01264             {
01265                 DisplayErrorMsg( D3DAPPERR_RESETFAILED, MSGERR_APPMUSTEXIT );
01266                 <span class="keywordflow">return</span> E_FAIL;
01267             }
01268         }
01269     }
01270 
01271     <span class="comment">// The dialog should use the mode the sample runs in, not</span>
01272     <span class="comment">// the mode that the dialog runs in.</span>
01273     D3DSettings tempSettings = m_d3dSettings;
01274     tempSettings.m_bIsWindowed = bOldWindowed;
01275     CD3DSettingsDialog settingsDialog( &amp;m_d3dEnum, &amp;tempSettings);
01276     INT_PTR nResult = settingsDialog.ShowDialog( m_hWnd );
01277 
01278     <span class="comment">// Before creating the device, switch back to SetDialogBoxMode(false) </span>
01279     <span class="comment">// mode to allow the user to pick multisampling or backbuffer formats </span>
01280     <span class="comment">// not supported by SetDialogBoxMode(true) but typical apps wouldn't </span>
01281     <span class="comment">// need to switch back.</span>
01282     <span class="keywordflow">if</span> (bDialogBoxMode) m_pDevice-&gt;SetDialogBoxMode( <span class="keyword">false</span> );
01283 
01284     <span class="keywordflow">if</span> (nResult != IDOK)
01285     {
01286         <span class="comment">// If we had to switch mode to display the dialog, we</span>
01287         <span class="comment">// need to go back to the original mode the sample</span>
01288         <span class="comment">// was running in.</span>
01289         <span class="keywordflow">if</span>( bOldWindowed != m_bWindowed &amp;&amp; FAILED( ToggleFullscreen() ) )
01290         {
01291             DisplayErrorMsg( D3DAPPERR_RESETFAILED, MSGERR_APPMUSTEXIT );
01292             <span class="keywordflow">return</span> E_FAIL;
01293         }
01294 
01295         <span class="keywordflow">return</span> S_OK;
01296     }
01297 
01298     settingsDialog.GetFinalSettings( &amp;m_d3dSettings );
01299 
01300     m_bWindowed = m_d3dSettings.m_bIsWindowed;
01301 
01302     <span class="comment">// Release all scene objects that will be re-created for the new device</span>
01303     Cleanup3DEnvironment();
01304 
01305     <span class="comment">// Inform the display class of the change. It will internally</span>
01306     <span class="comment">// re-create valid surfaces, a d3ddevice, etc.</span>
01307     <span class="keywordflow">if</span> (FAILED( hr = Initialize3DEnvironment() ))
01308     {
01309         <span class="keywordflow">if</span> (hr != D3DERR_OUTOFVIDEOMEMORY)
01310             hr = D3DAPPERR_RESETFAILED;
01311         <span class="keywordflow">if</span> (!m_bWindowed)
01312         {
01313             <span class="comment">// Restore window type to windowed mode</span>
01314             m_bWindowed = !m_bWindowed;
01315             m_d3dSettings.m_bIsWindowed = m_bWindowed;
01316             AdjustWindowForChange();
01317             SetWindowPos( m_hWnd, HWND_NOTOPMOST,
01318                         m_rcWindowBounds.left, m_rcWindowBounds.top,
01319                         ( m_rcWindowBounds.right - m_rcWindowBounds.left ),
01320                         ( m_rcWindowBounds.bottom - m_rcWindowBounds.top ),
01321                         SWP_SHOWWINDOW );
01322         }
01323         <span class="keywordflow">return</span> DisplayErrorMsg( hr, MSGERR_APPMUSTEXIT );
01324     }
01325 
01326     <span class="comment">// If the app is paused, trigger the rendering of the current frame</span>
01327     <span class="keywordflow">if</span> (<span class="keyword">false</span> == m_bFrameMoving)
01328     {
01329         m_bSingleStep = <span class="keyword">true</span>;
01330         DXUtil_Timer( TIMER_START );
01331         DXUtil_Timer( TIMER_STOP );
01332     }
01333     <span class="keywordflow">return</span> S_OK;
01334 } <span class="comment">// D3DApplication::UserSelectNewDevice</span>
01335 
01336 <span class="comment">//-----------------------------------------------------------------------------</span>
01337 <span class="comment">// Name: UpdateStats()</span>
01338 <span class="comment">// Desc: </span>
01339 <span class="comment">//-----------------------------------------------------------------------------</span>
01340 <span class="keywordtype">void</span> D3DApplication::UpdateStats()
01341 {
01342     <span class="comment">// Keep track of the frame count</span>
01343     <span class="keyword">static</span> FLOAT fLastTime = 0.0f;
01344     <span class="keyword">static</span> DWORD dwFrames  = 0;
01345     FLOAT fTime = DXUtil_Timer( TIMER_GETABSOLUTETIME );
01346     ++dwFrames;
01347 
01348     <span class="comment">// Update the scene stats once per second</span>
01349     <span class="keywordflow">if</span>( fTime - fLastTime &gt; 1.0f )
01350     {
01351         m_fFPS    = dwFrames / (fTime - fLastTime);
01352         fLastTime = fTime;
01353         dwFrames  = 0;
01354 
01355         TCHAR strFmt[100];
01356         D3DFORMAT fmtAdapter = m_d3dSettings.DisplayMode().Format;
01357         <span class="keywordflow">if</span>( fmtAdapter == m_d3dsdBackBuffer.Format )
01358         {
01359             lstrcpyn( strFmt, D3DUtil_D3DFormatToString( fmtAdapter, <span class="keyword">false</span> ), 100 );
01360         }
01361         <span class="keywordflow">else</span>
01362         {
01363             _sntprintf( strFmt, 100, TEXT(<span class="stringliteral">"backbuf %s, adapter %s"</span>), 
01364                 D3DUtil_D3DFormatToString( m_d3dsdBackBuffer.Format, <span class="keyword">false</span> ), 
01365                 D3DUtil_D3DFormatToString( fmtAdapter, <span class="keyword">false</span> ) );
01366         }
01367         strFmt[99] = TEXT(<span class="charliteral">'\0'</span>);
01368 
01369         TCHAR strDepthFmt[100];
01370         <span class="keywordflow">if</span>( m_d3dEnum.m_bUseZBuffer )
01371         {
01372             _sntprintf( strDepthFmt, 100, TEXT(<span class="stringliteral">" (%s)"</span>), 
01373                 D3DUtil_D3DFormatToString( m_d3dSettings.DepthStencilBufferFormat(), <span class="keyword">false</span> ) );
01374             strDepthFmt[99] = TEXT(<span class="charliteral">'\0'</span>);
01375         }
01376         <span class="keywordflow">else</span>
01377         {
01378             <span class="comment">// No depth buffer</span>
01379             strDepthFmt[0] = TEXT(<span class="charliteral">'\0'</span>);
01380         }
01381 
01382         TCHAR* pstrMultiSample;
01383         <span class="keywordflow">switch</span>( m_d3dSettings.MultisampleType() )
01384         {
01385         <span class="keywordflow">case</span> D3DMULTISAMPLE_NONMASKABLE:  pstrMultiSample = TEXT(<span class="stringliteral">" (Nonmaskable Multisample)"</span>); <span class="keywordflow">break</span>;
01386         <span class="keywordflow">case</span> D3DMULTISAMPLE_2_SAMPLES:  pstrMultiSample = TEXT(<span class="stringliteral">" (2x Multisample)"</span>); <span class="keywordflow">break</span>;
01387         <span class="keywordflow">case</span> D3DMULTISAMPLE_3_SAMPLES:  pstrMultiSample = TEXT(<span class="stringliteral">" (3x Multisample)"</span>); <span class="keywordflow">break</span>;
01388         <span class="keywordflow">case</span> D3DMULTISAMPLE_4_SAMPLES:  pstrMultiSample = TEXT(<span class="stringliteral">" (4x Multisample)"</span>); <span class="keywordflow">break</span>;
01389         <span class="keywordflow">case</span> D3DMULTISAMPLE_5_SAMPLES:  pstrMultiSample = TEXT(<span class="stringliteral">" (5x Multisample)"</span>); <span class="keywordflow">break</span>;
01390         <span class="keywordflow">case</span> D3DMULTISAMPLE_6_SAMPLES:  pstrMultiSample = TEXT(<span class="stringliteral">" (6x Multisample)"</span>); <span class="keywordflow">break</span>;
01391         <span class="keywordflow">case</span> D3DMULTISAMPLE_7_SAMPLES:  pstrMultiSample = TEXT(<span class="stringliteral">" (7x Multisample)"</span>); <span class="keywordflow">break</span>;
01392         <span class="keywordflow">case</span> D3DMULTISAMPLE_8_SAMPLES:  pstrMultiSample = TEXT(<span class="stringliteral">" (8x Multisample)"</span>); <span class="keywordflow">break</span>;
01393         <span class="keywordflow">case</span> D3DMULTISAMPLE_9_SAMPLES:  pstrMultiSample = TEXT(<span class="stringliteral">" (9x Multisample)"</span>); <span class="keywordflow">break</span>;
01394         <span class="keywordflow">case</span> D3DMULTISAMPLE_10_SAMPLES: pstrMultiSample = TEXT(<span class="stringliteral">" (10x Multisample)"</span>); <span class="keywordflow">break</span>;
01395         <span class="keywordflow">case</span> D3DMULTISAMPLE_11_SAMPLES: pstrMultiSample = TEXT(<span class="stringliteral">" (11x Multisample)"</span>); <span class="keywordflow">break</span>;
01396         <span class="keywordflow">case</span> D3DMULTISAMPLE_12_SAMPLES: pstrMultiSample = TEXT(<span class="stringliteral">" (12x Multisample)"</span>); <span class="keywordflow">break</span>;
01397         <span class="keywordflow">case</span> D3DMULTISAMPLE_13_SAMPLES: pstrMultiSample = TEXT(<span class="stringliteral">" (13x Multisample)"</span>); <span class="keywordflow">break</span>;
01398         <span class="keywordflow">case</span> D3DMULTISAMPLE_14_SAMPLES: pstrMultiSample = TEXT(<span class="stringliteral">" (14x Multisample)"</span>); <span class="keywordflow">break</span>;
01399         <span class="keywordflow">case</span> D3DMULTISAMPLE_15_SAMPLES: pstrMultiSample = TEXT(<span class="stringliteral">" (15x Multisample)"</span>); <span class="keywordflow">break</span>;
01400         <span class="keywordflow">case</span> D3DMULTISAMPLE_16_SAMPLES: pstrMultiSample = TEXT(<span class="stringliteral">" (16x Multisample)"</span>); <span class="keywordflow">break</span>;
01401         <span class="keywordflow">default</span>:                        pstrMultiSample = TEXT(<span class="stringliteral">""</span>); <span class="keywordflow">break</span>;
01402         }
01403 
01404         <span class="keyword">const</span> <span class="keywordtype">int</span> cchMaxFrameStats = <span class="keyword">sizeof</span>(m_strFrameStats) / <span class="keyword">sizeof</span>(TCHAR);
01405         _sntprintf( m_strFrameStats, cchMaxFrameStats, _T(<span class="stringliteral">"%.02f fps (%dx%d), %s%s%s"</span>), m_fFPS,
01406                     m_d3dsdBackBuffer.Width, m_d3dsdBackBuffer.Height,
01407                     strFmt, strDepthFmt, pstrMultiSample );
01408         m_strFrameStats[cchMaxFrameStats - 1] = TEXT(<span class="charliteral">'\0'</span>);
01409     }
01410 } <span class="comment">// D3DApplication::UpdateStats</span>
01411 
01412 <span class="comment">//-----------------------------------------------------------------------------</span>
01413 <span class="comment">// Name: Cleanup3DEnvironment()</span>
01414 <span class="comment">// Desc: Cleanup scene objects</span>
01415 <span class="comment">//-----------------------------------------------------------------------------</span>
01416 <span class="keywordtype">void</span> D3DApplication::Cleanup3DEnvironment()
01417 {
01418     <span class="keywordflow">if</span>( m_pDevice != NULL )
01419     {
01420         <span class="keywordflow">if</span>( m_bDeviceObjectsRestored )
01421         {
01422             m_bDeviceObjectsRestored = <span class="keyword">false</span>;
01423             InvalidateDeviceObjects();
01424         }
01425         <span class="keywordflow">if</span>( m_bDeviceObjectsInited )
01426         {
01427             m_bDeviceObjectsInited = <span class="keyword">false</span>;
01428             DeleteDeviceObjects();
01429         }
01430 
01431         <span class="keywordflow">if</span> (m_pDevice-&gt;Release() &gt; 0)
01432         {
01433             DisplayErrorMsg( D3DAPPERR_NONZEROREFCOUNT, MSGERR_APPMUSTEXIT );
01434         }
01435         m_pDevice = NULL;
01436     }
01437 
01438     <span class="comment">//  restore desktop screen mode</span>
01439     <span class="keywordtype">int</span> devModeRes = ChangeDisplaySettings( &amp;m_InitialDesktopMode, 0 );
01440     <span class="keywordflow">if</span> (devModeRes != DISP_CHANGE_SUCCESSFUL)
01441     {
01442         Log.Error( <span class="stringliteral">"Could not restore desktop display mode"</span> );
01443     }
01444 
01445 } <span class="comment">// D3DApplication::Cleanup3DEnvironment</span>
01446 
01447 <span class="keywordtype">bool</span> D3DApplication::SupportsInstancing()
01448 {
01449     <span class="keyword">const</span> D3DCAPS9&amp; caps = GetCaps();
01450     <span class="keywordflow">if</span> (caps.VertexShaderVersion &gt;= D3DVS_VERSION( 3,0 )) <span class="keywordflow">return</span> <span class="keyword">true</span>;
01451     <span class="keywordflow">if</span> (caps.VertexShaderVersion &gt;= D3DVS_VERSION( 2,0 ))
01452     {
01453         <span class="comment">// Because ATI supports instancing (on some drivers) without vertex shader 3.0,</span>
01454         <span class="comment">// but its also not enabled by default, so we need to not only check for support</span>
01455         <span class="comment">// but enabled it if it is supported.</span>
01456         DWORD instanceSupport = MAKEFOURCC( <span class="charliteral">'I'</span>, <span class="charliteral">'N'</span>, <span class="charliteral">'S'</span>, <span class="charliteral">'T'</span> );
01457         <span class="keywordflow">if</span>(m_pD3D &amp;&amp; SUCCEEDED( m_pD3D-&gt;CheckDeviceFormat(  D3DADAPTER_DEFAULT, 
01458                                                             D3DDEVTYPE_HAL, 
01459                                                             D3DFMT_X8R8G8B8,
01460                                                             0, D3DRTYPE_SURFACE, 
01461                                                             (D3DFORMAT)instanceSupport ) ))
01462         {
01463             m_pDevice-&gt;SetRenderState(D3DRS_POINTSIZE, instanceSupport);
01464             <span class="keywordflow">return</span> <span class="keyword">true</span>;
01465         }
01466     }
01467     <span class="keywordflow">return</span> <span class="keyword">false</span>;
01468 } <span class="comment">// D3DApplication::SupportsInstancing</span>
01469 
01470 <span class="comment">//-----------------------------------------------------------------------------</span>
01471 <span class="comment">// Name: DisplayErrorMsg()</span>
01472 <span class="comment">// Desc: Displays error messages in a message box</span>
01473 <span class="comment">//-----------------------------------------------------------------------------</span>
01474 HRESULT D3DApplication::DisplayErrorMsg( HRESULT hr, DWORD dwType )
01475 {
01476     <span class="keyword">static</span> <span class="keywordtype">bool</span> s_bFatalErrorReported = <span class="keyword">false</span>;
01477     <span class="comment">// If a fatal error message has already been reported, the app</span>
01478     <span class="comment">// is already shutting down, so don't show more error messages.</span>
01479     <span class="keywordflow">if</span>( s_bFatalErrorReported ) <span class="keywordflow">return</span> hr;
01480 
01481     <span class="keywordflow">switch</span>( hr )
01482     {
01483         <span class="keywordflow">case</span> D3DAPPERR_NODIRECT3D:
01484             Log.Error( <span class="stringliteral">"Could not initialize Direct3D."</span> );
01485             <span class="keywordflow">break</span>;
01486 
01487         <span class="keywordflow">case</span> D3DAPPERR_NOCOMPATIBLEDEVICES:
01488             Log.Error( <span class="stringliteral">"Could not find any compatible Direct3D devices."</span> );
01489             <span class="keywordflow">break</span>;
01490 
01491         <span class="keywordflow">case</span> D3DAPPERR_NOWINDOWABLEDEVICES:
01492             Log.Error( <span class="stringliteral">"Application cannot run in a desktop window with the current display settings. "</span>
01493                         <span class="stringliteral">"Please change your desktop settings to a "</span>
01494                         <span class="stringliteral">"16- or 32-bit display mode and re-run application."</span> );
01495             <span class="keywordflow">break</span>;
01496 
01497         <span class="keywordflow">case</span> D3DAPPERR_NOHARDWAREDEVICE:
01498             Log.Error( <span class="stringliteral">"No hardware-accelerated Direct3D devices were found."</span> );
01499             <span class="keywordflow">break</span>;
01500 
01501         <span class="keywordflow">case</span> D3DAPPERR_HALNOTCOMPATIBLE:
01502             Log.Error( <span class="stringliteral">"Application requires functionality that is not available on your hardware accelerator."</span> );
01503             <span class="keywordflow">break</span>;
01504 
01505         <span class="keywordflow">case</span> D3DAPPERR_NOWINDOWEDHAL:
01506             Log.Error( <span class="stringliteral">"Your Direct3D hardware accelerator cannot render into a window."</span> );
01507             <span class="keywordflow">break</span>;
01508 
01509         <span class="keywordflow">case</span> D3DAPPERR_NODESKTOPHAL:
01510             Log.Error( <span class="stringliteral">"Your Direct3D hardware accelerator cannot"</span>
01511                        <span class="stringliteral">"render into a window with the current"</span>
01512                        <span class="stringliteral">"desktop display settings."</span> );
01513             <span class="keywordflow">break</span>;
01514 
01515         <span class="keywordflow">case</span> D3DAPPERR_NOHALTHISMODE:
01516             Log.Error( <span class="stringliteral">"Application requires functionality that is "</span>
01517                        <span class="stringliteral">"not available on your Direct3D hardware "</span>
01518                        <span class="stringliteral">"accelerator with the current desktop display "</span>
01519                        <span class="stringliteral">"settings."</span> );
01520             <span class="keywordflow">break</span>;
01521 
01522         <span class="keywordflow">case</span> D3DAPPERR_MEDIANOTFOUND:
01523         <span class="keywordflow">case</span> 0x80070002: <span class="comment">// HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ):</span>
01524             Log.Error( <span class="stringliteral">"Could not load required media."</span> );
01525             <span class="keywordflow">break</span>;
01526 
01527         <span class="keywordflow">case</span> D3DAPPERR_RESETFAILED:
01528             Log.Error( <span class="stringliteral">"Could not reset the Direct3D device."</span> );
01529             <span class="keywordflow">break</span>;
01530 
01531         <span class="keywordflow">case</span> D3DAPPERR_NONZEROREFCOUNT:
01532             Log.Error( <span class="stringliteral">"A D3D object has a non-zero reference count (meaning things were not properly cleaned up."</span> );
01533             <span class="keywordflow">break</span>;
01534 
01535         <span class="keywordflow">case</span> D3DAPPERR_NULLREFDEVICE:
01536             Log.Error( <span class="stringliteral">"Nothing will be rendered. "</span>
01537                        <span class="stringliteral">"The reference rendering device was selected, but your "</span>
01538                        <span class="stringliteral">"computer only has a reduced-functionality reference device "</span>
01539                        <span class="stringliteral">"installed.  Install the DirectX SDK to get the full "</span>
01540                        <span class="stringliteral">"reference device."</span> );
01541             <span class="keywordflow">break</span>;
01542 
01543         <span class="keywordflow">case</span> E_OUTOFMEMORY:
01544             Log.Error( <span class="stringliteral">"Not enough memory."</span> );
01545             <span class="keywordflow">break</span>;
01546 
01547         <span class="keywordflow">case</span> D3DERR_OUTOFVIDEOMEMORY:
01548            Log.Error( <span class="stringliteral">"Not enough video memory."</span> );
01549             <span class="keywordflow">break</span>;
01550 
01551         <span class="keywordflow">case</span> D3DERR_DRIVERINTERNALERROR:
01552             Log.Error( <span class="stringliteral">"A serious problem occured inside the display driver."</span> );
01553             dwType = MSGERR_APPMUSTEXIT;
01554             <span class="keywordflow">break</span>;
01555 
01556         <span class="keywordflow">default</span>:
01557             Log.Error( <span class="stringliteral">"Generic application error. Enable debug output for detailed information."</span> );
01558     }
01559 
01560     <span class="keywordflow">if</span>( MSGERR_APPMUSTEXIT == dwType )
01561     {
01562         s_bFatalErrorReported = <span class="keyword">true</span>;
01563         Log.Error( <span class="stringliteral">"Application will now exit."</span> );
01564         <span class="comment">// Close the window, which shuts down the app</span>
01565         <span class="keywordflow">if</span>( m_hWnd ) SendMessage( m_hWnd, WM_CLOSE, 0, 0 );
01566     }
01567     <span class="keywordflow">else</span>
01568     {
01569         <span class="keywordflow">if</span>( MSGWARN_SWITCHEDTOREF == dwType )
01570         {
01571             Log.Warning( <span class="stringliteral">"Switching to the reference rasterizer, a software device that implements"</span>
01572                             <span class="stringliteral">"the entire Direct3D feature set, but runs very slowly."</span> );
01573         }
01574     }
01575 
01576     <span class="keywordflow">return</span> hr;
01577 } <span class="comment">// D3DApplication::DisplayErrorMsg</span>
01578 
01579 
</pre></div><hr><address style="align: right;"><small>
Generated on Tue Jun 13 11:14:33 2006 for gRenderDX9 by <a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 width=110 height=53>
</a> 1.3.1 using KingsTools</small></address>
</body>
</html>
