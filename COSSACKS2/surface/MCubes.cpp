#include "stdheader.h"
#include <vector>
#include "MCubes.h"


// For any edge, if one vertex is inside of the surface and the other is outside of the surface
//  then the edge intersects the surface
// For each of the 8 vertices of the cube can be two possible states : either inside or outside of the surface
// For any cube the are 2^8=256 possible sets of vertex states
// This table lists the edges intersected by the surface for all 256 possible vertex states
// There are 12 edges.  For each entry in the table, if edge #n is intersected, then bit #n is set to 1

int aiCubeEdgeFlags[256]=
{
	0x000, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, 
		0x190, 0x099, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 
		0x230, 0x339, 0x033, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 
		0x3a0, 0x2a9, 0x1a3, 0x0aa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 
		0x460, 0x569, 0x663, 0x76a, 0x066, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, 
		0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0x0ff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 
		0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x055, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, 
		0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0x0cc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 
		0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x0cc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 
		0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x055, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, 
		0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0x0ff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 
		0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x066, 0x76a, 0x663, 0x569, 0x460, 
		0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0x0aa, 0x1a3, 0x2a9, 0x3a0, 
		0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x033, 0x339, 0x230, 
		0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x099, 0x190, 
		0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x000
};

//  For each of the possible vertex states listed in aiCubeEdgeFlags there is a specific triangulation
//  of the edge intersection points.  a2iTriangleConnectionTable lists all of them in the form of
//  0-5 edge triples with the list terminated by the invalid value -1.
//  For example: a2iTriangleConnectionTable[3] list the 2 triangles formed when corner[0] 
//  and corner[1] are inside of the surface, but the rest of the cube is not.
//
//  I found this table in an example program someone wrote long ago.  It was probably generated by hand

int a2iTriangleConnectionTable[256][16] =  
{
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},
	{3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},
	{3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},
	{3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1},
	{9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},
	{9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
	{2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},
	{8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},
	{9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
	{4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},
	{3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1},
	{1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},
	{4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1},
	{4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},
	{9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
	{5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},
	{2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},
	{9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
	{0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
	{2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},
	{10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},
	{4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},
	{5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},
	{5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},
	{9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},
	{0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},
	{1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},
	{10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1},
	{8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},
	{2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},
	{7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},
	{9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},
	{2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},
	{11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},
	{9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},
	{5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},
	{11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},
	{11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
	{1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},
	{9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},
	{5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},
	{2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
	{0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
	{5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},
	{6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},
	{3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1},
	{6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},
	{5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},
	{1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
	{10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},
	{6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},
	{8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},
	{7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},
	{3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
	{5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},
	{0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1},
	{9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},
	{8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1},
	{5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},
	{0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},
	{6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},
	{10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},
	{10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},
	{8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},
	{1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},
	{3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},
	{0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},
	{10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},
	{3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},
	{6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},
	{9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},
	{8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},
	{3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},
	{6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},
	{0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},
	{10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},
	{10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},
	{2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},
	{7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},
	{7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},
	{2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},
	{1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},
	{11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},
	{8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},
	{0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},
	{7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
	{10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
	{2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
	{6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},
	{7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},
	{2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},
	{1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},
	{10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},
	{10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},
	{0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},
	{7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},
	{6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},
	{8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},
	{9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},
	{6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},
	{4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},
	{10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},
	{8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},
	{0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},
	{1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},
	{8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},
	{10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},
	{4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},
	{10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
	{5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
	{11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},
	{9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
	{6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},
	{7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1},
	{3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},
	{7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1},
	{9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},
	{3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},
	{6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},
	{9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},
	{1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},
	{4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},
	{7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},
	{6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},
	{3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},
	{0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},
	{6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},
	{0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},
	{11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},
	{6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},
	{5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},
	{9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},
	{1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},
	{1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},
	{10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},
	{0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},
	{5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},
	{10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},
	{11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},
	{9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},
	{7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},
	{2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},
	{8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},
	{9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},
	{9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},
	{1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},
	{9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},
	{9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},
	{5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},
	{0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},
	{10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},
	{2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},
	{0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},
	{0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},
	{9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1},
	{5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},
	{3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},
	{5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},
	{8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},
	{0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},
	{9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},
	{1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},
	{3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},
	{4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},
	{9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},
	{11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},
	{11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},
	{2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},
	{9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},
	{3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},
	{1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1},
	{4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},
	{4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},
	{0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},
	{3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},
	{3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},
	{0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},
	{9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},
	{1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
};

//a2fVertexOffset lists the positions, relative to vertex0, of each of the 8 vertices of a cube
int a2fVertexOffset[8][3] =
{
	{0, 0, 0},{1, 0, 0},{1, 1, 0},{0, 1, 0},
	{0, 0, 1},{1, 0, 1},{1, 1, 1},{0, 1, 1}
};

//a2iEdgeConnection lists the index of the endpoint vertices for each of the 12 edges of the cube
int a2iEdgeConnection[12][2] = 
{
	{0,1}, {1,2}, {2,3}, {3,0},
	{4,5}, {5,6}, {6,7}, {7,4},
	{0,4}, {1,5}, {2,6}, {3,7}
};

#define bt(x,y) (1<<x)+(1<<y)

int ExpFacesFromEdges[12] = 
{
	bt(2,4) , bt(2,1) , bt(2,5) , bt(0,2) , 
		bt(3,4) , bt(1,3) , bt(3,5) , bt(0,3) , 
		bt(0,4) , bt(1,4) , bt(1,5) , bt(0,5)
};

int ExpFacesDir[18] = { -1,0,0    ,1, 0,0,    0,0,-1,   0,0,1,   0,-1, 0,   0, 1, 0  };

bool CubeTriangulator::GetValue(int x,int y,int z){
	return sqrt(float((x-5)*(x-5)+(y-5)*(y-5)+(z-5)*(z-5)))<4.5f||sqrt(float((x-9)*(x-9)+(y-9)*(y-9)+(z-9)*(z-9)))<4.0f;
}
void normw(float& w){
	if(w<0){
		if(w>-0.1)w=-0.1;
	}else 
	if(w>0){
		if(w<0.1)w=0.1;
	}else w=0.1;
}
DWORD CubeTriangulator::GetTriangulation(int x,int y,int z,CubeTriangulation& T){
	if(AllowDistortion)return GetDistortedTriangulation(x,y,z,T);
	int idx=0;
	float val[8];
	for(int i=0;i<8;i++){
		float vf=GetFHashed(x+a2fVertexOffset[i][0],y+a2fVertexOffset[i][1],z+a2fVertexOffset[i][2]);
		if(vf<0)idx|=1<<i;
		val[i]=vf;
	}
	int edgeflag=aiCubeEdgeFlags[idx];
	DWORD M=0;
	if(edgeflag){
		int np=0;
		int reidx[12];
		memset(reidx,0xFF,sizeof reidx);
		for(int j=0;j<12;j++){
			if(edgeflag&(1<<j)){
				M|=ExpFacesFromEdges[j];
				int e1=a2iEdgeConnection[j][0];
				int e2=a2iEdgeConnection[j][1];
				float w1=val[e2];
				float w2=val[e1];
				float w=w1-w2;
				w1/=w;
				w2/=w;
				normw(w1);
				normw(w2);
				w=w1-w2;
				T.Points[np].x=float(a2fVertexOffset[e1][0]*w1-a2fVertexOffset[e2][0]*w2)/w;
				T.Points[np].y=float(a2fVertexOffset[e1][1]*w1-a2fVertexOffset[e2][1]*w2)/w;
				T.Points[np].z=float(a2fVertexOffset[e1][2]*w1-a2fVertexOffset[e2][2]*w2)/w;				
				reidx[j]=np;
				np++;
			}
		}
		T.NPoints=np;
		int* tris=&a2iTriangleConnectionTable[idx][0];
		for(int k=0;tris[k]!=-1;k++){
			T.Indices[k]=reidx[tris[k]];
			assert(T.Indices[k]!=-1);
			T.NIndices=k+1;
		}
	}
	return M;
}
DWORD CubeTriangulator::GetDistortedTriangulation(int x,int y,int z,CubeTriangulation& T){
	int idx=0;
	float val[8];
	for(int i=0;i<8;i++){
		float vf=GetFHashed(x+a2fVertexOffset[i][0],y+a2fVertexOffset[i][1],z+a2fVertexOffset[i][2]);
		if(vf<0)idx|=1<<i;
		val[i]=vf;
	}
	int edgeflag=aiCubeEdgeFlags[idx];
	DWORD M=0;
	if(edgeflag){
		int np=0;
		int reidx[12];
		memset(reidx,0xFF,sizeof reidx);
		for(int j=0;j<12;j++){
			if(edgeflag&(1<<j)){
				M|=ExpFacesFromEdges[j];
				int e1=a2iEdgeConnection[j][0];
				int e2=a2iEdgeConnection[j][1];
				float w1=val[e2];
				float w2=val[e1];
				float w=w1-w2;
				Vector3D V1=Distort(x+a2fVertexOffset[e1][0],y+a2fVertexOffset[e1][1],z+a2fVertexOffset[e1][2]);
				Vector3D V2=Distort(x+a2fVertexOffset[e2][0],y+a2fVertexOffset[e2][1],z+a2fVertexOffset[e2][2]);
				T.Points[np].x=float(V1.x*w1-V2.x*w2)/w-x;
				T.Points[np].y=float(V1.y*w1-V2.y*w2)/w-y;
				T.Points[np].z=float(V1.z*w1-V2.z*w2)/w-z;				
				reidx[j]=np;
				np++;
			}
		}
		T.NPoints=np;
		int* tris=&a2iTriangleConnectionTable[idx][0];
		for(int k=0;tris[k]!=-1;k++){
			T.Indices[k]=reidx[tris[k]];
			assert(T.Indices[k]!=-1);
			T.NIndices=k+1;
		}
	}
	return M;
}
void CubeTriangulator::GetFullTriangilation(int x0,int y0,int z0,int x1,int y1,int z1,WholeTriangulation& WT)
{	
	float dPercent = 0.0;
	int nIteration = 0;
	int nIterationCount = x1 - x0 + 1;
	/*if(gpProgress)
		gpProgress->ShowProgress(0.0, "Triangulation process: ");*/
	int minx= 1000000;
	int maxx=-1000000;
	int miny= 1000000;
	int maxy=-1000000;
	int minz= 1000000;
	int maxz=-1000000;
	for(int x = x0; x <= x1; x++){
		float dPercentCur = float(nIteration) / nIterationCount;
		nIteration++;
		if(fabs(dPercentCur - dPercent) >= 0.01){ 
			dPercent = dPercentCur;
			/*if(gpProgress)
				gpProgress->ShowProgress(dPercent, "Triangulation process: ");*/
		}		
		for(int y=y0;y<=y1;y++){
			for(int z=z0;z<=z1;z++){
				CubeTriangulation CT;
				GetTriangulation(x,y,z,CT);
				int vidxs[12];
				for(int i=0;i<CT.NPoints;i++){

					if(x<minx)minx=x;
					if(x>maxx)maxx=x;
					if(y<miny)miny=y;
					if(y>maxy)maxy=y;
					if(z<minz)minz=z;
					if(z>maxz)maxz=z;

					Vector3D V(x+CT.Points[i].x,y+CT.Points[i].y,z+CT.Points[i].z);
					vidxs[i]=WT.AddVertex(V);						
				}
				for(int j=0;j<CT.NIndices;j++){
					WT.AddIndex(vidxs[CT.Indices[j]]);						
				}					
			}
		}
	}		
}
DWORD CubeTriangulator::getcellidx(int x,int y,int z){
	int LX=x1-x0+1;
	int LY=y1-y0+1;
	return (x-x0)+(y-y0)*LX+(z-z0)*LX*LY;
}
void CubeTriangulator::getcellcoor(int& x,int& y,int& z,DWORD V){
	int LX=x1-x0+1;
	int LY=y1-y0+1;
	x=x0+V%LX;
	V/=LX;
	y=y0+V%LY;
	V/=LY;
	z=z0+V;
}
void CubeTriangulator::GetFullTriangilationRecursive(int x,int y,int z,int x0,int y0,int z0,int x1,int y1,int z1,WholeTriangulation& WT){
	if(UseTransform){
		int xyz[]={x0,x1,y0,y1,z0,z1};
		CubeTriangulator::x0= 100000;
		CubeTriangulator::x1=-100000;
		CubeTriangulator::y0= 100000;
		CubeTriangulator::y1=-100000;
		CubeTriangulator::z0= 100000;
		CubeTriangulator::z1=-100000;
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++){
				for(int k=0;k<2;k++){
					Vector3D v1(xyz[i],xyz[2+j],xyz[4+k]);
					transform.transformPt(v1);
					if(v1.x<CubeTriangulator::x0)CubeTriangulator::x0=v1.x;
					if(v1.y<CubeTriangulator::y0)CubeTriangulator::y0=v1.y;
					if(v1.z<CubeTriangulator::z0)CubeTriangulator::z0=v1.z;
					if(v1.x>CubeTriangulator::x1)CubeTriangulator::x1=v1.x;
					if(v1.y>CubeTriangulator::y1)CubeTriangulator::y1=v1.y;
					if(v1.z>CubeTriangulator::z1)CubeTriangulator::z1=v1.z;
				}
			}
		}
	}else{
		CubeTriangulator::x0=x0;
		CubeTriangulator::x1=x1;
		CubeTriangulator::y0=y0;
		CubeTriangulator::y1=y1;
		CubeTriangulator::z0=z0;
		CubeTriangulator::z1=z1;
	}
	DWORD_hash* DH=new DWORD_hash;
	std::vector<DWORD> neib;
	std::vector<DWORD> curr;  
	if(UseTransform){
		Vector3D v(x,y,z);
		transform.transformPt(v);
		x=v.x;y=v.y;z=v.z;
	}
	int LX=CubeTriangulator::x1-CubeTriangulator::x0+1;
	int LY=CubeTriangulator::y1-CubeTriangulator::y0+1;
	int LZ=CubeTriangulator::z1-CubeTriangulator::z0+1;

	neib.push_back(getcellidx(x,y,z));
	DH->add(neib[0]);
	int npro=0;
	int nfaces=0;
	bool change=false;
	int itr=0;	
	do{
		change=false;
		for(int i=0;i<neib.size();i++){
			curr.push_back(neib[i]);
		}
		neib.clear();
		for(int i=curr.size()-1;i>=0;i--){
			npro++;
			int x,y,z;
			getcellcoor(x,y,z,curr.back());
			curr.pop_back();
			CubeTriangulation CT;
			DWORD D=GetTriangulation(x,y,z,CT);
			int vidxs[12];
			bool wasadd=!UseTransform;
			if(UseTransform){
				for(int i=0;i<CT.NPoints;i++){
					Vector3D V(x+CT.Points[i].x,y+CT.Points[i].y,z+CT.Points[i].z);
					transformInv.transformPt(V);
					if(V.x>=x0 && V.y>=y0 && V.z>=z0 && V.x<=x1 && V.y<=y1 && V.z<=z1)wasadd=true;
				}
				if(wasadd){
					for(int i=0;i<CT.NPoints;i++){
						Vector3D V(x+CT.Points[i].x,y+CT.Points[i].y,z+CT.Points[i].z);
						transformInv.transformPt(V);
						vidxs[i]=WT.AddVertex(V);
					}
				}
			}else{
				for(int i=0;i<CT.NPoints;i++){
					Vector3D V(x+CT.Points[i].x,y+CT.Points[i].y,z+CT.Points[i].z);
					vidxs[i]=WT.AddVertex(V);
				}				
			}
			if(wasadd){
				for(int j=0;j<CT.NIndices;j+=3){
					int v1=vidxs[CT.Indices[j  ]];
					int v2=vidxs[CT.Indices[j+1]];
					int v3=vidxs[CT.Indices[j+2]];
					if(v1!=v2&&v2!=v3&&v1!=v3){
						WT.AddIndex(v1);
						WT.AddIndex(v2);
						WT.AddIndex(v3);
						nfaces++;
					}
				}
			}
			if( (CT.NPoints && wasadd) || nfaces==0){
				if(CT.NPoints==0 && nfaces==0){
					D=0xFFFF;
				}
				change=true;
				int p = 0;
				int q = 0;
				for(p=0,q=0;p<18;p+=3,q++)if( D & (1<<q) ){
					int xx=x+ExpFacesDir[p  ];
					int yy=y+ExpFacesDir[p+1];
					int zz=z+ExpFacesDir[p+2];
					if(xx>=CubeTriangulator::x0 && 
					   yy>=CubeTriangulator::y0 && 
					   zz>=CubeTriangulator::z0 && 
					   xx< CubeTriangulator::x1 &&
					   yy< CubeTriangulator::y1 &&
					   zz< CubeTriangulator::z1 ){

						DWORD V=getcellidx(xx,yy,zz);
						if(!DH->check(V)){
							DH->add(V);
							neib.push_back(V);
						}
					}
				}				
			}
		}	
		itr++;
		/*if(nfaces){
		char ccc[32];
		sprintf(ccc,"c:\\jmspmesh\\itr_%d.ply",itr);
		WT.SaveToPly(ccc,1);
		}*/
	}while(change);
	float mind=10000;
	for(int i=0;i<WT.Idxs.size();i+=3){
		int v1=WT.Idxs[i];
		int v2=WT.Idxs[i+1];
		int v3=WT.Idxs[i+2];
		Vector3D V1=WT.HVert.elem(v1).vec;
		Vector3D V2=WT.HVert.elem(v2).vec;
		Vector3D V3=WT.HVert.elem(v3).vec;
		float d=V1.distance(V2);
		if(d<mind)mind=d;
		d=V1.distance(V3);
		if(d<mind)mind=d;
		d=V3.distance(V2);
		if(d<mind)mind=d;		
	}
	delete(DH);
}
int WholeTriangulation::AddVertex(Vector3D V) //it should return index of new vertex
{
	int n = HVert.numElem();
	int nIdx = HVert.find(V);
	if(nIdx == NO_ELEMENT){
		HVert.add(V);
	}else{
		n = nIdx;	
	}
	return n;
}
void WholeTriangulation::AddIndex(int v){
	Idxs.push_back(v);
}

void WholeTriangulation::SaveToPly(const char* name, float dScale){
	FILE* F=fopen(name,"w");
	if(F){
		fprintf(F,"ply\nformat ascii 1.0\nelement vertex %d\nproperty float32 x\nproperty float32 y\nproperty float32 z\nelement face %d\nproperty list int8 int32 vertex_indices\nend_header\n", HVert.numElem(), Idxs.size()/3);
		for(unsigned int i = 0; i < HVert.numElem(); i++){
			const tagVector& tvec = HVert.elem(i);
			fprintf(F, "%.05f %.05f %.05f\n", tvec.vec.x / dScale, tvec.vec.y / dScale, tvec.vec.z / dScale);
		}
		for(unsigned int j = 0; j < Idxs.size(); j += 3){
			fprintf(F, "3 %d %d %d\n", Idxs[j], Idxs[j+2], Idxs[j+1]);
		}
		fclose(F);
	}
}
void WholeTriangulation::NormalSmooth(int ntimes){
	int NInd=Idxs.size();
	int NVert = HVert.numElem();

	Vector3D* vert = new Vector3D[NVert];
	Vector3D* vert0 = new Vector3D[NVert];
	Vector3D* vert2 = new Vector3D[NVert];	
	int*      idxs = new int[NInd];	
	int*      ww   = new int[NVert];
	memset    (ww, 0, NVert*4);	

	for(int i = 0; i < NVert; i++){
		vert[i] = HVert.elem(i).vec;
		vert0[i] = vert[i];
	}
	for(int i=0;i<NInd;i++){
		idxs[i]=Idxs[i];
	}

	for(int q=0;q<ntimes;q++){
		int i;
		for(i=0;i<NVert;i++){
			vert2[i].x=0;
			vert2[i].y=0;
			vert2[i].z=0;
			ww[i]=0;
		}
		for(i=0;i<NInd;i+=3){
			int i1=idxs[i  ];
			int i2=idxs[i+1];
			int i3=idxs[i+2];

			vert2[i1].x+=vert[i2].x+vert[i3].x;
			vert2[i1].y+=vert[i2].y+vert[i3].y;
			vert2[i1].z+=vert[i2].z+vert[i3].z;

			vert2[i2].x+=vert[i1].x+vert[i3].x;
			vert2[i2].y+=vert[i1].y+vert[i3].y;
			vert2[i2].z+=vert[i1].z+vert[i3].z;

			vert2[i3].x+=vert[i2].x+vert[i1].x;
			vert2[i3].y+=vert[i2].y+vert[i1].y;
			vert2[i3].z+=vert[i2].z+vert[i1].z;

			ww[i1]+=2;
			ww[i2]+=2;
			ww[i3]+=2;
		}
		for(i=0;i<NVert;i++){
			float xx=vert2[i].x/ww[i];
			float yy=vert2[i].y/ww[i];
			float zz=vert2[i].z/ww[i];			

			float xp=vert[i].x;
			float yp=vert[i].y;
			float zp=vert[i].z;

			xx=(xx+xp*7)/8;
			yy=(yy+yp*7)/8;
			zz=(zz+zp*7)/8;			

			vert[i].x=xx;
			vert[i].y=yy;
			vert[i].z=zz;

			ww[i]=0;
		}
	}
	for(int i = 0; i < NVert; i++){
		tagVector& tvec = HVert.elem(i);
		tvec.vec = vert[i];
	}

	delete[](vert);
	delete[](vert0);
	delete[](vert2);
	delete[](idxs);
	delete[](ww);
}
void WholeTriangulation::SmartSmooth(){
	int NInd=Idxs.size();
	int NVert = HVert.numElem();

	Vector3D* vert = new Vector3D[NVert];
	Vector3D* vert0 = new Vector3D[NVert];
	Vector3D* vert2 = new Vector3D[NVert];	
	int*      idxs = new int[NInd];	
	int*      ww   = new int[NVert];
	memset    (ww, 0, NVert*4);	

	for(int i = 0; i < NVert; i++){
		vert[i] = HVert.elem(i).vec;
		vert0[i] = vert[i];
	}
	for(int i=0;i<NInd;i++){
		idxs[i]=Idxs[i];
	}

	for(int q=0;q<3;q++){
		int i;
		for(i=0;i<NVert;i++){
			vert2[i].x=0;
			vert2[i].y=0;
			vert2[i].z=0;
			ww[i]=0;
		}
		for(i=0;i<NInd;i+=3){
			int i1=idxs[i  ];
			int i2=idxs[i+1];
			int i3=idxs[i+2];

			vert2[i1].x+=vert[i2].x+vert[i3].x;
			vert2[i1].y+=vert[i2].y+vert[i3].y;
			vert2[i1].z+=vert[i2].z+vert[i3].z;

			vert2[i2].x+=vert[i1].x+vert[i3].x;
			vert2[i2].y+=vert[i1].y+vert[i3].y;
			vert2[i2].z+=vert[i1].z+vert[i3].z;

			vert2[i3].x+=vert[i2].x+vert[i1].x;
			vert2[i3].y+=vert[i2].y+vert[i1].y;
			vert2[i3].z+=vert[i2].z+vert[i1].z;

			ww[i1]+=2;
			ww[i2]+=2;
			ww[i3]+=2;
		}
		for(i=0;i<NVert;i++){
			float xx=vert2[i].x/ww[i];
			float yy=vert2[i].y/ww[i];
			float zz=vert2[i].z/ww[i];			

			float xp=vert[i].x;
			float yp=vert[i].y;
			float zp=vert[i].z;

			xx=(xx+xp*7)/8;
			yy=(yy+yp*7)/8;
			zz=(zz+zp*7)/8;

			float d=sqrt((xx-vert0[i].x)*(xx-vert0[i].x)+(yy-vert0[i].y)*(yy-vert0[i].y)+(zz-vert0[i].z)*(zz-vert0[i].z));

			d=d*d*d/8;

			vert[i].x=(xx+vert0[i].x*d)/(1+d);
			vert[i].y=(yy+vert0[i].y*d)/(1+d);
			vert[i].z=(zz+vert0[i].z*d)/(1+d);

			ww[i]=0;
		}
	}
	for(int i = 0; i < NVert; i++){
		tagVector& tvec = HVert.elem(i);
		tvec.vec = vert[i];
	}

	delete[](vert);
	delete[](vert0);
	delete[](vert2);
	delete[](idxs);
	delete[](ww);
}
Vector3D CubeTriangulator::Distort(int x,int y,int z){
	if(AllowDistortion){
		return Vector3D(
			float(x)+float(DWORD(x*113   +y*1973    +z*199451)&255)/356.0f,
			float(y)+float(DWORD(x*31397 +y*193     +z*1951  )&255)/356.0f,
			float(z)+float(DWORD(x*1715  +y*197311  +z*191   )&255)/356.0f
		);
	}else return Vector3D(x,y,z);
}
float CubeTriangulator::GetFHashed(int x,int y,int z){
	DWORD cell=DWORD(x+y*13975+z*1987531);
	cell=cell%HashSize;
	HashItem& hi=wHash[cell];
	if( hi.x==x && hi.y==y && hi.z==z )return hi.w;	
	Vector3D v=Distort(x,y,z);
	if(UseTransform)transformInv.transformPt(v);
	hi.w=GetValueF(v.x,v.y,v.z);
	hi.x=x;hi.y=y;hi.z=z;
	return hi.w;
}
CubeTriangulator::CubeTriangulator(){
	for(int i=0;i<HashSize;i++){
		HashItem& hi=wHash[i];
		hi.x=-100000000;
		hi.y=-100000000;
		hi.z=-100000000;
	}	
	UseTransform=false;
	AllowDistortion=false;
}
void CubeTriangulator::SetTransform(Matrix4D& m,bool doDistort){
	UseTransform=true;
	transform=m;
	transformInv.inverse(m);
	AllowDistortion=doDistort;
}
class testTri:public CubeTriangulator{
	virtual float GetValueF(float x,float y,float z){
		//return sqrt( float ( (x-10)*(x-10)+(y-10)*(y-10)+(z-10)*(z-10) ) )-8.0f;
		x-=50;
		y-=50;
		float r=sqrt(float(x*x+y*y))-30;
		if(r<0)r=0;
		float v=0.5+10*exp(z/2.5f-r*r/100-z*z*z/2000.0f)*(cos(r/2)+1)-z;
		return v;
	}	
};
void testtri(){
	testTri T;
	WholeTriangulation* WT=new WholeTriangulation;

	float sq6=sqrt(6.0f);
	float sq2=sqrt(2.0f);
	float sq3=sqrt(3.0f);
	Matrix3D M(2/sq6,0,1/sq3,-1/sq6,1/sq2,1/sq3,-1/sq6,-1/sq2,1/sq3);
	Matrix4D M4=M;
	Matrix4D M4i;
	M4i.inverse(M4);

	T.SetTransform(M4,true);

	T.GetFullTriangilationRecursive(1,1,0, 0,0,0,100,100,100,*WT);
	//T.GetFullTriangilation(0,0,0,300,300,100,*WT);
	WT->NormalSmooth(10);
	WT->SaveToPly("c:\\jmspmesh\\sph2.ply",1);
	delete(WT);
}